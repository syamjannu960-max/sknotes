(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"interfaces\":{\"google.firestore.v1.Firestore\":{\"retry_codes\":{\"non_idempotent\":[],\"idempotent\":[\"DEADLINE_EXCEEDED\",\"UNAVAILABLE\"],\"deadline_exceeded_resource_exhausted_internal_unavailable\":[\"DEADLINE_EXCEEDED\",\"RESOURCE_EXHAUSTED\",\"INTERNAL\",\"UNAVAILABLE\"],\"resource_exhausted_unavailable\":[\"RESOURCE_EXHAUSTED\",\"UNAVAILABLE\"],\"resource_exhausted_aborted_unavailable\":[\"RESOURCE_EXHAUSTED\",\"ABORTED\",\"UNAVAILABLE\"]},\"retry_params\":{\"default\":{\"initial_retry_delay_millis\":100,\"retry_delay_multiplier\":1.3,\"max_retry_delay_millis\":60000,\"initial_rpc_timeout_millis\":60000,\"rpc_timeout_multiplier\":1,\"max_rpc_timeout_millis\":60000,\"total_timeout_millis\":600000}},\"methods\":{\"GetDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"ListDocuments\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"UpdateDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"resource_exhausted_unavailable\",\"retry_params_name\":\"default\"},\"DeleteDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"BatchGetDocuments\":{\"timeout_millis\":300000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"BeginTransaction\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"Commit\":{\"timeout_millis\":60000,\"retry_codes_name\":\"resource_exhausted_unavailable\",\"retry_params_name\":\"default\"},\"Rollback\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"RunQuery\":{\"timeout_millis\":300000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"RunAggregationQuery\":{\"timeout_millis\":300000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"PartitionQuery\":{\"timeout_millis\":300000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"Write\":{\"timeout_millis\":86400000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"Listen\":{\"timeout_millis\":86400000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"ListCollectionIds\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_resource_exhausted_internal_unavailable\",\"retry_params_name\":\"default\"},\"BatchWrite\":{\"timeout_millis\":60000,\"retry_codes_name\":\"resource_exhausted_aborted_unavailable\",\"retry_params_name\":\"default\"},\"CreateDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"resource_exhausted_unavailable\",\"retry_params_name\":\"default\"}}}}}"));}}),
"[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
/*!
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Deferred = void 0;
exports.autoId = autoId;
exports.requestTag = requestTag;
exports.isObject = isObject;
exports.isPlainObject = isPlainObject;
exports.isEmpty = isEmpty;
exports.isFunction = isFunction;
exports.isPermanentRpcError = isPermanentRpcError;
exports.getRetryCodes = getRetryCodes;
exports.getTotalTimeout = getTotalTimeout;
exports.getRetryParams = getRetryParams;
exports.silencePromise = silencePromise;
exports.wrapError = wrapError;
exports.tryGetPreferRestEnvironmentVariable = tryGetPreferRestEnvironmentVariable;
exports.mapToArray = mapToArray;
exports.isArrayEqual = isArrayEqual;
exports.isPrimitiveArrayEqual = isPrimitiveArrayEqual;
const crypto_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/crypto-browserify/index.js [app-client] (ecmascript)");
const gapicConfig = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json (json)");
/**
 * A Promise implementation that supports deferred resolution.
 * @private
 * @internal
 */ class Deferred {
    constructor(){
        this.resolve = ()=>{};
        this.reject = ()=>{};
        this.promise = new Promise((resolve, reject)=>{
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}
exports.Deferred = Deferred;
/**
 * Generate a unique client-side identifier.
 *
 * Used for the creation of new documents.
 *
 * @private
 * @internal
 * @returns {string} A unique 20-character wide identifier.
 */ function autoId() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let autoId = '';
    while(autoId.length < 20){
        const bytes = (0, crypto_1.randomBytes)(40);
        bytes.forEach((b)=>{
            // Length of `chars` is 62. We only take bytes between 0 and 62*4-1
            // (both inclusive). The value is then evenly mapped to indices of `char`
            // via a modulo operation.
            const maxValue = 62 * 4 - 1;
            if (autoId.length < 20 && b <= maxValue) {
                autoId += chars.charAt(b % 62);
            }
        });
    }
    return autoId;
}
/**
 * Generate a short and semi-random client-side identifier.
 *
 * Used for the creation of request tags.
 *
 * @private
 * @internal
 * @returns {string} A random 5-character wide identifier.
 */ function requestTag() {
    return autoId().substr(0, 5);
}
/**
 * Determines whether `value` is a JavaScript object.
 *
 * @private
 * @internal
 */ function isObject(value) {
    return Object.prototype.toString.call(value) === '[object Object]';
}
/**
 * Verifies that 'obj' is a plain JavaScript object that can be encoded as a
 * 'Map' in Firestore.
 *
 * @private
 * @internal
 * @param input The argument to verify.
 * @returns 'true' if the input can be a treated as a plain object.
 */ function isPlainObject(input) {
    return isObject(input) && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null || input.constructor.name === 'Object');
}
/**
 * Returns whether `value` has no custom properties.
 *
 * @private
 * @internal
 */ function isEmpty(value) {
    return Object.keys(value).length === 0;
}
/**
 * Determines whether `value` is a JavaScript function.
 *
 * @private
 * @internal
 */ function isFunction(value) {
    return typeof value === 'function';
}
/**
 * Determines whether the provided error is considered permanent for the given
 * RPC.
 *
 * @private
 * @internal
 */ function isPermanentRpcError(err, methodName) {
    if (err.code !== undefined) {
        const retryCodes = getRetryCodes(methodName);
        return retryCodes.indexOf(err.code) === -1;
    } else {
        return false;
    }
}
let serviceConfig;
/**
 * Lazy-loads the service config when first accessed.
 * @private
 * @internal
 **/ function getServiceConfig(methodName) {
    if (!serviceConfig) {
        serviceConfig = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)").constructSettings('google.firestore.v1.Firestore', gapicConfig, {}, __turbopack_context__.r("[project]/node_modules/google-gax/build/src/status.js [app-client] (ecmascript)").Status);
    }
    return serviceConfig[methodName];
}
/**
 * Returns the list of retryable error codes specified in the service
 * configuration.
 * @private
 * @internal
 */ function getRetryCodes(methodName) {
    var _a, _b, _c;
    return (_c = (_b = (_a = getServiceConfig(methodName)) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.retryCodes) !== null && _c !== void 0 ? _c : [];
}
/**
 * Gets the total timeout in milliseconds from the retry settings in
 * the service config for the given RPC. If the total timeout is not
 * set, then `0` is returned.
 *
 * @private
 * @internal
 */ function getTotalTimeout(methodName) {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = getServiceConfig(methodName)) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.backoffSettings) === null || _c === void 0 ? void 0 : _c.totalTimeoutMillis) !== null && _d !== void 0 ? _d : 0;
}
/**
 * Returns the backoff setting from the service configuration.
 * @private
 * @internal
 */ function getRetryParams(methodName) {
    var _a, _b, _c;
    return (_c = (_b = (_a = getServiceConfig(methodName)) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.backoffSettings) !== null && _c !== void 0 ? _c : __turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)").createDefaultBackoffSettings();
}
/**
 * Returns a promise with a void return type. The returned promise swallows all
 * errors and never throws.
 *
 * This is primarily used to wait for a promise to complete when the result of
 * the promise will be discarded.
 *
 * @private
 * @internal
 */ function silencePromise(promise) {
    return promise.then(()=>{}, ()=>{});
}
/**
 * Wraps the provided error in a new error that includes the provided stack.
 *
 * Used to preserve stack traces across async calls.
 * @private
 * @internal
 */ function wrapError(err, stack) {
    err.stack += '\nCaused by: ' + stack;
    return err;
}
/**
 * Parses the value of the environment variable FIRESTORE_PREFER_REST, and
 * returns a value indicating if the environment variable enables or disables
 * preferRest.
 *
 * This function will warn to the console if the environment variable is set
 * to an unsupported value.
 *
 * @return `true` if the environment variable enables `preferRest`,
 * `false` if the environment variable disables `preferRest`, or `undefined`
 * if the environment variable is not set or is set to an unsupported value.
 *
 * @internal
 * @private
 */ function tryGetPreferRestEnvironmentVariable() {
    var _a;
    const rawValue = (_a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.FIRESTORE_PREFER_REST) === null || _a === void 0 ? void 0 : _a.trim().toLowerCase();
    if (rawValue === undefined) {
        return undefined;
    } else if (rawValue === '1' || rawValue === 'true') {
        return true;
    } else if (rawValue === '0' || rawValue === 'false') {
        return false;
    } else {
        // eslint-disable-next-line no-console
        console.warn(`An unsupported value was specified for the environment variable FIRESTORE_PREFER_REST. Value ${rawValue} is unsupported.`);
        return undefined;
    }
}
/**
 * Returns an array of values that are calculated by performing the given `fn`
 * on all keys in the given `obj` dictionary.
 *
 * @private
 * @internal
 */ function mapToArray(obj, fn) {
    const result = [];
    for(const key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            result.push(fn(obj[key], key, obj));
        }
    }
    return result;
}
/**
 * Verifies equality for an array of objects using the `isEqual` interface.
 *
 * @private
 * @internal
 * @param left Array of objects supporting `isEqual`.
 * @param right Array of objects supporting `isEqual`.
 * @return True if arrays are equal.
 */ function isArrayEqual(left, right) {
    if (left.length !== right.length) {
        return false;
    }
    for(let i = 0; i < left.length; ++i){
        if (!left[i].isEqual(right[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Verifies equality for an array of primitives.
 *
 * @private
 * @internal
 * @param left Array of primitives.
 * @param right Array of primitives.
 * @return True if arrays are equal.
 */ function isPrimitiveArrayEqual(left, right) {
    if (left.length !== right.length) {
        return false;
    }
    for(let i = 0; i < left.length; ++i){
        if (left[i] !== right[i]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Timestamp = void 0;
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
/*!
 * Number of nanoseconds in a millisecond.
 *
 * @type {number}
 */ const MS_TO_NANOS = 1000000;
/*!
 * The minimum legal value for the "seconds" property of a Timestamp object.
 *
 * This value corresponds to 0001-01-01T00:00:00Z.
 *
 * @type {number}
 */ const MIN_SECONDS = -62135596800;
/*!
 * The maximum legal value for the "seconds" property of a Timestamp object.
 *
 * This value corresponds to 9999-12-31T23:59:59.999999999Z.
 *
 * @type {number}
 */ const MAX_SECONDS = 253402300799;
/**
 * A Timestamp represents a point in time independent of any time zone or
 * calendar, represented as seconds and fractions of seconds at nanosecond
 * resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian
 * Calendar which extends the Gregorian calendar backwards to year one. It is
 * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are
 * "smeared" so that no leap second table is needed for interpretation. Range is
 * from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.
 *
 * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto
 */ class Timestamp {
    /**
     * Creates a new timestamp with the current date, with millisecond precision.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.set({ updateTime:Firestore.Timestamp.now() });
     *
     * ```
     * @return {Timestamp} A new `Timestamp` representing the current date.
     */ static now() {
        return Timestamp.fromMillis(Date.now());
    }
    /**
     * Creates a new timestamp from the given date.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * let date = Date.parse('01 Jan 2000 00:00:00 GMT');
     * documentRef.set({ startTime:Firestore.Timestamp.fromDate(date) });
     *
     * ```
     * @param {Date} date The date to initialize the `Timestamp` from.
     * @return {Timestamp} A new `Timestamp` representing the same point in time
     * as the given date.
     */ static fromDate(date) {
        return Timestamp.fromMillis(date.getTime());
    }
    /**
     * Creates a new timestamp from the given number of milliseconds.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.set({ startTime:Firestore.Timestamp.fromMillis(42) });
     *
     * ```
     * @param {number} milliseconds Number of milliseconds since Unix epoch
     * 1970-01-01T00:00:00Z.
     * @return {Timestamp}  A new `Timestamp` representing the same point in time
     * as the given number of milliseconds.
     */ static fromMillis(milliseconds) {
        const seconds = Math.floor(milliseconds / 1000);
        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);
        return new Timestamp(seconds, nanos);
    }
    /**
     * Generates a `Timestamp` object from a Timestamp proto.
     *
     * @private
     * @internal
     * @param {Object} timestamp The `Timestamp` Protobuf object.
     */ static fromProto(timestamp) {
        return new Timestamp(Number(timestamp.seconds || 0), timestamp.nanos || 0);
    }
    /**
     * Creates a new timestamp.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.set({ startTime:new Firestore.Timestamp(42, 0) });
     *
     * ```
     * @param {number} seconds The number of seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * @param {number} nanoseconds The non-negative fractions of a second at
     * nanosecond resolution. Negative second values with fractions must still
     * have non-negative nanoseconds values that count forward in time. Must be
     * from 0 to 999,999,999 inclusive.
     */ constructor(seconds, nanoseconds){
        (0, validate_1.validateInteger)('seconds', seconds, {
            minValue: MIN_SECONDS,
            maxValue: MAX_SECONDS
        });
        (0, validate_1.validateInteger)('nanoseconds', nanoseconds, {
            minValue: 0,
            maxValue: 999999999
        });
        this._seconds = seconds;
        this._nanoseconds = nanoseconds;
    }
    /**
     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(snap => {
     *   let updated = snap.updateTime;
     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);
     * });
     *
     * ```
     * @type {number}
     */ get seconds() {
        return this._seconds;
    }
    /**
     * The non-negative fractions of a second at nanosecond resolution.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(snap => {
     *   let updated = snap.updateTime;
     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);
     * });
     *
     * ```
     * @type {number}
     */ get nanoseconds() {
        return this._nanoseconds;
    }
    /**
     * Returns a new `Date` corresponding to this timestamp. This may lose
     * precision.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(snap => {
     *   console.log(`Document updated at: ${snap.updateTime.toDate()}`);
     * });
     *
     * ```
     * @return {Date} JavaScript `Date` object representing the same point in time
     * as this `Timestamp`, with millisecond precision.
     */ toDate() {
        return new Date(this._seconds * 1000 + Math.round(this._nanoseconds / MS_TO_NANOS));
    }
    /**
     * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(snap => {
     *   let startTime = snap.get('startTime');
     *   let endTime = snap.get('endTime');
     *   console.log(`Duration: ${endTime - startTime}`);
     * });
     *
     * ```
     * @return {number} The point in time corresponding to this timestamp,
     * represented as the number of milliseconds since Unix epoch
     * 1970-01-01T00:00:00Z.
     */ toMillis() {
        return this._seconds * 1000 + Math.floor(this._nanoseconds / MS_TO_NANOS);
    }
    /**
     * Returns 'true' if this `Timestamp` is equal to the provided one.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(snap => {
     *   if (snap.createTime.isEqual(snap.updateTime)) {
     *     console.log('Document is in its initial state.');
     *   }
     * });
     *
     * ```
     * @param {any} other The `Timestamp` to compare against.
     * @return {boolean} 'true' if this `Timestamp` is equal to the provided one.
     */ isEqual(other) {
        return this === other || other instanceof Timestamp && this._seconds === other.seconds && this._nanoseconds === other.nanoseconds;
    }
    /**
     * Generates the Protobuf `Timestamp` object for this timestamp.
     *
     * @private
     * @internal
     * @returns {Object} The `Timestamp` Protobuf object.
     */ toProto() {
        const timestamp = {};
        if (this.seconds) {
            timestamp.seconds = this.seconds.toString();
        }
        if (this.nanoseconds) {
            timestamp.nanos = this.nanoseconds;
        }
        return {
            timestampValue: timestamp
        };
    }
    /**
     * Converts this object to a primitive `string`, which allows `Timestamp` objects to be compared
     * using the `>`, `<=`, `>=` and `>` operators.
     *
     * @return {string} a string encoding of this object.
     */ valueOf() {
        // This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is
        // translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded
        // with zeroes to be a consistent length. Strings with this format then have a lexicographical
        // ordering that matches the expected ordering. The <seconds> translation is done to avoid
        // having a leading negative sign (i.e. a leading '-' character) in its string representation,
        // which would affect its lexicographical ordering.
        const adjustedSeconds = this.seconds - MIN_SECONDS;
        // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.
        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');
        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');
        return formattedSeconds + '.' + formattedNanoseconds;
    }
}
exports.Timestamp = Timestamp; //# sourceMappingURL=timestamp.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.customObjectMessage = customObjectMessage;
exports.validateFunction = validateFunction;
exports.validateObject = validateObject;
exports.validateString = validateString;
exports.validateHost = validateHost;
exports.validateBoolean = validateBoolean;
exports.validateNumber = validateNumber;
exports.validateInteger = validateInteger;
exports.validateTimestamp = validateTimestamp;
exports.invalidArgumentMessage = invalidArgumentMessage;
exports.validateOptional = validateOptional;
exports.validateMinNumberOfArguments = validateMinNumberOfArguments;
exports.validateMaxNumberOfArguments = validateMaxNumberOfArguments;
exports.validateEnumValue = validateEnumValue;
const url_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const timestamp_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
/**
 * Generates an error message to use with custom objects that cannot be
 * serialized.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The value that failed serialization.
 * @param path The field path that the object is assigned to.
 */ function customObjectMessage(arg, value, path) {
    const fieldPathMessage = path ? ` (found in field "${path}")` : '';
    if ((0, util_1.isObject)(value)) {
        // We use the base class name as the type name as the sentinel classes
        // returned by the public FieldValue API are subclasses of FieldValue. By
        // using the base name, we reduce the number of special cases below.
        const typeName = value.constructor.name;
        switch(typeName){
            case 'DocumentReference':
            case 'FieldPath':
            case 'FieldValue':
            case 'GeoPoint':
            case 'Timestamp':
                return `${invalidArgumentMessage(arg, 'Firestore document')} Detected an object of type "${typeName}" that doesn't match the ` + `expected instance${fieldPathMessage}. Please ensure that the ` + 'Firestore types you are using are from the same NPM package.)';
            case 'Object':
                return `${invalidArgumentMessage(arg, 'Firestore document')} Invalid use of type "${typeof value}" as a Firestore argument${fieldPathMessage}.`;
            default:
                return `${invalidArgumentMessage(arg, 'Firestore document')} Couldn't serialize object of type "${typeName}"${fieldPathMessage}. Firestore doesn't support JavaScript ` + 'objects with custom prototypes (i.e. objects that were created ' + 'via the "new" operator).';
        }
    } else {
        return `${invalidArgumentMessage(arg, 'Firestore document')} Input is not a plain JavaScript object${fieldPathMessage}.`;
    }
}
/**
 * Validates that 'value' is a function.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the function can be omitted.
 */ function validateFunction(arg, value, options) {
    if (!validateOptional(value, options)) {
        if (!(0, util_1.isFunction)(value)) {
            throw new Error(invalidArgumentMessage(arg, 'function'));
        }
    }
}
/**
 * Validates that 'value' is an object.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the object can be omitted.
 */ function validateObject(arg, value, options) {
    if (!validateOptional(value, options)) {
        if (!(0, util_1.isObject)(value)) {
            throw new Error(invalidArgumentMessage(arg, 'object'));
        }
    }
}
/**
 * Validates that 'value' is a string.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the string can be omitted.
 */ function validateString(arg, value, options) {
    if (!validateOptional(value, options)) {
        if (typeof value !== 'string') {
            throw new Error(invalidArgumentMessage(arg, 'string'));
        }
    }
}
/**
 * Validates that 'value' is a host.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the host can be omitted.
 */ function validateHost(arg, value, options) {
    if (!validateOptional(value, options)) {
        validateString(arg, value);
        const urlString = `http://${value}/`;
        let parsed;
        try {
            parsed = new url_1.URL(urlString);
        } catch (e) {
            throw new Error(invalidArgumentMessage(arg, 'host'));
        }
        if (parsed.search !== '' || parsed.pathname !== '/' || parsed.username !== '') {
            throw new Error(invalidArgumentMessage(arg, 'host'));
        }
    }
}
/**
 * Validates that 'value' is a boolean.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the boolean can be omitted.
 */ function validateBoolean(arg, value, options) {
    if (!validateOptional(value, options)) {
        if (typeof value !== 'boolean') {
            throw new Error(invalidArgumentMessage(arg, 'boolean'));
        }
    }
}
/**
 * Validates that 'value' is a number.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the number can be omitted.
 */ function validateNumber(arg, value, options) {
    const min = options !== undefined && options.minValue !== undefined ? options.minValue : -Infinity;
    const max = options !== undefined && options.maxValue !== undefined ? options.maxValue : Infinity;
    if (!validateOptional(value, options)) {
        if (typeof value !== 'number' || isNaN(value)) {
            throw new Error(invalidArgumentMessage(arg, 'number'));
        } else if (value < min || value > max) {
            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);
        }
    }
}
/**
 * Validates that 'value' is a integer.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the integer can be omitted.
 */ function validateInteger(arg, value, options) {
    const min = options !== undefined && options.minValue !== undefined ? options.minValue : -Infinity;
    const max = options !== undefined && options.maxValue !== undefined ? options.maxValue : Infinity;
    if (!validateOptional(value, options)) {
        if (typeof value !== 'number' || isNaN(value) || value % 1 !== 0) {
            throw new Error(invalidArgumentMessage(arg, 'integer'));
        } else if (value < min || value > max) {
            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);
        }
    }
}
/**
 * Validates that 'value' is a Timestamp.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the Timestamp can be omitted.
 */ function validateTimestamp(arg, value, options) {
    if (!validateOptional(value, options)) {
        if (!(value instanceof timestamp_1.Timestamp)) {
            throw new Error(invalidArgumentMessage(arg, 'Timestamp'));
        }
    }
}
/**
 * Generates an error message to use with invalid arguments.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param expectedType The expected input type.
 */ function invalidArgumentMessage(arg, expectedType) {
    return `${formatArgumentName(arg)} is not a valid ${expectedType}.`;
}
/**
 * Enforces the 'options.optional' constraint for 'value'.
 *
 * @private
 * @internal
 * @param value The input to validate.
 * @param options Whether the function can be omitted.
 * @return Whether the object is omitted and is allowed to be omitted.
 */ function validateOptional(value, options) {
    return value === undefined && options !== undefined && options.optional === true;
}
/**
 * Formats the given word as plural conditionally given the preceding number.
 *
 * @private
 * @internal
 * @param num The number to use for formatting.
 * @param str The string to format.
 */ function formatPlural(num, str) {
    return `${num} ${str}` + (num === 1 ? '' : 's');
}
/**
 * Creates a descriptive name for the provided argument name or index.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @return Either the argument name or its index description.
 */ function formatArgumentName(arg) {
    return typeof arg === 'string' ? `Value for argument "${arg}"` : `Element at index ${arg}`;
}
/**
 * Verifies that 'args' has at least 'minSize' elements.
 *
 * @private
 * @internal
 * @param funcName The function name to use in the error message.
 * @param args The array (or array-like structure) to verify.
 * @param minSize The minimum number of elements to enforce.
 * @throws if the expectation is not met.
 */ function validateMinNumberOfArguments(funcName, args, minSize) {
    if (args.length < minSize) {
        throw new Error(`Function "${funcName}()" requires at least ` + `${formatPlural(minSize, 'argument')}.`);
    }
}
/**
 * Verifies that 'args' has at most 'maxSize' elements.
 *
 * @private
 * @internal
 * @param funcName The function name to use in the error message.
 * @param args The array (or array-like structure) to verify.
 * @param maxSize The maximum number of elements to enforce.
 * @throws if the expectation is not met.
 */ function validateMaxNumberOfArguments(funcName, args, maxSize) {
    if (args.length > maxSize) {
        throw new Error(`Function "${funcName}()" accepts at most ` + `${formatPlural(maxSize, 'argument')}.`);
    }
}
/**
 * Validates that the provided named option equals one of the expected values.
 *
 * @param arg The argument name or argument index (for varargs methods).).
 * @param value The input to validate.
 * @param allowedValues A list of expected values.
 * @param options Whether the input can be omitted.
 * @private
 * @internal
 */ function validateEnumValue(arg, value, allowedValues, options) {
    if (!validateOptional(value, options)) {
        const expectedDescription = [];
        for (const allowed of allowedValues){
            if (allowed === value) {
                return;
            }
            expectedDescription.push(allowed);
        }
        throw new Error(`${formatArgumentName(arg)} is invalid. Acceptable values are: ${expectedDescription.join(', ')}`);
    }
} //# sourceMappingURL=validate.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.logger = logger;
exports.setLogFunction = setLogFunction;
exports.setLibVersion = setLibVersion;
const util = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
/*! The Firestore library version */ let libVersion;
/*! The external function used to emit logs. */ let logFunction = null;
/**
 * Log function to use for debug output. By default, we don't perform any
 * logging.
 *
 * @private
 * @internal
 */ function logger(methodName, requestTag, logMessage, ...additionalArgs) {
    requestTag = requestTag || '#####';
    if (logFunction) {
        const formattedMessage = util.format(logMessage, ...additionalArgs);
        const time = new Date().toISOString();
        logFunction(`Firestore (${libVersion}) ${time} ${requestTag} [${methodName}]: ` + formattedMessage);
    }
}
/**
 * Sets or disables the log function for all active Firestore instances.
 *
 * @param logger A log function that takes a message (such as `console.log`) or
 * `null` to turn off logging.
 */ function setLogFunction(logger) {
    if (logger !== null) (0, validate_1.validateFunction)('logger', logger);
    logFunction = logger;
}
/**
 * Sets the library version to be used in log messages.
 *
 * @private
 * @internal
 */ function setLibVersion(version) {
    libVersion = version;
} //# sourceMappingURL=logger.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/backoff.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExponentialBackoff = exports.delayExecution = exports.MAX_RETRY_ATTEMPTS = exports.DEFAULT_BACKOFF_FACTOR = exports.DEFAULT_BACKOFF_MAX_DELAY_MS = exports.DEFAULT_BACKOFF_INITIAL_DELAY_MS = void 0;
exports.setTimeoutHandler = setTimeoutHandler;
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
/*
 * @module firestore/backoff
 * @private
 * @internal
 *
 * Contains backoff logic to facilitate RPC error handling. This class derives
 * its implementation from the Firestore Mobile Web Client.
 *
 * @see https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/remote/backoff.ts
 */ /*!
 * The default initial backoff time in milliseconds after an error.
 * Set to 1s according to https://cloud.google.com/apis/design/errors.
 */ exports.DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;
/*!
 * The default maximum backoff time in milliseconds.
 */ exports.DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;
/*!
 * The default factor to increase the backup by after each failed attempt.
 */ exports.DEFAULT_BACKOFF_FACTOR = 1.5;
/*!
 * The default jitter to distribute the backoff attempts by (0 means no
 * randomization, 1.0 means +/-50% randomization).
 */ const DEFAULT_JITTER_FACTOR = 1.0;
/*!
 * The maximum number of retries that will be attempted by backoff
 * before stopping all retry attempts.
 */ exports.MAX_RETRY_ATTEMPTS = 10;
/*!
 * The timeout handler used by `ExponentialBackoff` and `BulkWriter`.
 */ exports.delayExecution = setTimeout;
/**
 * Allows overriding of the timeout handler used by the exponential backoff
 * implementation. If not invoked, we default to `setTimeout()`.
 *
 * Used only in testing.
 *
 * @private
 * @internal
 * @param {function} handler A handler than matches the API of `setTimeout()`.
 */ function setTimeoutHandler(handler) {
    exports.delayExecution = (f, ms)=>{
        handler(f, ms);
        const timeout = {
            hasRef: ()=>{
                throw new Error('For tests only. Not Implemented');
            },
            ref: ()=>{
                throw new Error('For tests only. Not Implemented');
            },
            refresh: ()=>{
                throw new Error('For tests only. Not Implemented');
            },
            unref: ()=>{
                throw new Error('For tests only. Not Implemented');
            },
            [Symbol.toPrimitive]: ()=>{
                throw new Error('For tests only. Not Implemented');
            }
        };
        // `NodeJS.Timeout` type signature change:
        // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/66176/files#diff-e838d0ace9cd5f6516bacfbd3ad00d02cd37bd60f9993ce6223f52d889a1fdbaR122-R126
        //
        // Adding `[Symbol.dispose](): void;` cannot be done on older versions of
        // NodeJS. So we simply cast to `NodeJS.Timeout`.
        return timeout;
    };
}
/**
 * A helper for running delayed tasks following an exponential backoff curve
 * between attempts.
 *
 * Each delay is made up of a "base" delay which follows the exponential
 * backoff curve, and a "jitter" (+/- 50% by default)  that is calculated and
 * added to the base delay. This prevents clients from accidentally
 * synchronizing their delays causing spikes of load to the backend.
 *
 * @private
 * @internal
 */ class ExponentialBackoff {
    constructor(options = {}){
        /**
         * The number of retries that has been attempted.
         *
         * @private
         * @internal
         */ this._retryCount = 0;
        /**
         * The backoff delay of the current attempt.
         *
         * @private
         * @internal
         */ this.currentBaseMs = 0;
        /**
         * Whether we are currently waiting for backoff to complete.
         *
         * @private
         * @internal
         */ this.awaitingBackoffCompletion = false;
        this.initialDelayMs = options.initialDelayMs !== undefined ? options.initialDelayMs : exports.DEFAULT_BACKOFF_INITIAL_DELAY_MS;
        this.backoffFactor = options.backoffFactor !== undefined ? options.backoffFactor : exports.DEFAULT_BACKOFF_FACTOR;
        this.maxDelayMs = options.maxDelayMs !== undefined ? options.maxDelayMs : exports.DEFAULT_BACKOFF_MAX_DELAY_MS;
        this.jitterFactor = options.jitterFactor !== undefined ? options.jitterFactor : DEFAULT_JITTER_FACTOR;
    }
    /**
     * Resets the backoff delay and retry count.
     *
     * The very next backoffAndWait() will have no delay. If it is called again
     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
     * subsequent ones will increase according to the backoffFactor.
     *
     * @private
     * @internal
     */ reset() {
        this._retryCount = 0;
        this.currentBaseMs = 0;
    }
    /**
     * Resets the backoff delay to the maximum delay (e.g. for use after a
     * RESOURCE_EXHAUSTED error).
     *
     * @private
     * @internal
     */ resetToMax() {
        this.currentBaseMs = this.maxDelayMs;
    }
    /**
     * Returns a promise that resolves after currentDelayMs, and increases the
     * delay for any subsequent attempts.
     *
     * @return A Promise that resolves when the current delay elapsed.
     * @private
     * @internal
     */ backoffAndWait() {
        if (this.awaitingBackoffCompletion) {
            return Promise.reject(new Error('A backoff operation is already in progress.'));
        }
        if (this.retryCount > exports.MAX_RETRY_ATTEMPTS) {
            return Promise.reject(new Error('Exceeded maximum number of retries allowed.'));
        }
        // First schedule using the current base (which may be 0 and should be
        // honored as such).
        const delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();
        if (this.currentBaseMs > 0) {
            (0, logger_1.logger)('ExponentialBackoff.backoffAndWait', null, `Backing off for ${delayWithJitterMs} ms ` + `(base delay: ${this.currentBaseMs} ms)`);
        }
        // Apply backoff factor to determine next delay and ensure it is within
        // bounds.
        this.currentBaseMs *= this.backoffFactor;
        this.currentBaseMs = Math.max(this.currentBaseMs, this.initialDelayMs);
        this.currentBaseMs = Math.min(this.currentBaseMs, this.maxDelayMs);
        this._retryCount += 1;
        return new Promise((resolve)=>{
            this.awaitingBackoffCompletion = true;
            (0, exports.delayExecution)(()=>{
                this.awaitingBackoffCompletion = false;
                resolve();
            }, delayWithJitterMs);
        });
    }
    // Visible for testing.
    get retryCount() {
        return this._retryCount;
    }
    /**
     * Returns a randomized "jitter" delay based on the current base and jitter
     * factor.
     *
     * @returns {number} The jitter to apply based on the current delay.
     * @private
     * @internal
     */ jitterDelayMs() {
        return (Math.random() - 0.5) * this.jitterFactor * this.currentBaseMs;
    }
}
exports.ExponentialBackoff = ExponentialBackoff; //# sourceMappingURL=backoff.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/rate-limiter.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RateLimiter = void 0;
/*!
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
/**
 * A helper that uses the Token Bucket algorithm to rate limit the number of
 * operations that can be made in a second.
 *
 * Before a given request containing a number of operations can proceed,
 * RateLimiter determines doing so stays under the provided rate limits. It can
 * also determine how much time is required before a request can be made.
 *
 * RateLimiter can also implement a gradually increasing rate limit. This is
 * used to enforce the 500/50/5 rule
 * (https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic).
 *
 * @private
 * @internal
 */ class RateLimiter {
    /**
     * @param initialCapacity Initial maximum number of operations per second.
     * @param multiplier Rate by which to increase the capacity.
     * @param multiplierMillis How often the capacity should increase in
     * milliseconds.
     * @param maximumCapacity Maximum number of allowed operations per second.
     * The number of tokens added per second will never exceed this number.
     * @param startTimeMillis The starting time in epoch milliseconds that the
     * rate limit is based on. Used for testing the limiter.
     */ constructor(initialCapacity, multiplier, multiplierMillis, maximumCapacity, startTimeMillis = Date.now()){
        this.initialCapacity = initialCapacity;
        this.multiplier = multiplier;
        this.multiplierMillis = multiplierMillis;
        this.maximumCapacity = maximumCapacity;
        this.startTimeMillis = startTimeMillis;
        this.availableTokens = initialCapacity;
        this.lastRefillTimeMillis = startTimeMillis;
        this.previousCapacity = initialCapacity;
    }
    /**
     * Tries to make the number of operations. Returns true if the request
     * succeeded and false otherwise.
     *
     * @param requestTimeMillis The time used to calculate the number of available
     * tokens. Used for testing the limiter.
     * @private
     * @internal
     */ tryMakeRequest(numOperations, requestTimeMillis = Date.now()) {
        this.refillTokens(requestTimeMillis);
        if (numOperations <= this.availableTokens) {
            this.availableTokens -= numOperations;
            return true;
        }
        return false;
    }
    /**
     * Returns the number of ms needed to make a request with the provided number
     * of operations. Returns 0 if the request can be made with the existing
     * capacity. Returns -1 if the request is not possible with the current
     * capacity.
     *
     * @param requestTimeMillis The time used to calculate the number of available
     * tokens. Used for testing the limiter.
     * @private
     * @internal
     */ getNextRequestDelayMs(numOperations, requestTimeMillis = Date.now()) {
        this.refillTokens(requestTimeMillis);
        if (numOperations < this.availableTokens) {
            return 0;
        }
        const capacity = this.calculateCapacity(requestTimeMillis);
        if (capacity < numOperations) {
            return -1;
        }
        const requiredTokens = numOperations - this.availableTokens;
        return Math.ceil(requiredTokens * 1000 / capacity);
    }
    /**
     * Refills the number of available tokens based on how much time has elapsed
     * since the last time the tokens were refilled.
     *
     * @param requestTimeMillis The time used to calculate the number of available
     * tokens. Used for testing the limiter.
     * @private
     * @internal
     */ refillTokens(requestTimeMillis) {
        if (requestTimeMillis >= this.lastRefillTimeMillis) {
            const elapsedTime = requestTimeMillis - this.lastRefillTimeMillis;
            const capacity = this.calculateCapacity(requestTimeMillis);
            const tokensToAdd = Math.floor(elapsedTime * capacity / 1000);
            if (tokensToAdd > 0) {
                this.availableTokens = Math.min(capacity, this.availableTokens + tokensToAdd);
                this.lastRefillTimeMillis = requestTimeMillis;
            }
        } else {
            throw new Error('Request time should not be before the last token refill time.');
        }
    }
    /**
     * Calculates the maximum capacity based on the provided date.
     *
     * @private
     * @internal
     */ // Visible for testing.
    calculateCapacity(requestTimeMillis) {
        assert(requestTimeMillis >= this.startTimeMillis, 'startTime cannot be after currentTime');
        const millisElapsed = requestTimeMillis - this.startTimeMillis;
        const operationsPerSecond = Math.min(Math.floor(Math.pow(this.multiplier, Math.floor(millisElapsed / this.multiplierMillis)) * this.initialCapacity), this.maximumCapacity);
        if (operationsPerSecond !== this.previousCapacity) {
            (0, logger_1.logger)('RateLimiter.calculateCapacity', null, `New request capacity: ${operationsPerSecond} operations per second.`);
        }
        this.previousCapacity = operationsPerSecond;
        return operationsPerSecond;
    }
}
exports.RateLimiter = RateLimiter; //# sourceMappingURL=rate-limiter.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/map-type.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VECTOR_MAP_VECTORS_KEY = exports.RESERVED_MAP_KEY_VECTOR_VALUE = exports.RESERVED_MAP_KEY = void 0;
exports.RESERVED_MAP_KEY = '__type__';
exports.RESERVED_MAP_KEY_VECTOR_VALUE = '__vector__';
exports.VECTOR_MAP_VECTORS_KEY = 'value'; //# sourceMappingURL=map-type.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/convert.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.timestampFromJson = timestampFromJson;
exports.detectValueType = detectValueType;
exports.detectGoogleProtobufValueType = detectGoogleProtobufValueType;
exports.valueFromJson = valueFromJson;
exports.fieldsFromJson = fieldsFromJson;
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const map_type_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/map-type.js [app-client] (ecmascript)");
/*!
 * @module firestore/convert
 * @private
 * @internal
 *
 * This module contains utility functions to convert
 * `firestore.v1.Documents` from Proto3 JSON to their equivalent
 * representation in Protobuf JS. Protobuf JS is the only encoding supported by
 * this client, and dependencies that use Proto3 JSON (such as the Google Cloud
 * Functions SDK) are supported through this conversion and its usage in
 * {@see Firestore#snapshot_}.
 */ /**
 * Converts an ISO 8601 or google.protobuf.Timestamp proto into Protobuf JS.
 *
 * @private
 * @internal
 * @param timestampValue The value to convert.
 * @param argumentName The argument name to use in the error message if the
 * conversion fails. If omitted, 'timestampValue' is used.
 * @return The value as expected by Protobuf JS or undefined if no input was
 * provided.
 */ function timestampFromJson(timestampValue, argumentName) {
    let timestampProto = {};
    if (typeof timestampValue === 'string') {
        const date = new Date(timestampValue);
        const seconds = Math.floor(date.getTime() / 1000);
        let nanos = 0;
        if (timestampValue.length > 20) {
            const nanoString = timestampValue.substring(20, timestampValue.length - 1);
            const trailingZeroes = 9 - nanoString.length;
            nanos = Number(nanoString) * Math.pow(10, trailingZeroes);
        }
        if (isNaN(seconds) || isNaN(nanos)) {
            argumentName = argumentName || 'timestampValue';
            throw new Error(`Specify a valid ISO 8601 timestamp for "${argumentName}".`);
        }
        timestampProto = {
            seconds: seconds || undefined,
            nanos: nanos || undefined
        };
    } else if (timestampValue !== undefined) {
        (0, validate_1.validateObject)('timestampValue', timestampValue);
        timestampProto = {
            seconds: timestampValue.seconds || undefined,
            nanos: timestampValue.nanos || undefined
        };
    }
    return timestampProto;
}
/**
 * Converts a Proto3 JSON 'bytesValue' field into Protobuf JS.
 *
 * @private
 * @internal
 * @param bytesValue The value to convert.
 * @return The value as expected by Protobuf JS.
 */ function bytesFromJson(bytesValue) {
    if (typeof bytesValue === 'string') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(bytesValue, 'base64');
    } else {
        return bytesValue;
    }
}
/**
 * Detects 'valueType' from a Proto3 JSON `firestore.v1.Value` proto.
 *
 * @private
 * @internal
 * @param proto The `firestore.v1.Value` proto.
 * @return The string value for 'valueType'.
 */ function detectValueType(proto) {
    var _a;
    let valueType;
    if (proto.valueType) {
        valueType = proto.valueType;
    } else {
        const detectedValues = [];
        if (proto.stringValue !== undefined) {
            detectedValues.push('stringValue');
        }
        if (proto.booleanValue !== undefined) {
            detectedValues.push('booleanValue');
        }
        if (proto.integerValue !== undefined) {
            detectedValues.push('integerValue');
        }
        if (proto.doubleValue !== undefined) {
            detectedValues.push('doubleValue');
        }
        if (proto.timestampValue !== undefined) {
            detectedValues.push('timestampValue');
        }
        if (proto.referenceValue !== undefined) {
            detectedValues.push('referenceValue');
        }
        if (proto.arrayValue !== undefined) {
            detectedValues.push('arrayValue');
        }
        if (proto.nullValue !== undefined) {
            detectedValues.push('nullValue');
        }
        if (proto.mapValue !== undefined) {
            detectedValues.push('mapValue');
        }
        if (proto.geoPointValue !== undefined) {
            detectedValues.push('geoPointValue');
        }
        if (proto.bytesValue !== undefined) {
            detectedValues.push('bytesValue');
        }
        if (detectedValues.length !== 1) {
            throw new Error(`Unable to infer type value from '${JSON.stringify(proto)}'.`);
        }
        valueType = detectedValues[0];
    }
    // Special handling of mapValues used to represent other data types
    if (valueType === 'mapValue') {
        const fields = (_a = proto.mapValue) === null || _a === void 0 ? void 0 : _a.fields;
        if (fields) {
            const props = Object.keys(fields);
            if (props.indexOf(map_type_1.RESERVED_MAP_KEY) !== -1 && detectValueType(fields[map_type_1.RESERVED_MAP_KEY]) === 'stringValue' && fields[map_type_1.RESERVED_MAP_KEY].stringValue === map_type_1.RESERVED_MAP_KEY_VECTOR_VALUE) {
                valueType = 'vectorValue';
            }
        }
    }
    return valueType;
}
/**
 * Detects the value kind from a Proto3 JSON `google.protobuf.Value` proto.
 *
 * @private
 * @internal
 * @param proto The `firestore.v1.Value` proto.
 * @return The string value for 'valueType'.
 */ function detectGoogleProtobufValueType(proto) {
    const detectedValues = [];
    if (proto.nullValue !== undefined) {
        detectedValues.push('nullValue');
    }
    if (proto.numberValue !== undefined) {
        detectedValues.push('numberValue');
    }
    if (proto.stringValue !== undefined) {
        detectedValues.push('stringValue');
    }
    if (proto.boolValue !== undefined) {
        detectedValues.push('boolValue');
    }
    if (proto.structValue !== undefined) {
        detectedValues.push('structValue');
    }
    if (proto.listValue !== undefined) {
        detectedValues.push('listValue');
    }
    if (detectedValues.length !== 1) {
        throw new Error(`Unable to infer type value from '${JSON.stringify(proto)}'.`);
    }
    return detectedValues[0];
}
/**
 * Converts a `firestore.v1.Value` in Proto3 JSON encoding into the
 * Protobuf JS format expected by this client.
 *
 * @private
 * @internal
 * @param fieldValue The `firestore.v1.Value` in Proto3 JSON format.
 * @return The `firestore.v1.Value` in Protobuf JS format.
 */ function valueFromJson(fieldValue) {
    const valueType = detectValueType(fieldValue);
    switch(valueType){
        case 'timestampValue':
            return {
                timestampValue: timestampFromJson(fieldValue.timestampValue)
            };
        case 'bytesValue':
            return {
                bytesValue: bytesFromJson(fieldValue.bytesValue)
            };
        case 'doubleValue':
            return {
                doubleValue: Number(fieldValue.doubleValue)
            };
        case 'arrayValue':
            {
                const arrayValue = [];
                if (Array.isArray(fieldValue.arrayValue.values)) {
                    for (const value of fieldValue.arrayValue.values){
                        arrayValue.push(valueFromJson(value));
                    }
                }
                return {
                    arrayValue: {
                        values: arrayValue
                    }
                };
            }
        case 'mapValue':
        case 'vectorValue':
            {
                const mapValue = {};
                const fields = fieldValue.mapValue.fields;
                if (fields) {
                    for (const prop of Object.keys(fields)){
                        mapValue[prop] = valueFromJson(fieldValue.mapValue.fields[prop]);
                    }
                }
                return {
                    mapValue: {
                        fields: mapValue
                    }
                };
            }
        default:
            return fieldValue;
    }
}
/**
 * Converts a map of IValues in Proto3 JSON encoding into the Protobuf JS format
 * expected by this client. This conversion creates a copy of the underlying
 * fields.
 *
 * @private
 * @internal
 * @param document An object with IValues in Proto3 JSON format.
 * @return The object in Protobuf JS format.
 */ function fieldsFromJson(document) {
    const result = {};
    for (const prop of Object.keys(document)){
        result[prop] = valueFromJson(document[prop]);
    }
    return result;
} //# sourceMappingURL=convert.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/geo-point.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeoPoint = void 0;
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
/**
 * An immutable object representing a geographic location in Firestore. The
 * location is represented as a latitude/longitude pair.
 *
 * @class
 */ class GeoPoint {
    /**
     * Creates a [GeoPoint]{@link GeoPoint}.
     *
     * @param {number} latitude The latitude as a number between -90 and 90.
     * @param {number} longitude The longitude as a number between -180 and 180.
     *
     * @example
     * ```
     * let data = {
     *   google: new Firestore.GeoPoint(37.422, 122.084)
     * };
     *
     * firestore.doc('col/doc').set(data).then(() => {
     *   console.log(`Location is ${data.google.latitude}, ` +
     *     `${data.google.longitude}`);
     * });
     * ```
     */ constructor(latitude, longitude){
        (0, validate_1.validateNumber)('latitude', latitude, {
            minValue: -90,
            maxValue: 90
        });
        (0, validate_1.validateNumber)('longitude', longitude, {
            minValue: -180,
            maxValue: 180
        });
        this._latitude = latitude;
        this._longitude = longitude;
    }
    /**
     * The latitude as a number between -90 and 90.
     *
     * @type {number}
     * @name GeoPoint#latitude
     * @readonly
     */ get latitude() {
        return this._latitude;
    }
    /**
     * The longitude as a number between -180 and 180.
     *
     * @type {number}
     * @name GeoPoint#longitude
     * @readonly
     */ get longitude() {
        return this._longitude;
    }
    /**
     * Returns true if this `GeoPoint` is equal to the provided value.
     *
     * @param {*} other The value to compare against.
     * @return {boolean} true if this `GeoPoint` is equal to the provided value.
     */ isEqual(other) {
        return this === other || other instanceof GeoPoint && this.latitude === other.latitude && this.longitude === other.longitude;
    }
    /**
     * Converts the GeoPoint to a google.type.LatLng proto.
     * @private
     * @internal
     */ toProto() {
        return {
            geoPointValue: {
                latitude: this.latitude,
                longitude: this.longitude
            }
        };
    }
    /**
     * Converts a google.type.LatLng proto to its GeoPoint representation.
     * @private
     * @internal
     */ static fromProto(proto) {
        return new GeoPoint(proto.latitude || 0, proto.longitude || 0);
    }
}
exports.GeoPoint = GeoPoint; //# sourceMappingURL=geo-point.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/order.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.primitiveComparator = primitiveComparator;
exports.compareArrays = compareArrays;
exports.compareUtf8Strings = compareUtf8Strings;
exports.compare = compare;
const convert_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/convert.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
/*!
 * The type order as defined by the backend.
 */ var TypeOrder;
(function(TypeOrder) {
    TypeOrder[TypeOrder["NULL"] = 0] = "NULL";
    TypeOrder[TypeOrder["BOOLEAN"] = 1] = "BOOLEAN";
    TypeOrder[TypeOrder["NUMBER"] = 2] = "NUMBER";
    TypeOrder[TypeOrder["TIMESTAMP"] = 3] = "TIMESTAMP";
    TypeOrder[TypeOrder["STRING"] = 4] = "STRING";
    TypeOrder[TypeOrder["BLOB"] = 5] = "BLOB";
    TypeOrder[TypeOrder["REF"] = 6] = "REF";
    TypeOrder[TypeOrder["GEO_POINT"] = 7] = "GEO_POINT";
    TypeOrder[TypeOrder["ARRAY"] = 8] = "ARRAY";
    TypeOrder[TypeOrder["VECTOR"] = 9] = "VECTOR";
    TypeOrder[TypeOrder["OBJECT"] = 10] = "OBJECT";
})(TypeOrder || (TypeOrder = {}));
/*!
 * @private
 * @internal
 */ function typeOrder(val) {
    const valueType = (0, convert_1.detectValueType)(val);
    switch(valueType){
        case 'nullValue':
            return TypeOrder.NULL;
        case 'integerValue':
            return TypeOrder.NUMBER;
        case 'doubleValue':
            return TypeOrder.NUMBER;
        case 'stringValue':
            return TypeOrder.STRING;
        case 'booleanValue':
            return TypeOrder.BOOLEAN;
        case 'arrayValue':
            return TypeOrder.ARRAY;
        case 'timestampValue':
            return TypeOrder.TIMESTAMP;
        case 'geoPointValue':
            return TypeOrder.GEO_POINT;
        case 'bytesValue':
            return TypeOrder.BLOB;
        case 'referenceValue':
            return TypeOrder.REF;
        case 'mapValue':
            return TypeOrder.OBJECT;
        case 'vectorValue':
            return TypeOrder.VECTOR;
        default:
            throw new Error('Unexpected value type: ' + valueType);
    }
}
/*!
 * @private
 * @internal
 */ function primitiveComparator(left, right) {
    if (left < right) {
        return -1;
    }
    if (left > right) {
        return 1;
    }
    return 0;
}
/*!
 * Utility function to compare doubles (using Firestore semantics for NaN).
 * @private
 * @internal
 */ function compareNumbers(left, right) {
    if (left < right) {
        return -1;
    }
    if (left > right) {
        return 1;
    }
    if (left === right) {
        return 0;
    }
    // one or both are NaN.
    if (isNaN(left)) {
        return isNaN(right) ? 0 : -1;
    }
    return 1;
}
/*!
 * @private
 * @internal
 */ function compareNumberProtos(left, right) {
    let leftValue, rightValue;
    if (left.integerValue !== undefined) {
        leftValue = Number(left.integerValue);
    } else {
        leftValue = Number(left.doubleValue);
    }
    if (right.integerValue !== undefined) {
        rightValue = Number(right.integerValue);
    } else {
        rightValue = Number(right.doubleValue);
    }
    return compareNumbers(leftValue, rightValue);
}
/*!
 * @private
 * @internal
 */ function compareTimestamps(left, right) {
    const seconds = primitiveComparator(left.seconds || 0, right.seconds || 0);
    if (seconds !== 0) {
        return seconds;
    }
    return primitiveComparator(left.nanos || 0, right.nanos || 0);
}
/*!
 * @private
 * @internal
 */ function compareBlobs(left, right) {
    if (!(left instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"]) || !(right instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"])) {
        throw new Error('Blobs can only be compared if they are Buffers.');
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare(left, right);
}
/*!
 * @private
 * @internal
 */ function compareReferenceProtos(left, right) {
    const leftPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(left.referenceValue);
    const rightPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(right.referenceValue);
    return leftPath.compareTo(rightPath);
}
/*!
 * @private
 * @internal
 */ function compareGeoPoints(left, right) {
    return primitiveComparator(left.latitude || 0, right.latitude || 0) || primitiveComparator(left.longitude || 0, right.longitude || 0);
}
/*!
 * @private
 * @internal
 */ function compareArrays(left, right) {
    for(let i = 0; i < left.length && i < right.length; i++){
        const valueComparison = compare(left[i], right[i]);
        if (valueComparison !== 0) {
            return valueComparison;
        }
    }
    // If all the values matched so far, just check the length.
    return primitiveComparator(left.length, right.length);
}
/*!
 * @private
 * @internal
 */ function compareObjects(left, right) {
    // This requires iterating over the keys in the object in order and doing a
    // deep comparison.
    const leftKeys = Object.keys(left);
    const rightKeys = Object.keys(right);
    leftKeys.sort();
    rightKeys.sort();
    for(let i = 0; i < leftKeys.length && i < rightKeys.length; i++){
        const keyComparison = compareUtf8Strings(leftKeys[i], rightKeys[i]);
        if (keyComparison !== 0) {
            return keyComparison;
        }
        const key = leftKeys[i];
        const valueComparison = compare(left[key], right[key]);
        if (valueComparison !== 0) {
            return valueComparison;
        }
    }
    // If all the keys matched so far, just check the length.
    return primitiveComparator(leftKeys.length, rightKeys.length);
}
/*!
 * @private
 * @internal
 */ function compareVectors(left, right) {
    var _a, _b, _c, _d, _e, _f;
    // The vector is a map, but only vector value is compared.
    const leftArray = (_c = (_b = (_a = left === null || left === void 0 ? void 0 : left['value']) === null || _a === void 0 ? void 0 : _a.arrayValue) === null || _b === void 0 ? void 0 : _b.values) !== null && _c !== void 0 ? _c : [];
    const rightArray = (_f = (_e = (_d = right === null || right === void 0 ? void 0 : right['value']) === null || _d === void 0 ? void 0 : _d.arrayValue) === null || _e === void 0 ? void 0 : _e.values) !== null && _f !== void 0 ? _f : [];
    const lengthCompare = primitiveComparator(leftArray.length, rightArray.length);
    if (lengthCompare !== 0) {
        return lengthCompare;
    }
    return compareArrays(leftArray, rightArray);
}
/*!
 * Compare strings in UTF-8 encoded byte order
 * @private
 * @internal
 */ function compareUtf8Strings(left, right) {
    // Find the first differing character (a.k.a. "UTF-16 code unit") in the two strings and,
    // if found, use that character to determine the relative ordering of the two strings as a
    // whole. Comparing UTF-16 strings in UTF-8 byte order can be done simply and efficiently by
    // comparing the UTF-16 code units (chars). This serendipitously works because of the way UTF-8
    // and UTF-16 happen to represent Unicode code points.
    //
    // After finding the first pair of differing characters, there are two cases:
    //
    // Case 1: Both characters are non-surrogates (code points less than or equal to 0xFFFF) or
    // both are surrogates from a surrogate pair (that collectively represent code points greater
    // than 0xFFFF). In this case their numeric order as UTF-16 code units is the same as the
    // lexicographical order of their corresponding UTF-8 byte sequences. A direct comparison is
    // sufficient.
    //
    // Case 2: One character is a surrogate and the other is not. In this case the surrogate-
    // containing string is always ordered after the non-surrogate. This is because surrogates are
    // used to represent code points greater than 0xFFFF which have 4-byte UTF-8 representations
    // and are lexicographically greater than the 1, 2, or 3-byte representations of code points
    // less than or equal to 0xFFFF.
    //
    // An example of why Case 2 is required is comparing the following two Unicode code points:
    //
    // |-----------------------|------------|---------------------|-----------------|
    // | Name                  | Code Point | UTF-8 Encoding      | UTF-16 Encoding |
    // |-----------------------|------------|---------------------|-----------------|
    // | Replacement Character | U+FFFD     | 0xEF 0xBF 0xBD      | 0xFFFD          |
    // | Grinning Face         | U+1F600    | 0xF0 0x9F 0x98 0x80 | 0xD83D 0xDE00   |
    // |-----------------------|------------|---------------------|-----------------|
    //
    // A lexicographical comparison of the UTF-8 encodings of these code points would order
    // "Replacement Character" _before_ "Grinning Face" because 0xEF is less than 0xF0. However, a
    // direct comparison of the UTF-16 code units, as would be done in case 1, would erroneously
    // produce the _opposite_ ordering, because 0xFFFD is _greater than_ 0xD83D. As it turns out,
    // this relative ordering holds for all comparisons of UTF-16 code points requiring a surrogate
    // pair with those that do not.
    const length = Math.min(left.length, right.length);
    for(let i = 0; i < length; i++){
        const leftChar = left.charAt(i);
        const rightChar = right.charAt(i);
        if (leftChar !== rightChar) {
            return isSurrogate(leftChar) === isSurrogate(rightChar) ? primitiveComparator(leftChar, rightChar) : isSurrogate(leftChar) ? 1 : -1;
        }
    }
    // Use the lengths of the strings to determine the overall comparison result since either the
    // strings were equal or one is a prefix of the other.
    return primitiveComparator(left.length, right.length);
}
const MIN_SURROGATE = 0xd800;
const MAX_SURROGATE = 0xdfff;
function isSurrogate(s) {
    const c = s.charCodeAt(0);
    return c >= MIN_SURROGATE && c <= MAX_SURROGATE;
}
/*!
 * @private
 * @internal
 */ function compare(left, right) {
    // First compare the types.
    const leftType = typeOrder(left);
    const rightType = typeOrder(right);
    const typeComparison = primitiveComparator(leftType, rightType);
    if (typeComparison !== 0) {
        return typeComparison;
    }
    // So they are the same type.
    switch(leftType){
        case TypeOrder.NULL:
            // Nulls are all equal.
            return 0;
        case TypeOrder.BOOLEAN:
            return primitiveComparator(left.booleanValue, right.booleanValue);
        case TypeOrder.STRING:
            return compareUtf8Strings(left.stringValue, right.stringValue);
        case TypeOrder.NUMBER:
            return compareNumberProtos(left, right);
        case TypeOrder.TIMESTAMP:
            return compareTimestamps(left.timestampValue, right.timestampValue);
        case TypeOrder.BLOB:
            return compareBlobs(left.bytesValue, right.bytesValue);
        case TypeOrder.REF:
            return compareReferenceProtos(left, right);
        case TypeOrder.GEO_POINT:
            return compareGeoPoints(left.geoPointValue, right.geoPointValue);
        case TypeOrder.ARRAY:
            return compareArrays(left.arrayValue.values || [], right.arrayValue.values || []);
        case TypeOrder.OBJECT:
            return compareObjects(left.mapValue.fields || {}, right.mapValue.fields || {});
        case TypeOrder.VECTOR:
            return compareVectors(left.mapValue.fields || {}, right.mapValue.fields || {});
        default:
            throw new Error(`Encountered unknown type order: ${leftType}`);
    }
} //# sourceMappingURL=order.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FieldPath = exports.QualifiedResourcePath = exports.ResourcePath = exports.DEFAULT_DATABASE_ID = void 0;
exports.validateResourcePath = validateResourcePath;
exports.validateFieldPath = validateFieldPath;
const order_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/order.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
/*!
 * The default database ID for this Firestore client. We do not yet expose the
 * ability to use different databases.
 */ exports.DEFAULT_DATABASE_ID = '(default)';
/*!
 * A regular expression to verify an absolute Resource Path in Firestore. It
 * extracts the project ID, the database name and the relative resource path
 * if available.
 *
 * @type {RegExp}
 */ const RESOURCE_PATH_RE = // Note: [\s\S] matches all characters including newlines.
/^projects\/([^/]*)\/databases\/([^/]*)(?:\/documents\/)?([\s\S]*)$/;
/*!
 * A regular expression to verify whether a field name can be passed to the
 * backend without escaping.
 *
 * @type {RegExp}
 */ const UNESCAPED_FIELD_NAME_RE = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
/*!
 * A regular expression to verify field paths that are passed to the API as
 * strings. Field paths that do not match this expression have to be provided
 * as a [FieldPath]{@link FieldPath} object.
 *
 * @type {RegExp}
 */ const FIELD_PATH_RE = /^[^*~/[\]]+$/;
/**
 * An abstract class representing a Firestore path.
 *
 * Subclasses have to implement `split()` and `canonicalString()`.
 *
 * @private
 * @internal
 * @class
 */ class Path {
    /**
     * Creates a new Path with the given segments.
     *
     * @private
     * @internal
     * @private
     * @param segments Sequence of parts of a path.
     */ constructor(segments){
        this.segments = segments;
    }
    /**
     * Returns the number of segments of this field path.
     *
     * @private
     * @internal
     */ get size() {
        return this.segments.length;
    }
    /**
     * Create a child path beneath the current level.
     *
     * @private
     * @internal
     * @param relativePath Relative path to append to the current path.
     * @returns The new path.
     */ append(relativePath) {
        if (relativePath instanceof Path) {
            return this.construct(this.segments.concat(relativePath.segments));
        }
        return this.construct(this.segments.concat(this.split(relativePath)));
    }
    /**
     * Returns the path of the parent node.
     *
     * @private
     * @internal
     * @returns The new path or null if we are already at the root.
     */ parent() {
        if (this.segments.length === 0) {
            return null;
        }
        return this.construct(this.segments.slice(0, this.segments.length - 1));
    }
    /**
     * Checks whether the current path is a prefix of the specified path.
     *
     * @private
     * @internal
     * @param other The path to check against.
     * @returns 'true' iff the current path is a prefix match with 'other'.
     */ isPrefixOf(other) {
        if (other.segments.length < this.segments.length) {
            return false;
        }
        for(let i = 0; i < this.segments.length; i++){
            if (this.segments[i] !== other.segments[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Compare the current path against another Path object.
     *
     * Compare the current path against another Path object. Paths are compared segment by segment,
     * prioritizing numeric IDs (e.g., "__id123__") in numeric ascending order, followed by string
     * segments in lexicographical order.
     *
     * @private
     * @internal
     * @param other The path to compare to.
     * @returns -1 if current < other, 1 if current > other, 0 if equal
     */ compareTo(other) {
        const len = Math.min(this.segments.length, other.segments.length);
        for(let i = 0; i < len; i++){
            const comparison = this.compareSegments(this.segments[i], other.segments[i]);
            if (comparison !== 0) {
                return comparison;
            }
        }
        return (0, order_1.primitiveComparator)(this.segments.length, other.segments.length);
    }
    compareSegments(lhs, rhs) {
        const isLhsNumeric = this.isNumericId(lhs);
        const isRhsNumeric = this.isNumericId(rhs);
        if (isLhsNumeric && !isRhsNumeric) {
            // Only lhs is numeric
            return -1;
        } else if (!isLhsNumeric && isRhsNumeric) {
            // Only rhs is numeric
            return 1;
        } else if (isLhsNumeric && isRhsNumeric) {
            // both numeric
            return this.compareNumbers(this.extractNumericId(lhs), this.extractNumericId(rhs));
        } else {
            // both non-numeric
            return (0, order_1.compareUtf8Strings)(lhs, rhs);
        }
    }
    // Checks if a segment is a numeric ID (starts with "__id" and ends with "__").
    isNumericId(segment) {
        return segment.startsWith('__id') && segment.endsWith('__');
    }
    //  Extracts the long number from a numeric ID segment.
    extractNumericId(segment) {
        return BigInt(segment.substring(4, segment.length - 2));
    }
    compareNumbers(lhs, rhs) {
        if (lhs < rhs) {
            return -1;
        } else if (lhs > rhs) {
            return 1;
        } else {
            return 0;
        }
    }
    /**
     * Returns a copy of the underlying segments.
     *
     * @private
     * @internal
     * @returns A copy of the segments that make up this path.
     */ toArray() {
        return this.segments.slice();
    }
    /**
     * Pops the last segment from this `Path` and returns a newly constructed
     * `Path`.
     *
     * @private
     * @internal
     * @returns The newly created Path.
     */ popLast() {
        this.segments.pop();
        return this.construct(this.segments);
    }
    /**
     * Returns true if this `Path` is equal to the provided value.
     *
     * @private
     * @internal
     * @param other The value to compare against.
     * @return true if this `Path` is equal to the provided value.
     */ isEqual(other) {
        return this === other || this.compareTo(other) === 0;
    }
}
/**
 * A slash-separated path for navigating resources within the current Firestore
 * instance.
 *
 * @private
 * @internal
 */ class ResourcePath extends Path {
    /**
     * Constructs a ResourcePath.
     *
     * @private
     * @internal
     * @param segments Sequence of names of the parts of the path.
     */ constructor(...segments){
        super(segments);
    }
    /**
     * Indicates whether this path points to a document.
     * @private
     * @internal
     */ get isDocument() {
        return this.segments.length > 0 && this.segments.length % 2 === 0;
    }
    /**
     * Indicates whether this path points to a collection.
     * @private
     * @internal
     */ get isCollection() {
        return this.segments.length % 2 === 1;
    }
    /**
     * The last component of the path.
     * @private
     * @internal
     */ get id() {
        if (this.segments.length > 0) {
            return this.segments[this.segments.length - 1];
        }
        return null;
    }
    /**
     * Returns the location of this path relative to the root of the project's
     * database.
     * @private
     * @internal
     */ get relativeName() {
        return this.segments.join('/');
    }
    /**
     * Constructs a new instance of ResourcePath.
     *
     * @private
     * @internal
     * @param segments Sequence of parts of the path.
     * @returns The newly created ResourcePath.
     */ construct(segments) {
        return new ResourcePath(...segments);
    }
    /**
     * Splits a string into path segments, using slashes as separators.
     *
     * @private
     * @internal
     * @param relativePath The path to split.
     * @returns The split path segments.
     */ split(relativePath) {
        // We may have an empty segment at the beginning or end if they had a
        // leading or trailing slash (which we allow).
        return relativePath.split('/').filter((segment)=>segment.length > 0);
    }
    /**
     * Converts this path to a fully qualified ResourcePath.
     *
     * @private
     * @internal
     * @param projectId The project ID of the current Firestore project.
     * @return A fully-qualified resource path pointing to the same element.
     */ toQualifiedResourcePath(projectId, databaseId) {
        return new QualifiedResourcePath(projectId, databaseId, ...this.segments);
    }
}
exports.ResourcePath = ResourcePath;
/**
 * A default instance pointing to the root collection.
 * @private
 * @internal
 */ ResourcePath.EMPTY = new ResourcePath();
/**
 * A slash-separated path that includes a project and database ID for referring
 * to resources in any Firestore project.
 *
 * @private
 * @internal
 */ class QualifiedResourcePath extends ResourcePath {
    /**
     * Constructs a Firestore Resource Path.
     *
     * @private
     * @internal
     * @param projectId The Firestore project id.
     * @param databaseId The Firestore database id.
     * @param segments Sequence of names of the parts of the path.
     */ constructor(projectId, databaseId, ...segments){
        super(...segments);
        this.projectId = projectId;
        this.databaseId = databaseId;
    }
    /**
     * String representation of the path relative to the database root.
     * @private
     * @internal
     */ get relativeName() {
        return this.segments.join('/');
    }
    /**
     * Creates a resource path from an absolute Firestore path.
     *
     * @private
     * @internal
     * @param absolutePath A string representation of a Resource Path.
     * @returns The new ResourcePath.
     */ static fromSlashSeparatedString(absolutePath) {
        const elements = RESOURCE_PATH_RE.exec(absolutePath);
        if (elements) {
            const project = elements[1];
            const database = elements[2];
            const path = elements[3];
            return new QualifiedResourcePath(project, database).append(path);
        }
        throw new Error(`Resource name '${absolutePath}' is not valid.`);
    }
    /**
     * Create a child path beneath the current level.
     *
     * @private
     * @internal
     * @param relativePath Relative path to append to the current path.
     * @returns The new path.
     */ append(relativePath) {
        // `super.append()` calls `QualifiedResourcePath.construct()` when invoked
        // from here and returns a QualifiedResourcePath.
        return super.append(relativePath);
    }
    /**
     * Create a child path beneath the current level.
     *
     * @private
     * @internal
     * @returns The new path.
     */ parent() {
        return super.parent();
    }
    /**
     * String representation of a ResourcePath as expected by the API.
     *
     * @private
     * @internal
     * @returns The representation as expected by the API.
     */ get formattedName() {
        const components = [
            'projects',
            this.projectId,
            'databases',
            this.databaseId,
            'documents',
            ...this.segments
        ];
        return components.join('/');
    }
    /**
     * Constructs a new instance of ResourcePath. We need this instead of using
     * the normal constructor because polymorphic 'this' doesn't work on static
     * methods.
     *
     * @private
     * @internal
     * @param segments Sequence of names of the parts of the path.
     * @returns The newly created QualifiedResourcePath.
     */ construct(segments) {
        return new QualifiedResourcePath(this.projectId, this.databaseId, ...segments);
    }
    /**
     * Convenience method to match the ResourcePath API. This method always
     * returns the current instance.
     *
     * @private
     * @internal
     */ toQualifiedResourcePath() {
        return this;
    }
    /**
     * Compare the current path against another ResourcePath object.
     *
     * @private
     * @internal
     * @param other The path to compare to.
     * @returns -1 if current < other, 1 if current > other, 0 if equal
     */ compareTo(other) {
        if (other instanceof QualifiedResourcePath) {
            if (this.projectId < other.projectId) {
                return -1;
            }
            if (this.projectId > other.projectId) {
                return 1;
            }
            if (this.databaseId < other.databaseId) {
                return -1;
            }
            if (this.databaseId > other.databaseId) {
                return 1;
            }
        }
        return super.compareTo(other);
    }
    /**
     * Converts this ResourcePath to the Firestore Proto representation.
     * @private
     * @internal
     */ toProto() {
        return {
            referenceValue: this.formattedName
        };
    }
}
exports.QualifiedResourcePath = QualifiedResourcePath;
/**
 * Validates that the given string can be used as a relative or absolute
 * resource path.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param resourcePath The path to validate.
 * @throws if the string can't be used as a resource path.
 */ function validateResourcePath(arg, resourcePath) {
    if (typeof resourcePath !== 'string' || resourcePath === '') {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'resource path')} Path must be a non-empty string.`);
    }
    if (resourcePath.indexOf('//') >= 0) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'resource path')} Paths must not contain //.`);
    }
}
/**
 * A dot-separated path for navigating sub-objects (e.g. nested maps) within a document.
 *
 * @class
 */ class FieldPath extends Path {
    /**
     * Constructs a Firestore Field Path.
     *
     * @param {...string} segments Sequence of field names that form this path.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     * let fieldPath = new FieldPath('f.o.o', 'bar');
     *
     * query.where(fieldPath, '==', 42).get().then(snapshot => {
     *   snapshot.forEach(document => {
     *     console.log(`Document contains {'f.o.o' : {'bar' : 42}}`);
     *   });
     * });
     * ```
     */ constructor(...segments){
        if (Array.isArray(segments[0])) {
            throw new Error('The FieldPath constructor no longer supports an array as its first argument. ' + 'Please unpack your array and call FieldPath() with individual arguments.');
        }
        (0, validate_1.validateMinNumberOfArguments)('FieldPath', segments, 1);
        for(let i = 0; i < segments.length; ++i){
            (0, validate_1.validateString)(i, segments[i]);
            if (segments[i].length === 0) {
                throw new Error(`Element at index ${i} should not be an empty string.`);
            }
        }
        super(segments);
    }
    /**
     * A special FieldPath value to refer to the ID of a document. It can be used
     * in queries to sort or filter by the document ID.
     *
     * @returns {FieldPath}
     */ static documentId() {
        return FieldPath._DOCUMENT_ID;
    }
    /**
     * Turns a field path argument into a [FieldPath]{@link FieldPath}.
     * Supports FieldPaths as input (which are passed through) and dot-separated
     * strings.
     *
     * @private
     * @internal
     * @param {string|FieldPath} fieldPath The FieldPath to create.
     * @returns {FieldPath} A field path representation.
     */ static fromArgument(fieldPath) {
        // validateFieldPath() is used in all public API entry points to validate
        // that fromArgument() is only called with a Field Path or a string.
        return fieldPath instanceof FieldPath ? fieldPath : new FieldPath(...fieldPath.split('.'));
    }
    /**
     * String representation of a FieldPath as expected by the API.
     *
     * @private
     * @internal
     * @override
     * @returns {string} The representation as expected by the API.
     */ get formattedName() {
        return this.segments.map((str)=>{
            return UNESCAPED_FIELD_NAME_RE.test(str) ? str : '`' + str.replace(/\\/g, '\\\\').replace(/`/g, '\\`') + '`';
        }).join('.');
    }
    /**
     * Returns a string representation of this path.
     *
     * @private
     * @internal
     * @returns A string representing this path.
     */ toString() {
        return this.formattedName;
    }
    /**
     * Splits a string into path segments, using dots as separators.
     *
     * @private
     * @internal
     * @override
     * @param {string} fieldPath The path to split.
     * @returns {Array.<string>} - The split path segments.
     */ split(fieldPath) {
        return fieldPath.split('.');
    }
    /**
     * Constructs a new instance of FieldPath. We need this instead of using
     * the normal constructor because polymorphic 'this' doesn't work on static
     * methods.
     *
     * @private
     * @internal
     * @override
     * @param segments Sequence of field names.
     * @returns The newly created FieldPath.
     */ construct(segments) {
        return new FieldPath(...segments);
    }
    /**
     * Returns true if this `FieldPath` is equal to the provided value.
     *
     * @param {*} other The value to compare against.
     * @return {boolean} true if this `FieldPath` is equal to the provided value.
     */ isEqual(other) {
        return super.isEqual(other);
    }
}
exports.FieldPath = FieldPath;
/**
 * A special sentinel value to refer to the ID of a document.
 *
 * @private
 * @internal
 */ FieldPath._DOCUMENT_ID = new FieldPath('__name__');
/**
 * Validates that the provided value can be used as a field path argument.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param fieldPath The value to verify.
 * @throws if the string can't be used as a field path.
 */ function validateFieldPath(arg, fieldPath) {
    if (fieldPath instanceof FieldPath) {
        return;
    }
    if (fieldPath === undefined) {
        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'field path') + ' The path cannot be omitted.');
    }
    if ((0, util_1.isObject)(fieldPath) && fieldPath.constructor.name === 'FieldPath') {
        throw new Error((0, validate_1.customObjectMessage)(arg, fieldPath));
    }
    if (typeof fieldPath !== 'string') {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'field path')} Paths can only be specified as strings or via a FieldPath object.`);
    }
    if (fieldPath.indexOf('..') >= 0) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'field path')} Paths must not contain ".." in them.`);
    }
    if (fieldPath.startsWith('.') || fieldPath.endsWith('.')) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'field path')} Paths must not start or end with ".".`);
    }
    if (!FIELD_PATH_RE.test(fieldPath)) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'field path')} Paths can't be empty and must not contain
    "*~/[]".`);
    }
} //# sourceMappingURL=path.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/serializer.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Serializer = void 0;
exports.validateUserInput = validateUserInput;
const field_value_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/field-value.js [app-client] (ecmascript)");
const convert_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/convert.js [app-client] (ecmascript)");
const geo_point_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/geo-point.js [app-client] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/index.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const timestamp_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const map_type_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/map-type.js [app-client] (ecmascript)");
/**
 * The maximum depth of a Firestore object.
 *
 * @private
 * @internal
 */ const MAX_DEPTH = 20;
/**
 * Serializer that is used to convert between JavaScript types and their
 * Firestore Protobuf representation.
 *
 * @private
 * @internal
 */ class Serializer {
    constructor(firestore){
        // Instead of storing the `firestore` object, we store just a reference to
        // its `.doc()` method. This avoid a circular reference, which breaks
        // JSON.stringify().
        this.createReference = (path)=>firestore.doc(path);
        this.createInteger = (n)=>firestore._settings.useBigInt ? BigInt(n) : Number(n);
        this.allowUndefined = !!firestore._settings.ignoreUndefinedProperties;
    }
    /**
     * Encodes a JavaScript object into the Firestore 'Fields' representation.
     *
     * @private
     * @internal
     * @param obj The object to encode.
     * @returns The Firestore 'Fields' representation
     */ encodeFields(obj) {
        const fields = {};
        for (const prop of Object.keys(obj)){
            const val = this.encodeValue(obj[prop]);
            if (val) {
                fields[prop] = val;
            }
        }
        return fields;
    }
    /**
     * Encodes a JavaScript value into the Firestore 'Value' representation.
     *
     * @private
     * @internal
     * @param val The object to encode
     * @returns The Firestore Proto or null if we are deleting a field.
     */ encodeValue(val) {
        if (val instanceof field_value_1.FieldTransform) {
            return null;
        }
        if (typeof val === 'string') {
            return {
                stringValue: val
            };
        }
        if (typeof val === 'boolean') {
            return {
                booleanValue: val
            };
        }
        if (typeof val === 'number') {
            const isNegativeZero = val === 0 && 1 / val === 1 / -0;
            if (Number.isSafeInteger(val) && !isNegativeZero) {
                return {
                    integerValue: val
                };
            } else {
                return {
                    doubleValue: val
                };
            }
        }
        if (typeof val === 'bigint') {
            return {
                integerValue: val.toString()
            };
        }
        if (val instanceof Date) {
            const timestamp = timestamp_1.Timestamp.fromDate(val);
            return {
                timestampValue: {
                    seconds: timestamp.seconds,
                    nanos: timestamp.nanoseconds
                }
            };
        }
        if (isMomentJsType(val)) {
            const timestamp = timestamp_1.Timestamp.fromDate(val.toDate());
            return {
                timestampValue: {
                    seconds: timestamp.seconds,
                    nanos: timestamp.nanoseconds
                }
            };
        }
        if (val === null) {
            return {
                nullValue: 'NULL_VALUE'
            };
        }
        if (val instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] || val instanceof Uint8Array) {
            return {
                bytesValue: val
            };
        }
        if (val instanceof field_value_1.VectorValue) {
            return val._toProto(this);
        }
        if ((0, util_1.isObject)(val)) {
            const toProto = val['toProto'];
            if (typeof toProto === 'function') {
                return toProto.bind(val)();
            }
        }
        if (Array.isArray(val)) {
            const array = {
                arrayValue: {}
            };
            if (val.length > 0) {
                array.arrayValue.values = [];
                for(let i = 0; i < val.length; ++i){
                    const enc = this.encodeValue(val[i]);
                    if (enc) {
                        array.arrayValue.values.push(enc);
                    }
                }
            }
            return array;
        }
        if (typeof val === 'object' && (0, util_1.isPlainObject)(val)) {
            const map = {
                mapValue: {}
            };
            // If we encounter an empty object, we always need to send it to make sure
            // the server creates a map entry.
            if (!(0, util_1.isEmpty)(val)) {
                map.mapValue.fields = this.encodeFields(val);
                if ((0, util_1.isEmpty)(map.mapValue.fields)) {
                    return null;
                }
            }
            return map;
        }
        if (val === undefined && this.allowUndefined) {
            return null;
        }
        throw new Error(`Cannot encode value: ${val}`);
    }
    /**
     * @private
     */ encodeVector(rawVector) {
        // A Firestore Vector is a map with reserved key/value pairs.
        return {
            mapValue: {
                fields: {
                    [map_type_1.RESERVED_MAP_KEY]: {
                        stringValue: map_type_1.RESERVED_MAP_KEY_VECTOR_VALUE
                    },
                    [map_type_1.VECTOR_MAP_VECTORS_KEY]: {
                        arrayValue: {
                            values: rawVector.map((value)=>{
                                return {
                                    doubleValue: value
                                };
                            })
                        }
                    }
                }
            }
        };
    }
    /**
     * Decodes a single Firestore 'Value' Protobuf.
     *
     * @private
     * @internal
     * @param proto A Firestore 'Value' Protobuf.
     * @returns The converted JS type.
     */ decodeValue(proto) {
        const valueType = (0, convert_1.detectValueType)(proto);
        switch(valueType){
            case 'stringValue':
                {
                    return proto.stringValue;
                }
            case 'booleanValue':
                {
                    return proto.booleanValue;
                }
            case 'integerValue':
                {
                    return this.createInteger(proto.integerValue);
                }
            case 'doubleValue':
                {
                    return proto.doubleValue;
                }
            case 'timestampValue':
                {
                    return timestamp_1.Timestamp.fromProto(proto.timestampValue);
                }
            case 'referenceValue':
                {
                    const resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);
                    return this.createReference(resourcePath.relativeName);
                }
            case 'arrayValue':
                {
                    const array = [];
                    if (Array.isArray(proto.arrayValue.values)) {
                        for (const value of proto.arrayValue.values){
                            array.push(this.decodeValue(value));
                        }
                    }
                    return array;
                }
            case 'nullValue':
                {
                    return null;
                }
            case 'mapValue':
                {
                    const fields = proto.mapValue.fields;
                    if (fields) {
                        const obj = {};
                        for (const prop of Object.keys(fields)){
                            obj[prop] = this.decodeValue(fields[prop]);
                        }
                        return obj;
                    } else {
                        return {};
                    }
                }
            case 'vectorValue':
                {
                    const fields = proto.mapValue.fields;
                    return field_value_1.VectorValue._fromProto(fields[map_type_1.VECTOR_MAP_VECTORS_KEY]);
                }
            case 'geoPointValue':
                {
                    return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);
                }
            case 'bytesValue':
                {
                    return proto.bytesValue;
                }
            default:
                {
                    throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));
                }
        }
    }
    /**
     * Decodes a google.protobuf.Value
     *
     * @private
     * @internal
     * @param proto A Google Protobuf 'Value'.
     * @returns The converted JS type.
     */ decodeGoogleProtobufValue(proto) {
        switch((0, convert_1.detectGoogleProtobufValueType)(proto)){
            case 'nullValue':
                {
                    return null;
                }
            case 'numberValue':
                {
                    return proto.numberValue;
                }
            case 'stringValue':
                {
                    return proto.stringValue;
                }
            case 'boolValue':
                {
                    return proto.boolValue;
                }
            case 'listValue':
                {
                    return this.decodeGoogleProtobufList(proto.listValue);
                }
            case 'structValue':
                {
                    return this.decodeGoogleProtobufStruct(proto.structValue);
                }
            default:
                {
                    throw new Error('Cannot decode type from google.protobuf.Value: ' + JSON.stringify(proto));
                }
        }
    }
    /**
     * Decodes a google.protobuf.ListValue
     *
     * @private
     * @internal
     * @param proto A Google Protobuf 'ListValue'.
     * @returns The converted JS type.
     */ decodeGoogleProtobufList(proto) {
        const result = [];
        if (proto && proto.values && Array.isArray(proto.values)) {
            for (const value of proto.values){
                result.push(this.decodeGoogleProtobufValue(value));
            }
        }
        return result;
    }
    /**
     * Decodes a google.protobuf.Struct
     *
     * @private
     * @internal
     * @param proto A Google Protobuf 'Struct'.
     * @returns The converted JS type.
     */ decodeGoogleProtobufStruct(proto) {
        const result = {};
        if (proto && proto.fields) {
            for (const prop of Object.keys(proto.fields)){
                result[prop] = this.decodeGoogleProtobufValue(proto.fields[prop]);
            }
        }
        return result;
    }
}
exports.Serializer = Serializer;
/**
 * Validates a JavaScript value for usage as a Firestore value.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value JavaScript value to validate.
 * @param desc A description of the expected type.
 * @param path The field path to validate.
 * @param options Validation options
 * @param level The current depth of the traversal. This is used to decide
 * whether undefined values or deletes are allowed.
 * @param inArray Whether we are inside an array.
 * @throws when the object is invalid.
 */ function validateUserInput(arg, value, desc, options, path, level, inArray) {
    if (path && path.size - 1 > MAX_DEPTH) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} Input object is deeper than ${MAX_DEPTH} levels or contains a cycle.`);
    }
    level = level || 0;
    inArray = inArray || false;
    const fieldPathMessage = path ? ` (found in field "${path}")` : '';
    if (Array.isArray(value)) {
        for(let i = 0; i < value.length; ++i){
            validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1, /* inArray= */ true);
        }
    } else if ((0, util_1.isPlainObject)(value)) {
        for (const prop of Object.keys(value)){
            validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);
        }
    } else if (value === undefined) {
        if (options.allowUndefined && level === 0) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} "undefined" values are only ignored inside of objects.`);
        } else if (!options.allowUndefined) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} Cannot use "undefined" as a Firestore value${fieldPathMessage}. ` + 'If you want to ignore undefined values, enable `ignoreUndefinedProperties`.');
        }
    } else if (value instanceof field_value_1.VectorValue) {
    // OK
    } else if (value instanceof field_value_1.DeleteTransform) {
        if (inArray) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);
        } else if (options.allowDeletes === 'none') {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() must appear at the top-level and can only be used in update() ` + `or set() with {merge:true}${fieldPathMessage}.`);
        } else if (options.allowDeletes === 'root') {
            if (level === 0) {
            // Ok (update() with UpdateData).
            } else if (level === 1 && (path === null || path === void 0 ? void 0 : path.size) === 1) {
            // Ok (update with varargs).
            } else {
                throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() must appear at the top-level and can only be used in update() ` + `or set() with {merge:true}${fieldPathMessage}.`);
            }
        }
    } else if (value instanceof field_value_1.FieldTransform) {
        if (inArray) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);
        } else if (!options.allowTransforms) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() can only be used in set(), create() or update()${fieldPathMessage}.`);
        }
    } else if (value instanceof path_1.FieldPath) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} Cannot use object of type "FieldPath" as a Firestore value${fieldPathMessage}.`);
    } else if (value instanceof index_1.DocumentReference) {
    // Ok.
    } else if (value instanceof geo_point_1.GeoPoint) {
    // Ok.
    } else if (value instanceof timestamp_1.Timestamp || value instanceof Date) {
    // Ok.
    } else if (isMomentJsType(value)) {
    // Ok.
    } else if (value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] || value instanceof Uint8Array) {
    // Ok.
    } else if (value === null) {
    // Ok.
    } else if (typeof value === 'object') {
        throw new Error((0, validate_1.customObjectMessage)(arg, value, path));
    }
}
/**
 * Returns true if value is a MomentJs date object.
 * @private
 * @internal
 */ function isMomentJsType(value) {
    return typeof value === 'object' && value !== null && value.constructor && value.constructor.name === 'Moment' && typeof value.toDate === 'function';
} //# sourceMappingURL=serializer.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/field-value.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DeleteTransform = exports.FieldTransform = exports.FieldValue = exports.VectorValue = void 0;
const deepEqual = __turbopack_context__.r("[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)");
const serializer_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/serializer.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
/**
 * Represent a vector type in Firestore documents.
 * Create an instance with {@link FieldValue.vector}.
 *
 * @class VectorValue
 */ class VectorValue {
    /**
     * @private
     * @internal
     */ constructor(values){
        // Making a copy of the parameter.
        this._values = (values || []).map((n)=>n);
    }
    /**
     * Returns a copy of the raw number array form of the vector.
     */ toArray() {
        return this._values.map((n)=>n);
    }
    /**
     * @private
     * @internal
     */ _toProto(serializer) {
        return serializer.encodeVector(this._values);
    }
    /**
     * @private
     * @internal
     */ static _fromProto(valueArray) {
        var _a, _b;
        const values = (_b = (_a = valueArray.arrayValue) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.map((v)=>{
            return v.doubleValue;
        });
        return new VectorValue(values);
    }
    /**
     * Returns `true` if the two VectorValue has the same raw number arrays, returns `false` otherwise.
     */ isEqual(other) {
        return (0, util_1.isPrimitiveArrayEqual)(this._values, other._values);
    }
}
exports.VectorValue = VectorValue;
/**
 * Sentinel values that can be used when writing documents with set(), create()
 * or update().
 *
 * @class FieldValue
 */ class FieldValue {
    /** @private */ constructor(){}
    /**
     * Creates a new `VectorValue` constructed with a copy of the given array of numbers.
     *
     * @param values - Create a `VectorValue` instance with a copy of this array of numbers.
     *
     * @returns A new `VectorValue` constructed with a copy of the given array of numbers.
     */ static vector(values) {
        return new VectorValue(values);
    }
    /**
     * Returns a sentinel for use with update() or set() with {merge:true} to mark
     * a field for deletion.
     *
     * @returns {FieldValue} The sentinel value to use in your objects.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     * let data = { a: 'b', c: 'd' };
     *
     * documentRef.set(data).then(() => {
     *   return documentRef.update({a: Firestore.FieldValue.delete()});
     * }).then(() => {
     *   // Document now only contains { c: 'd' }
     * });
     * ```
     */ static delete() {
        return DeleteTransform.DELETE_SENTINEL;
    }
    /**
     * Returns a sentinel used with set(), create() or update() to include a
     * server-generated timestamp in the written data.
     *
     * @return {FieldValue} The FieldValue sentinel for use in a call to set(),
     * create() or update().
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.set({
     *   time: Firestore.FieldValue.serverTimestamp()
     * }).then(() => {
     *   return documentRef.get();
     * }).then(doc => {
     *   console.log(`Server time set to ${doc.get('time')}`);
     * });
     * ```
     */ static serverTimestamp() {
        return ServerTimestampTransform.SERVER_TIMESTAMP_SENTINEL;
    }
    /**
     * Returns a special value that can be used with set(), create() or update()
     * that tells the server to increment the the field's current value by the
     * given value.
     *
     * If either current field value or the operand uses floating point
     * precision, both values will be interpreted as floating point numbers and
     * all arithmetic will follow IEEE 754 semantics. Otherwise, integer
     * precision is kept and the result is capped between -2^63 and 2^63-1.
     *
     * If the current field value is not of type 'number', or if the field does
     * not yet exist, the transformation will set the field to the given value.
     *
     * @param {number} n The value to increment by.
     * @return {FieldValue} The FieldValue sentinel for use in a call to set(),
     * create() or update().
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.update(
     *   'counter', Firestore.FieldValue.increment(1)
     * ).then(() => {
     *   return documentRef.get();
     * }).then(doc => {
     *   // doc.get('counter') was incremented
     * });
     * ```
     */ static increment(n) {
        // eslint-disable-next-line prefer-rest-params
        (0, validate_1.validateMinNumberOfArguments)('FieldValue.increment', arguments, 1);
        return new NumericIncrementTransform(n);
    }
    /**
     * Returns a special value that can be used with set(), create() or update()
     * that tells the server to union the given elements with any array value that
     * already exists on the server. Each specified element that doesn't already
     * exist in the array will be added to the end. If the field being modified is
     * not already an array it will be overwritten with an array containing
     * exactly the specified elements.
     *
     * @param {...*} elements The elements to union into the array.
     * @return {FieldValue} The FieldValue sentinel for use in a call to set(),
     * create() or update().
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.update(
     *   'array', Firestore.FieldValue.arrayUnion('foo')
     * ).then(() => {
     *   return documentRef.get();
     * }).then(doc => {
     *   // doc.get('array') contains field 'foo'
     * });
     * ```
     */ static arrayUnion(...elements) {
        (0, validate_1.validateMinNumberOfArguments)('FieldValue.arrayUnion', elements, 1);
        return new ArrayUnionTransform(elements);
    }
    /**
     * Returns a special value that can be used with set(), create() or update()
     * that tells the server to remove the given elements from any array value
     * that already exists on the server. All instances of each element specified
     * will be removed from the array. If the field being modified is not already
     * an array it will be overwritten with an empty array.
     *
     * @param {...*} elements The elements to remove from the array.
     * @return {FieldValue} The FieldValue sentinel for use in a call to set(),
     * create() or update().
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.update(
     *   'array', Firestore.FieldValue.arrayRemove('foo')
     * ).then(() => {
     *   return documentRef.get();
     * }).then(doc => {
     *   // doc.get('array') no longer contains field 'foo'
     * });
     * ```
     */ static arrayRemove(...elements) {
        (0, validate_1.validateMinNumberOfArguments)('FieldValue.arrayRemove', elements, 1);
        return new ArrayRemoveTransform(elements);
    }
    /**
     * Returns true if this `FieldValue` is equal to the provided value.
     *
     * @param {*} other The value to compare against.
     * @return {boolean} true if this `FieldValue` is equal to the provided value.
     *
     * @example
     * ```
     * let fieldValues = [
     *   Firestore.FieldValue.increment(-1.0),
     *   Firestore.FieldValue.increment(-1),
     *   Firestore.FieldValue.increment(-0.0),
     *   Firestore.FieldValue.increment(-0),
     *   Firestore.FieldValue.increment(0),
     *   Firestore.FieldValue.increment(0.0),
     *   Firestore.FieldValue.increment(1),
     *   Firestore.FieldValue.increment(1.0)
     * ];
     *
     * let equal = 0;
     * for (let i = 0; i < fieldValues.length; ++i) {
     *   for (let j = i + 1; j < fieldValues.length; ++j) {
     *     if (fieldValues[i].isEqual(fieldValues[j])) {
     *       ++equal;
     *     }
     *   }
     * }
     * console.log(`Found ${equal} equalities.`);
     * ```
     */ isEqual(other) {
        return this === other;
    }
}
exports.FieldValue = FieldValue;
/**
 * An internal interface shared by all field transforms.
 *
 * A 'FieldTransform` subclass should implement '.includeInDocumentMask',
 * '.includeInDocumentTransform' and 'toProto' (if '.includeInDocumentTransform'
 * is 'true').
 *
 * @private
 * @internal
 * @abstract
 */ class FieldTransform extends FieldValue {
}
exports.FieldTransform = FieldTransform;
/**
 * A transform that deletes a field from a Firestore document.
 *
 * @private
 * @internal
 */ class DeleteTransform extends FieldTransform {
    constructor(){
        super();
    }
    /**
     * Deletes are included in document masks.
     * @private
     * @internal
     */ get includeInDocumentMask() {
        return true;
    }
    /**
     * Deletes are are omitted from document transforms.
     * @private
     * @internal
     */ get includeInDocumentTransform() {
        return false;
    }
    get methodName() {
        return 'FieldValue.delete';
    }
    validate() {}
    toProto() {
        throw new Error('FieldValue.delete() should not be included in a FieldTransform');
    }
}
exports.DeleteTransform = DeleteTransform;
/**
 * Sentinel value for a field delete.
 * @private
 * @internal
 */ DeleteTransform.DELETE_SENTINEL = new DeleteTransform();
/**
 * A transform that sets a field to the Firestore server time.
 *
 * @private
 * @internal
 */ class ServerTimestampTransform extends FieldTransform {
    constructor(){
        super();
    }
    /**
     * Server timestamps are omitted from document masks.
     *
     * @private
     * @internal
     */ get includeInDocumentMask() {
        return false;
    }
    /**
     * Server timestamps are included in document transforms.
     *
     * @private
     * @internal
     */ get includeInDocumentTransform() {
        return true;
    }
    get methodName() {
        return 'FieldValue.serverTimestamp';
    }
    validate() {}
    toProto(serializer, fieldPath) {
        return {
            fieldPath: fieldPath.formattedName,
            setToServerValue: 'REQUEST_TIME'
        };
    }
}
/**
 * Sentinel value for a server timestamp.
 *
 * @private
 * @internal
 */ ServerTimestampTransform.SERVER_TIMESTAMP_SENTINEL = new ServerTimestampTransform();
/**
 * Increments a field value on the backend.
 *
 * @private
 * @internal
 */ class NumericIncrementTransform extends FieldTransform {
    constructor(operand){
        super();
        this.operand = operand;
    }
    /**
     * Numeric transforms are omitted from document masks.
     *
     * @private
     * @internal
     */ get includeInDocumentMask() {
        return false;
    }
    /**
     * Numeric transforms are included in document transforms.
     *
     * @private
     * @internal
     */ get includeInDocumentTransform() {
        return true;
    }
    get methodName() {
        return 'FieldValue.increment';
    }
    validate() {
        (0, validate_1.validateNumber)('FieldValue.increment()', this.operand);
    }
    toProto(serializer, fieldPath) {
        const encodedOperand = serializer.encodeValue(this.operand);
        return {
            fieldPath: fieldPath.formattedName,
            increment: encodedOperand
        };
    }
    isEqual(other) {
        return this === other || other instanceof NumericIncrementTransform && this.operand === other.operand;
    }
}
/**
 * Transforms an array value via a union operation.
 *
 * @private
 * @internal
 */ class ArrayUnionTransform extends FieldTransform {
    constructor(elements){
        super();
        this.elements = elements;
    }
    /**
     * Array transforms are omitted from document masks.
     * @private
     * @internal
     */ get includeInDocumentMask() {
        return false;
    }
    /**
     * Array transforms are included in document transforms.
     * @private
     * @internal
     */ get includeInDocumentTransform() {
        return true;
    }
    get methodName() {
        return 'FieldValue.arrayUnion';
    }
    validate(allowUndefined) {
        for(let i = 0; i < this.elements.length; ++i){
            validateArrayElement(i, this.elements[i], allowUndefined);
        }
    }
    toProto(serializer, fieldPath) {
        const encodedElements = serializer.encodeValue(this.elements).arrayValue;
        return {
            fieldPath: fieldPath.formattedName,
            appendMissingElements: encodedElements
        };
    }
    isEqual(other) {
        return this === other || other instanceof ArrayUnionTransform && deepEqual(this.elements, other.elements);
    }
}
/**
 * Transforms an array value via a remove operation.
 *
 * @private
 * @internal
 */ class ArrayRemoveTransform extends FieldTransform {
    constructor(elements){
        super();
        this.elements = elements;
    }
    /**
     * Array transforms are omitted from document masks.
     * @private
     * @internal
     */ get includeInDocumentMask() {
        return false;
    }
    /**
     * Array transforms are included in document transforms.
     * @private
     * @internal
     */ get includeInDocumentTransform() {
        return true;
    }
    get methodName() {
        return 'FieldValue.arrayRemove';
    }
    validate(allowUndefined) {
        for(let i = 0; i < this.elements.length; ++i){
            validateArrayElement(i, this.elements[i], allowUndefined);
        }
    }
    toProto(serializer, fieldPath) {
        const encodedElements = serializer.encodeValue(this.elements).arrayValue;
        return {
            fieldPath: fieldPath.formattedName,
            removeAllFromArray: encodedElements
        };
    }
    isEqual(other) {
        return this === other || other instanceof ArrayRemoveTransform && deepEqual(this.elements, other.elements);
    }
}
/**
 * Validates that `value` can be used as an element inside of an array. Certain
 * field values (such as ServerTimestamps) are rejected. Nested arrays are also
 * rejected.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The value to validate.
 * @param allowUndefined Whether to allow nested properties that are `undefined`.
 */ function validateArrayElement(arg, value, allowUndefined) {
    if (Array.isArray(value)) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'array element')} Nested arrays are not supported.`);
    }
    (0, serializer_1.validateUserInput)(arg, value, 'array element', /*path=*/ {
        allowDeletes: 'none',
        allowTransforms: false,
        allowUndefined
    }, /*path=*/ undefined, /*level=*/ 0, /*inArray=*/ true);
} //# sourceMappingURL=field-value.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/types.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultConverter = defaultConverter;
/**
 * A default converter to use when none is provided.
 *
 * By declaring the converter as a variable instead of creating the object
 * inside defaultConverter(), object equality when comparing default converters
 * is preserved.
 * @private
 * @internal
 */ const defaultConverterObj = {
    toFirestore (modelObject) {
        return modelObject;
    },
    fromFirestore (snapshot) {
        return snapshot.data();
    }
};
/**
 * A default converter to use when none is provided.
 * @private
 * @internal
 */ function defaultConverter() {
    return defaultConverterObj;
} //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/document-change.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DocumentChange = void 0;
/**
 * A DocumentChange represents a change to the documents matching a query.
 * It contains the document affected and the type of change that occurred.
 *
 * @class DocumentChange
 */ class DocumentChange {
    /**
     * @private
     *
     * @param {string} type 'added' | 'removed' | 'modified'.
     * @param {QueryDocumentSnapshot} document The document.
     * @param {number} oldIndex The index in the documents array prior to this
     * change.
     * @param {number} newIndex The index in the documents array after this
     * change.
     */ constructor(type, document, oldIndex, newIndex){
        this._type = type;
        this._document = document;
        this._oldIndex = oldIndex;
        this._newIndex = newIndex;
    }
    /**
     * The type of change ('added', 'modified', or 'removed').
     *
     * @type {string}
     * @name DocumentChange#type
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     * let docsArray = [];
     *
     * let unsubscribe = query.onSnapshot(querySnapshot => {
     *   for (let change of querySnapshot.docChanges) {
     *     console.log(`Type of change is ${change.type}`);
     *   }
     * });
     *
     * // Remove this listener.
     * unsubscribe();
     * ```
     */ get type() {
        return this._type;
    }
    /**
     * The document affected by this change.
     *
     * @type {QueryDocumentSnapshot}
     * @name DocumentChange#doc
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * let unsubscribe = query.onSnapshot(querySnapshot => {
     *   for (let change of querySnapshot.docChanges) {
     *     console.log(change.doc.data());
     *   }
     * });
     *
     * // Remove this listener.
     * unsubscribe();
     * ```
     */ get doc() {
        return this._document;
    }
    /**
     * The index of the changed document in the result set immediately prior to
     * this DocumentChange (i.e. supposing that all prior DocumentChange objects
     * have been applied). Is -1 for 'added' events.
     *
     * @type {number}
     * @name DocumentChange#oldIndex
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     * let docsArray = [];
     *
     * let unsubscribe = query.onSnapshot(querySnapshot => {
     *   for (let change of querySnapshot.docChanges) {
     *     if (change.oldIndex !== -1) {
     *       docsArray.splice(change.oldIndex, 1);
     *     }
     *     if (change.newIndex !== -1) {
     *       docsArray.splice(change.newIndex, 0, change.doc);
     *     }
     *   }
     * });
     *
     * // Remove this listener.
     * unsubscribe();
     * ```
     */ get oldIndex() {
        return this._oldIndex;
    }
    /**
     * The index of the changed document in the result set immediately after
     * this DocumentChange (i.e. supposing that all prior DocumentChange
     * objects and the current DocumentChange object have been applied).
     * Is -1 for 'removed' events.
     *
     * @type {number}
     * @name DocumentChange#newIndex
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     * let docsArray = [];
     *
     * let unsubscribe = query.onSnapshot(querySnapshot => {
     *   for (let change of querySnapshot.docChanges) {
     *     if (change.oldIndex !== -1) {
     *       docsArray.splice(change.oldIndex, 1);
     *     }
     *     if (change.newIndex !== -1) {
     *       docsArray.splice(change.newIndex, 0, change.doc);
     *     }
     *   }
     * });
     *
     * // Remove this listener.
     * unsubscribe();
     * ```
     */ get newIndex() {
        return this._newIndex;
    }
    /**
     * Returns true if the data in this `DocumentChange` is equal to the provided
     * value.
     *
     * @param {*} other The value to compare against.
     * @return true if this `DocumentChange` is equal to the provided value.
     */ isEqual(other) {
        if (this === other) {
            return true;
        }
        return other instanceof DocumentChange && this._type === other._type && this._oldIndex === other._oldIndex && this._newIndex === other._newIndex && this._document.isEqual(other._document);
    }
}
exports.DocumentChange = DocumentChange; //# sourceMappingURL=document-change.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/query-profile.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExplainResults = exports.ExplainMetrics = exports.ExecutionStats = exports.PlanSummary = void 0;
/**
 * PlanSummary contains information about the planning stage of a query.
 *
 * @class PlanSummary
 */ class PlanSummary {
    /**
     * @private
     * @internal
     */ constructor(indexesUsed){
        this.indexesUsed = indexesUsed;
    }
    /**
     * @private
     * @internal
     */ static _fromProto(plan, serializer) {
        const indexes = [];
        if (plan && plan.indexesUsed) {
            for (const index of plan.indexesUsed){
                indexes.push(serializer.decodeGoogleProtobufStruct(index));
            }
        }
        return new PlanSummary(indexes);
    }
}
exports.PlanSummary = PlanSummary;
/**
 *  ExecutionStats contains information about the execution of a query.
 *
 * @class ExecutionStats
 */ class ExecutionStats {
    /**
     * @private
     * @internal
     */ constructor(resultsReturned, executionDuration, readOperations, debugStats){
        this.resultsReturned = resultsReturned;
        this.executionDuration = executionDuration;
        this.readOperations = readOperations;
        this.debugStats = debugStats;
    }
    /**
     * @private
     * @internal
     */ static _fromProto(stats, serializer) {
        var _a, _b;
        if (stats) {
            return new ExecutionStats(Number(stats.resultsReturned), {
                seconds: Number((_a = stats.executionDuration) === null || _a === void 0 ? void 0 : _a.seconds),
                nanoseconds: Number((_b = stats.executionDuration) === null || _b === void 0 ? void 0 : _b.nanos)
            }, Number(stats.readOperations), serializer.decodeGoogleProtobufStruct(stats.debugStats));
        }
        return null;
    }
}
exports.ExecutionStats = ExecutionStats;
/**
 * ExplainMetrics contains information about planning and execution of a query.
 *
 * @class ExplainMetrics
 */ class ExplainMetrics {
    /**
     * @private
     * @internal
     */ constructor(planSummary, executionStats){
        this.planSummary = planSummary;
        this.executionStats = executionStats;
    }
    /**
     * @private
     * @internal
     */ static _fromProto(metrics, serializer) {
        return new ExplainMetrics(PlanSummary._fromProto(metrics.planSummary, serializer), ExecutionStats._fromProto(metrics.executionStats, serializer));
    }
}
exports.ExplainMetrics = ExplainMetrics;
/**
 * ExplainResults contains information about planning, execution, and results
 * of a query.
 *
 * @class ExplainResults
 */ class ExplainResults {
    /**
     * @private
     * @internal
     */ constructor(metrics, snapshot){
        this.metrics = metrics;
        this.snapshot = snapshot;
    }
}
exports.ExplainResults = ExplainResults; //# sourceMappingURL=query-profile.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/vector-query-snapshot.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorQuerySnapshot = void 0;
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
/**
 * A `VectorQuerySnapshot` contains zero or more `QueryDocumentSnapshot` objects
 * representing the results of a query. The documents can be accessed as an
 * array via the `docs` property or enumerated using the `forEach` method. The
 * number of documents can be determined via the `empty` and `size`
 * properties.
 */ class VectorQuerySnapshot {
    /**
     * @private
     * @internal
     *
     * @param _query - The originating query.
     * @param _readTime - The time when this query snapshot was obtained.
     * @param _size - The number of documents in the result set.
     * @param docs - A callback returning a sorted array of documents matching
     * this query
     * @param changes - A callback returning a sorted array of document change
     * events for this snapshot.
     */ constructor(_query, _readTime, _size, docs, changes){
        this._query = _query;
        this._readTime = _readTime;
        this._size = _size;
        this._materializedDocs = null;
        this._materializedChanges = null;
        this._docs = null;
        this._changes = null;
        this._docs = docs;
        this._changes = changes;
    }
    /**
     * The `VectorQuery` on which you called get() in order to get this
     * `VectorQuerySnapshot`.
     *
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.findNearest("embedding", [0, 0], {limit: 10, distanceMeasure: "EUCLIDEAN"})
     *   .get().then(querySnapshot => {
     *     console.log(`Returned first batch of results`);
     *     let query = querySnapshot.query;
     *     return query.offset(10).get();
     *   }).then(() => {
     *   console.log(`Returned second batch of results`);
     *   });
     * ```
     */ get query() {
        return this._query;
    }
    /**
     * An array of all the documents in this `VectorQuerySnapshot`.
     *
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col')
     *   .findNearest("embedding", [0, 0], {limit: 10, distanceMeasure: "EUCLIDEAN"});
     *
     * query.get().then(querySnapshot => {
     *   let docs = querySnapshot.docs;
     *   for (let doc of docs) {
     *     console.log(`Document found at path: ${doc.ref.path}`);
     *   }
     * });
     * ```
     */ get docs() {
        if (this._materializedDocs) {
            return this._materializedDocs;
        }
        this._materializedDocs = this._docs();
        this._docs = null;
        return this._materializedDocs;
    }
    /**
     * `true` if there are no documents in the `VectorQuerySnapshot`.
     *
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col')
     *   .findNearest("embedding", [0, 0], {limit: 10, distanceMeasure: "EUCLIDEAN"});
     *
     * query.get().then(querySnapshot => {
     *   if (querySnapshot.empty) {
     *     console.log('No documents found.');
     *   }
     * });
     * ```
     */ get empty() {
        return this._size === 0;
    }
    /**
     * The number of documents in the `VectorQuerySnapshot`.
     *
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col')
     *   .findNearest("embedding", [0, 0], {limit: 10, distanceMeasure: "EUCLIDEAN"});
     *
     * query.get().then(querySnapshot => {
     *   console.log(`Found ${querySnapshot.size} documents.`);
     * });
     * ```
     */ get size() {
        return this._size;
    }
    /**
     * The time this `VectorQuerySnapshot` was obtained.
     *
     * @example
     * ```
     * let query = firestore.collection('col')
     *   .findNearest("embedding", [0, 0], {limit: 10, distanceMeasure: "EUCLIDEAN"});
     *
     * query.get().then((querySnapshot) => {
     *   let readTime = querySnapshot.readTime;
     *   console.log(`Query results returned at '${readTime.toDate()}'`);
     * });
     * ```
     */ get readTime() {
        return this._readTime;
    }
    /**
     * Returns an array of the documents changes since the last snapshot. If
     * this is the first snapshot, all documents will be in the list as added
     * changes.
     *
     * @returns An array of the documents changes since the last snapshot.
     *
     * @example
     * ```
     * let query = firestore.collection('col')
     *   .findNearest("embedding", [0, 0], {limit: 10, distanceMeasure: "EUCLIDEAN"});
     *
     * query.get().then(querySnapshot => {
     *   let changes = querySnapshot.docChanges();
     *   for (let change of changes) {
     *     console.log(`A document was ${change.type}.`);
     *   }
     * });
     * ```
     */ docChanges() {
        if (this._materializedChanges) {
            return this._materializedChanges;
        }
        this._materializedChanges = this._changes();
        this._changes = null;
        return this._materializedChanges;
    }
    /**
     * Enumerates all of the documents in the `VectorQuerySnapshot`. This is a convenience
     * method for running the same callback on each {@link QueryDocumentSnapshot}
     * that is returned.
     *
     * @param callback - A callback to be called with a
     * {@link QueryDocumentSnapshot} for each document in
     * the snapshot.
     * @param thisArg - The `this` binding for the callback..
     *
     * @example
     * ```
     * let query = firestore.collection('col')
     *   .findNearest("embedding", [0, 0], {limit: 10, distanceMeasure: "EUCLIDEAN"});
     *
     * query.get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ forEach(callback, thisArg) {
        (0, validate_1.validateFunction)('callback', callback);
        for (const doc of this.docs){
            callback.call(thisArg, doc);
        }
    }
    /**
     * Returns true if the document data in this `VectorQuerySnapshot` is equal to the
     * provided value.
     *
     * @param other - The value to compare against.
     * @returns true if this `VectorQuerySnapshot` is equal to the provided
     * value.
     */ isEqual(other) {
        // Since the read time is different on every query read, we explicitly
        // ignore all metadata in this comparison.
        if (this === other) {
            return true;
        }
        if (!(other instanceof VectorQuerySnapshot)) {
            return false;
        }
        if (this._size !== other._size) {
            return false;
        }
        if (!this._query.isEqual(other._query)) {
            return false;
        }
        if (this._materializedDocs && !this._materializedChanges) {
            // If we have only materialized the documents, we compare them first.
            return (0, util_1.isArrayEqual)(this.docs, other.docs) && (0, util_1.isArrayEqual)(this.docChanges(), other.docChanges());
        }
        // Otherwise, we compare the changes first as we expect there to be fewer.
        return (0, util_1.isArrayEqual)(this.docChanges(), other.docChanges()) && (0, util_1.isArrayEqual)(this.docs, other.docs);
    }
}
exports.VectorQuerySnapshot = VectorQuerySnapshot; //# sourceMappingURL=vector-query-snapshot.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/vector-query.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorQuery = void 0;
const field_value_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/field-value.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const query_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query-util.js [app-client] (ecmascript)");
const vector_query_snapshot_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/vector-query-snapshot.js [app-client] (ecmascript)");
const query_profile_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/query-profile.js [app-client] (ecmascript)");
/**
 * A query that finds the documents whose vector fields are closest to a certain query vector.
 * Create an instance of `VectorQuery` with {@link Query.findNearest}.
 */ class VectorQuery {
    /**
     * @private
     * @internal
     */ constructor(_query, _options){
        this._query = _query;
        this._options = _options;
        this._queryUtil = new query_util_1.QueryUtil(_query._firestore, _query._queryOptions, _query._serializer);
    }
    /** The query whose results participants in the vector search. Filtering
     * performed by the query will apply before the vector search.
     **/ get query() {
        return this._query;
    }
    /**
     * @private
     * @internal
     */ get _rawVectorField() {
        return typeof this._options.vectorField === 'string' ? this._options.vectorField : this._options.vectorField.toString();
    }
    /**
     * @private
     * @internal
     */ get _rawDistanceResultField() {
        if (typeof this._options.distanceResultField === 'undefined') return;
        return typeof this._options.distanceResultField === 'string' ? this._options.distanceResultField : this._options.distanceResultField.toString();
    }
    /**
     * @private
     * @internal
     */ get _rawQueryVector() {
        return Array.isArray(this._options.queryVector) ? this._options.queryVector : this._options.queryVector.toArray();
    }
    /**
     * Plans and optionally executes this vector search query. Returns a Promise that will be
     * resolved with the planner information, statistics from the query execution (if any),
     * and the query results (if any).
     *
     * @return A Promise that will be resolved with the planner information, statistics
     *  from the query execution (if any), and the query results (if any).
     */ async explain(options) {
        if (options === undefined) {
            options = {};
        }
        const { result, explainMetrics } = await this._getResponse(options);
        if (!explainMetrics) {
            throw new Error('No explain results');
        }
        return new query_profile_1.ExplainResults(explainMetrics, result || null);
    }
    /**
     * Executes this vector search query.
     *
     * @returns A promise that will be resolved with the results of the query.
     */ async get() {
        const { result } = await this._getResponse();
        if (!result) {
            throw new Error('No VectorQuerySnapshot result');
        }
        return result;
    }
    _getResponse(explainOptions) {
        return this._queryUtil._getResponse(this, /*transactionOrReadTime*/ undefined, // VectorQuery cannot be retried with cursors as they do not support cursors yet.
        /*retryWithCursor*/ false, explainOptions);
    }
    /**
     * Internal streaming method that accepts an optional transaction ID.
     *
     * @param transactionId - A transaction ID.
     * @private
     * @internal
     * @returns A stream of document results.
     */ _stream(transactionId) {
        return this._queryUtil._stream(this, transactionId, /*retryWithCursor*/ false);
    }
    /**
     * Internal method for serializing a query to its proto
     * representation with an optional transaction id.
     *
     * @private
     * @internal
     * @returns Serialized JSON for the query.
     */ toProto(transactionOrReadTime, explainOptions) {
        var _a, _b, _c;
        const queryProto = this._query.toProto(transactionOrReadTime);
        const queryVector = Array.isArray(this._options.queryVector) ? new field_value_1.VectorValue(this._options.queryVector) : this._options.queryVector;
        queryProto.structuredQuery.findNearest = {
            limit: {
                value: this._options.limit
            },
            distanceMeasure: this._options.distanceMeasure,
            vectorField: {
                fieldPath: path_1.FieldPath.fromArgument(this._options.vectorField).formattedName
            },
            queryVector: queryVector._toProto(this._query._serializer),
            distanceResultField: ((_a = this._options) === null || _a === void 0 ? void 0 : _a.distanceResultField) ? path_1.FieldPath.fromArgument(this._options.distanceResultField).formattedName : undefined,
            distanceThreshold: ((_b = this._options) === null || _b === void 0 ? void 0 : _b.distanceThreshold) ? {
                value: (_c = this._options) === null || _c === void 0 ? void 0 : _c.distanceThreshold
            } : undefined
        };
        if (explainOptions) {
            queryProto.explainOptions = explainOptions;
        }
        return queryProto;
    }
    /**
     * Construct the resulting vector snapshot for this query with given documents.
     *
     * @private
     * @internal
     */ _createSnapshot(readTime, size, docs, changes) {
        return new vector_query_snapshot_1.VectorQuerySnapshot(this, readTime, size, docs, changes);
    }
    /**
     * Construct a new vector query whose result will start after To support stream().
     * This now throws an exception because cursors are not supported from the backend for vector queries yet.
     *
     * @private
     * @internal
     * @returns Serialized JSON for the query.
     */ startAfter(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    ...fieldValuesOrDocumentSnapshot) {
        throw new Error('Unimplemented: Vector query does not support cursors yet.');
    }
    /**
     * Compares this object with the given object for equality.
     *
     * This object is considered "equal" to the other object if and only if
     * `other` performs the same vector distance search as this `VectorQuery` and
     * the underlying Query of `other` compares equal to that of this object
     * using `Query.isEqual()`.
     *
     * @param other - The object to compare to this object for equality.
     * @returns `true` if this object is "equal" to the given object, as
     * defined above, or `false` otherwise.
     */ isEqual(other) {
        if (this === other) {
            return true;
        }
        if (!(other instanceof VectorQuery)) {
            return false;
        }
        if (!this.query.isEqual(other.query)) {
            return false;
        }
        return this._rawVectorField === other._rawVectorField && (0, util_1.isPrimitiveArrayEqual)(this._rawQueryVector, other._rawQueryVector) && this._options.limit === other._options.limit && this._options.distanceMeasure === other._options.distanceMeasure && this._options.distanceThreshold === other._options.distanceThreshold && this._rawDistanceResultField === other._rawDistanceResultField;
    }
}
exports.VectorQuery = VectorQuery; //# sourceMappingURL=vector-query.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/types.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LimitType = void 0;
/*!
 * Denotes whether a provided limit is applied to the beginning or the end of
 * the result set.
 */ var LimitType;
(function(LimitType) {
    LimitType[LimitType["First"] = 0] = "First";
    LimitType[LimitType["Last"] = 1] = "Last";
})(LimitType || (exports.LimitType = LimitType = {})); /**
 * onSnapshot() callback that receives a QuerySnapshot.
 *
 * @callback querySnapshotCallback
 * @param {QuerySnapshot} snapshot A query snapshot.
 */  /**
 * onSnapshot() callback that receives a DocumentSnapshot.
 *
 * @callback documentSnapshotCallback
 * @param {DocumentSnapshot} snapshot A document snapshot.
 */  /**
 * onSnapshot() callback that receives an error.
 *
 * @callback errorCallback
 * @param {Error} err An error from a listen.
 */  //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/constants.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NOOP_MESSAGE = exports.comparisonOperators = exports.directionOperators = void 0;
/**
 * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'
 * (descending or ascending).
 *
 * @private
 * @internal
 */ exports.directionOperators = {
    asc: 'ASCENDING',
    desc: 'DESCENDING'
};
/**
 * Filter conditions in a `Query.where()` clause are specified using the
 * strings '<', '<=', '==', '!=', '>=', '>', 'array-contains', 'in', 'not-in',
 * and 'array-contains-any'.
 *
 * @private
 * @internal
 */ exports.comparisonOperators = {
    '<': 'LESS_THAN',
    '<=': 'LESS_THAN_OR_EQUAL',
    '==': 'EQUAL',
    '!=': 'NOT_EQUAL',
    '>': 'GREATER_THAN',
    '>=': 'GREATER_THAN_OR_EQUAL',
    'array-contains': 'ARRAY_CONTAINS',
    in: 'IN',
    'not-in': 'NOT_IN',
    'array-contains-any': 'ARRAY_CONTAINS_ANY'
};
exports.NOOP_MESSAGE = Symbol('a noop message'); //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ATTRIBUTE_KEY_ATTEMPTS_REMAINING = exports.ATTRIBUTE_KEY_ATTEMPTS_ALLOWED = exports.ATTRIBUTE_KEY_TRANSACTION_TYPE = exports.ATTRIBUTE_KEY_IS_RETRY_WITH_CURSOR = exports.ATTRIBUTE_KEY_NUM_RESPONSES = exports.ATTRIBUTE_KEY_IS_TRANSACTIONAL = exports.ATTRIBUTE_KEY_DOC_COUNT = exports.ATTRIBUTE_SETTINGS_PREFIX = exports.ATTRIBUTE_SERVICE_PREFIX = exports.SPAN_NAME_BULK_WRITER_COMMIT = exports.SPAN_NAME_PARTITION_QUERY = exports.SPAN_NAME_BATCH_COMMIT = exports.SPAN_NAME_TRANSACTION_COMMIT = exports.SPAN_NAME_TRANSACTION_ROLLBACK = exports.SPAN_NAME_TRANSACTION_GET_DOCUMENTS = exports.SPAN_NAME_TRANSACTION_GET_DOCUMENT = exports.SPAN_NAME_TRANSACTION_GET_AGGREGATION_QUERY = exports.SPAN_NAME_TRANSACTION_GET_QUERY = exports.SPAN_NAME_TRANSACTION_RUN = exports.SPAN_NAME_AGGREGATION_QUERY_GET = exports.SPAN_NAME_QUERY_GET = exports.SPAN_NAME_COL_REF_LIST_DOCUMENTS = exports.SPAN_NAME_COL_REF_ADD = exports.SPAN_NAME_DOC_REF_LIST_COLLECTIONS = exports.SPAN_NAME_DOC_REF_GET = exports.SPAN_NAME_DOC_REF_DELETE = exports.SPAN_NAME_DOC_REF_UPDATE = exports.SPAN_NAME_DOC_REF_SET = exports.SPAN_NAME_DOC_REF_CREATE = exports.SPAN_NAME_RUN_AGGREGATION_QUERY = exports.SPAN_NAME_RUN_QUERY = exports.SPAN_NAME_BATCH_GET_DOCUMENTS = exports.SERVICE = void 0;
/**
 * Span names for instrumented operations.
 */ exports.SERVICE = 'google.firestore.v1.Firestore/';
exports.SPAN_NAME_BATCH_GET_DOCUMENTS = 'BatchGetDocuments';
exports.SPAN_NAME_RUN_QUERY = 'RunQuery';
exports.SPAN_NAME_RUN_AGGREGATION_QUERY = 'RunAggregationQuery';
exports.SPAN_NAME_DOC_REF_CREATE = 'DocumentReference.Create';
exports.SPAN_NAME_DOC_REF_SET = 'DocumentReference.Set';
exports.SPAN_NAME_DOC_REF_UPDATE = 'DocumentReference.Update';
exports.SPAN_NAME_DOC_REF_DELETE = 'DocumentReference.Delete';
exports.SPAN_NAME_DOC_REF_GET = 'DocumentReference.Get';
exports.SPAN_NAME_DOC_REF_LIST_COLLECTIONS = 'DocumentReference.ListCollections';
exports.SPAN_NAME_COL_REF_ADD = 'CollectionReference.Add';
exports.SPAN_NAME_COL_REF_LIST_DOCUMENTS = 'CollectionReference.ListDocuments';
exports.SPAN_NAME_QUERY_GET = 'Query.Get';
exports.SPAN_NAME_AGGREGATION_QUERY_GET = 'AggregationQuery.Get';
exports.SPAN_NAME_TRANSACTION_RUN = 'Transaction.Run';
exports.SPAN_NAME_TRANSACTION_GET_QUERY = 'Transaction.Get.Query';
exports.SPAN_NAME_TRANSACTION_GET_AGGREGATION_QUERY = 'Transaction.Get.AggregationQuery';
exports.SPAN_NAME_TRANSACTION_GET_DOCUMENT = 'Transaction.Get.Document';
exports.SPAN_NAME_TRANSACTION_GET_DOCUMENTS = 'Transaction.Get.Documents';
exports.SPAN_NAME_TRANSACTION_ROLLBACK = 'Transaction.Rollback';
exports.SPAN_NAME_TRANSACTION_COMMIT = 'Transaction.Commit';
exports.SPAN_NAME_BATCH_COMMIT = 'Batch.Commit';
exports.SPAN_NAME_PARTITION_QUERY = 'PartitionQuery';
exports.SPAN_NAME_BULK_WRITER_COMMIT = 'BulkWriter.Commit';
exports.ATTRIBUTE_SERVICE_PREFIX = 'gcp.firestore';
exports.ATTRIBUTE_SETTINGS_PREFIX = `${exports.ATTRIBUTE_SERVICE_PREFIX}.settings`;
exports.ATTRIBUTE_KEY_DOC_COUNT = 'doc_count';
exports.ATTRIBUTE_KEY_IS_TRANSACTIONAL = 'transactional';
exports.ATTRIBUTE_KEY_NUM_RESPONSES = 'response_count';
exports.ATTRIBUTE_KEY_IS_RETRY_WITH_CURSOR = 'retry_query_with_cursor';
exports.ATTRIBUTE_KEY_TRANSACTION_TYPE = 'transaction_type';
exports.ATTRIBUTE_KEY_ATTEMPTS_ALLOWED = 'attempts_allowed';
exports.ATTRIBUTE_KEY_ATTEMPTS_REMAINING = 'attempts_remaining'; //# sourceMappingURL=trace-util.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/query-util.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryUtil = void 0;
const stream_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
const timestamp_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
const document_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const document_change_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document-change.js [app-client] (ecmascript)");
const query_profile_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/query-profile.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
const vector_query_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/vector-query.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/types.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/constants.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
class QueryUtil {
    constructor(/** @private */ _firestore, /** @private */ _queryOptions, /** @private */ _serializer){
        this._firestore = _firestore;
        this._queryOptions = _queryOptions;
        this._serializer = _serializer;
    }
    _getResponse(query, transactionOrReadTime, retryWithCursor = true, explainOptions) {
        // Capture the error stack to preserve stack tracing across async calls.
        const stack = Error().stack;
        return new Promise((resolve, reject)=>{
            const docs = [];
            const output = {};
            this._stream(query, transactionOrReadTime, retryWithCursor, explainOptions).on('error', (err)=>{
                reject((0, util_1.wrapError)(err, stack));
            }).on('data', (data)=>{
                if (data.transaction) {
                    output.transaction = data.transaction;
                }
                if (data.readTime) {
                    output.readTime = data.readTime;
                }
                if (data.explainMetrics) {
                    output.explainMetrics = data.explainMetrics;
                }
                if (data.document) {
                    docs.push(data.document);
                }
            }).on('end', ()=>{
                if (this._queryOptions.limitType === types_1.LimitType.Last) {
                    // The results for limitToLast queries need to be flipped since
                    // we reversed the ordering constraints before sending the query
                    // to the backend.
                    docs.reverse();
                }
                // Only return a snapshot when we have a readTime
                // explain queries with analyze !== true will return no documents and no read time
                const result = output.readTime ? query._createSnapshot(output.readTime, docs.length, ()=>docs, ()=>{
                    const changes = [];
                    for(let i = 0; i < docs.length; ++i){
                        changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));
                    }
                    return changes;
                }) : undefined;
                resolve({
                    transaction: output.transaction,
                    explainMetrics: output.explainMetrics,
                    result
                });
            });
        });
    }
    // This method exists solely to enable unit tests to mock it.
    _isPermanentRpcError(err, methodName) {
        return (0, util_1.isPermanentRpcError)(err, methodName);
    }
    _hasRetryTimedOut(methodName, startTime) {
        const totalTimeout = (0, util_1.getTotalTimeout)(methodName);
        if (totalTimeout === 0) {
            return false;
        }
        return Date.now() - startTime >= totalTimeout;
    }
    stream(query) {
        if (this._queryOptions.limitType === types_1.LimitType.Last) {
            throw new Error('Query results for queries that include limitToLast() ' + 'constraints cannot be streamed. Use Query.get() instead.');
        }
        const responseStream = this._stream(query);
        const transform = new stream_1.Transform({
            objectMode: true,
            transform (chunk, encoding, callback) {
                callback(undefined, chunk.document);
            }
        });
        responseStream.pipe(transform);
        responseStream.on('error', (e)=>transform.destroy(e));
        return transform;
    }
    _stream(query, transactionOrReadTime, retryWithCursor = true, explainOptions) {
        const tag = (0, util_1.requestTag)();
        const startTime = Date.now();
        const isExplain = explainOptions !== undefined;
        const methodName = 'runQuery';
        let numDocumentsReceived = 0;
        let lastReceivedDocument = null;
        let backendStream;
        const stream = new stream_1.Transform({
            objectMode: true,
            transform: (proto, enc, callback)=>{
                var _a;
                if (proto === constants_1.NOOP_MESSAGE) {
                    callback(undefined);
                    return;
                }
                const output = {};
                // Proto comes with zero-length buffer by default
                if ((_a = proto.transaction) === null || _a === void 0 ? void 0 : _a.length) {
                    output.transaction = proto.transaction;
                }
                if (proto.readTime) {
                    output.readTime = timestamp_1.Timestamp.fromProto(proto.readTime);
                }
                if (proto.document) {
                    const document = this._firestore.snapshot_(proto.document, proto.readTime);
                    const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(this._queryOptions.converter));
                    // Recreate the QueryDocumentSnapshot with the DocumentReference
                    // containing the original converter.
                    finalDoc.fieldsProto = document._fieldsProto;
                    finalDoc.readTime = document.readTime;
                    finalDoc.createTime = document.createTime;
                    finalDoc.updateTime = document.updateTime;
                    lastReceivedDocument = finalDoc.build();
                    output.document = lastReceivedDocument;
                }
                if (proto.explainMetrics) {
                    output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, this._serializer);
                }
                ++numDocumentsReceived;
                callback(undefined, output);
                if (proto.done) {
                    (0, logger_1.logger)('QueryUtil._stream', tag, 'Trigger Logical Termination.');
                    this._firestore._traceUtil.currentSpan().addEvent(`Firestore.${methodName}: Received RunQueryResponse.Done.`);
                    backendStream.unpipe(stream);
                    backendStream.resume();
                    backendStream.end();
                    stream.end();
                }
            }
        });
        this._firestore.initializeIfNeeded(tag).then(async ()=>{
            // `toProto()` might throw an exception. We rely on the behavior of an
            // async function to convert this exception into the rejected Promise we
            // catch below.
            let request = query.toProto(transactionOrReadTime, explainOptions);
            let isRetryRequestWithCursor = false;
            let streamActive;
            do {
                streamActive = new util_1.Deferred();
                this._firestore._traceUtil.currentSpan().addEvent(trace_util_1.SPAN_NAME_RUN_QUERY, {
                    [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: !!request.transaction,
                    [trace_util_1.ATTRIBUTE_KEY_IS_RETRY_WITH_CURSOR]: isRetryRequestWithCursor
                });
                backendStream = await this._firestore.requestStream(methodName, /* bidirectional= */ false, request, tag);
                backendStream.on('error', (err)=>{
                    backendStream.unpipe(stream);
                    // If a non-transactional query failed, attempt to restart.
                    // Transactional queries are retried via the transaction runner.
                    // Explain queries are not retried with a cursor. That would produce
                    // incorrect/partial profiling results.
                    if (!isExplain && !transactionOrReadTime && !this._isPermanentRpcError(err, methodName)) {
                        (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with retryable stream error:', err);
                        this._firestore._traceUtil.currentSpan().addEvent(`${trace_util_1.SPAN_NAME_RUN_QUERY}: Retryable Error.`, {
                            'error.message': err.message
                        });
                        // Enqueue a "no-op" write into the stream and wait for it to be
                        // read by the downstream consumer. This ensures that all enqueued
                        // results in the stream are consumed, which will give us an accurate
                        // value for `lastReceivedDocument`.
                        stream.write(constants_1.NOOP_MESSAGE, ()=>{
                            if (this._hasRetryTimedOut(methodName, startTime)) {
                                (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with retryable stream error but the total retry timeout has exceeded.');
                                stream.destroy(err);
                                streamActive.resolve(/* active= */ false);
                            } else if (lastReceivedDocument && retryWithCursor) {
                                if (query instanceof vector_query_1.VectorQuery) {
                                    throw new Error('Unimplemented: Vector query does not support cursors yet.');
                                }
                                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error and progress was made receiving ' + 'documents, so the stream is being retried.');
                                isRetryRequestWithCursor = true;
                                // Restart the query but use the last document we received as
                                // the query cursor. Note that we do not use backoff here. The
                                // call to `requestStream()` will backoff should the restart
                                // fail before delivering any results.
                                let newQuery;
                                if (!this._queryOptions.limit) {
                                    newQuery = query;
                                } else {
                                    const newLimit = this._queryOptions.limit - numDocumentsReceived;
                                    if (this._queryOptions.limitType === undefined || this._queryOptions.limitType === types_1.LimitType.First) {
                                        newQuery = query.limit(newLimit);
                                    } else {
                                        newQuery = query.limitToLast(newLimit);
                                    }
                                }
                                if (this._queryOptions.requireConsistency) {
                                    request = newQuery.startAfter(lastReceivedDocument).toProto(lastReceivedDocument.readTime);
                                } else {
                                    request = newQuery.startAfter(lastReceivedDocument).toProto();
                                }
                                // Set lastReceivedDocument to null before each retry attempt to ensure the retry makes progress
                                lastReceivedDocument = null;
                                streamActive.resolve(/* active= */ true);
                            } else {
                                (0, logger_1.logger)('QueryUtil._stream', tag, `Query failed with retryable stream error however either retryWithCursor="${retryWithCursor}", or ` + 'no progress was made receiving documents, so the stream is being closed.');
                                stream.destroy(err);
                                streamActive.resolve(/* active= */ false);
                            }
                        });
                    } else {
                        (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with stream error:', err);
                        this._firestore._traceUtil.currentSpan().addEvent(`${trace_util_1.SPAN_NAME_RUN_QUERY}: Error.`, {
                            'error.message': err.message
                        });
                        stream.destroy(err);
                        streamActive.resolve(/* active= */ false);
                    }
                });
                backendStream.on('end', ()=>{
                    streamActive.resolve(/* active= */ false);
                });
                backendStream.resume();
                backendStream.pipe(stream);
            }while (await streamActive.promise)
        }).catch((e)=>stream.destroy(e));
        return stream;
    }
}
exports.QueryUtil = QueryUtil; //# sourceMappingURL=query-util.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/field-order.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FieldOrder = void 0;
/**
 * A Query order-by field.
 *
 * @private
 * @internal
 * @class
 */ class FieldOrder {
    /**
     * @param field The name of a document field (member) on which to order query
     * results.
     * @param direction One of 'ASCENDING' (default) or 'DESCENDING' to
     * set the ordering direction to ascending or descending, respectively.
     */ constructor(field, direction = 'ASCENDING'){
        this.field = field;
        this.direction = direction;
    }
    /**
     * Generates the proto representation for this field order.
     * @private
     * @internal
     */ toProto() {
        return {
            field: {
                fieldPath: this.field.formattedName
            },
            direction: this.direction
        };
    }
}
exports.FieldOrder = FieldOrder; //# sourceMappingURL=field-order.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/filter-internal.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FilterInternal = void 0;
class FilterInternal {
}
exports.FilterInternal = FilterInternal; //# sourceMappingURL=filter-internal.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/field-filter-internal.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FieldFilterInternal = void 0;
const deepEqual = __turbopack_context__.r("[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)");
const filter_internal_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/filter-internal.js [app-client] (ecmascript)");
/**
 * A field constraint for a Query where clause.
 *
 * @private
 * @internal
 * @class
 */ class FieldFilterInternal extends filter_internal_1.FilterInternal {
    getFlattenedFilters() {
        return [
            this
        ];
    }
    getFilters() {
        return [
            this
        ];
    }
    /**
     * @param serializer The Firestore serializer
     * @param field The path of the property value to compare.
     * @param op A comparison operation.
     * @param value The value to which to compare the field for inclusion in a
     * query.
     */ constructor(serializer, field, op, value){
        super();
        this.serializer = serializer;
        this.field = field;
        this.op = op;
        this.value = value;
    }
    /**
     * Returns whether this FieldFilter uses an equals comparison.
     *
     * @private
     * @internal
     */ isInequalityFilter() {
        switch(this.op){
            case 'GREATER_THAN':
            case 'GREATER_THAN_OR_EQUAL':
            case 'LESS_THAN':
            case 'LESS_THAN_OR_EQUAL':
            case 'NOT_EQUAL':
            case 'NOT_IN':
                return true;
            default:
                return false;
        }
    }
    /**
     * Generates the proto representation for this field filter.
     *
     * @private
     * @internal
     */ toProto() {
        if (typeof this.value === 'number' && isNaN(this.value)) {
            return {
                unaryFilter: {
                    field: {
                        fieldPath: this.field.formattedName
                    },
                    op: this.op === 'EQUAL' ? 'IS_NAN' : 'IS_NOT_NAN'
                }
            };
        }
        if (this.value === null) {
            return {
                unaryFilter: {
                    field: {
                        fieldPath: this.field.formattedName
                    },
                    op: this.op === 'EQUAL' ? 'IS_NULL' : 'IS_NOT_NULL'
                }
            };
        }
        return {
            fieldFilter: {
                field: {
                    fieldPath: this.field.formattedName
                },
                op: this.op,
                value: this.serializer.encodeValue(this.value)
            }
        };
    }
    isEqual(other) {
        return other instanceof FieldFilterInternal && this.field.isEqual(other.field) && this.op === other.op && deepEqual(this.value, other.value);
    }
}
exports.FieldFilterInternal = FieldFilterInternal; //# sourceMappingURL=field-filter-internal.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/composite-filter-internal.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CompositeFilterInternal = void 0;
const filter_internal_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/filter-internal.js [app-client] (ecmascript)");
class CompositeFilterInternal extends filter_internal_1.FilterInternal {
    constructor(filters, operator){
        super();
        this.filters = filters;
        this.operator = operator;
        // Memoized list of all field filters that can be found by traversing the tree of filters
        // contained in this composite filter.
        this.memoizedFlattenedFilters = null;
    }
    getFilters() {
        return this.filters;
    }
    isConjunction() {
        return this.operator === 'AND';
    }
    getFlattenedFilters() {
        if (this.memoizedFlattenedFilters !== null) {
            return this.memoizedFlattenedFilters;
        }
        this.memoizedFlattenedFilters = this.filters.reduce((allFilters, subfilter)=>allFilters.concat(subfilter.getFlattenedFilters()), []);
        return this.memoizedFlattenedFilters;
    }
    toProto() {
        if (this.filters.length === 1) {
            return this.filters[0].toProto();
        }
        const proto = {
            compositeFilter: {
                op: this.operator,
                filters: this.filters.map((filter)=>filter.toProto())
            }
        };
        return proto;
    }
    isEqual(other) {
        if (other instanceof CompositeFilterInternal) {
            const otherFilters = other.getFilters();
            return this.operator === other.operator && this.getFilters().length === other.getFilters().length && this.getFilters().every((filter, index)=>filter.isEqual(otherFilters[index]));
        } else {
            return false;
        }
    }
}
exports.CompositeFilterInternal = CompositeFilterInternal; //# sourceMappingURL=composite-filter-internal.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/query-snapshot.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QuerySnapshot = void 0;
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
/**
 * A QuerySnapshot contains zero or more
 * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects
 * representing the results of a query. The documents can be accessed as an
 * array via the [documents]{@link QuerySnapshot#documents} property
 * or enumerated using the [forEach]{@link QuerySnapshot#forEach}
 * method. The number of documents can be determined via the
 * [empty]{@link QuerySnapshot#empty} and
 * [size]{@link QuerySnapshot#size} properties.
 *
 * @class QuerySnapshot
 */ class QuerySnapshot {
    /**
     * @private
     *
     * @param _query The originating query.
     * @param _readTime The time when this query snapshot was obtained.
     * @param _size The number of documents in the result set.
     * @param docs A callback returning a sorted array of documents matching
     * this query
     * @param changes A callback returning a sorted array of document change
     * events for this snapshot.
     */ constructor(_query, _readTime, _size, docs, changes){
        this._query = _query;
        this._readTime = _readTime;
        this._size = _size;
        this._materializedDocs = null;
        this._materializedChanges = null;
        this._docs = null;
        this._changes = null;
        this._docs = docs;
        this._changes = changes;
    }
    /**
     * The query on which you called get() or onSnapshot() in order to get this
     * QuerySnapshot.
     *
     * @type {Query}
     * @name QuerySnapshot#query
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.limit(10).get().then(querySnapshot => {
     *   console.log(`Returned first batch of results`);
     *   let query = querySnapshot.query;
     *   return query.offset(10).get();
     * }).then(() => {
     *   console.log(`Returned second batch of results`);
     * });
     * ```
     */ get query() {
        return this._query;
    }
    /**
     * An array of all the documents in this QuerySnapshot.
     *
     * @type {Array.<QueryDocumentSnapshot>}
     * @name QuerySnapshot#docs
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then(querySnapshot => {
     *   let docs = querySnapshot.docs;
     *   for (let doc of docs) {
     *     console.log(`Document found at path: ${doc.ref.path}`);
     *   }
     * });
     * ```
     */ get docs() {
        if (this._materializedDocs) {
            return this._materializedDocs;
        }
        this._materializedDocs = this._docs();
        this._docs = null;
        return this._materializedDocs;
    }
    /**
     * True if there are no documents in the QuerySnapshot.
     *
     * @type {boolean}
     * @name QuerySnapshot#empty
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then(querySnapshot => {
     *   if (querySnapshot.empty) {
     *     console.log('No documents found.');
     *   }
     * });
     * ```
     */ get empty() {
        return this._size === 0;
    }
    /**
     * The number of documents in the QuerySnapshot.
     *
     * @type {number}
     * @name QuerySnapshot#size
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then(querySnapshot => {
     *   console.log(`Found ${querySnapshot.size} documents.`);
     * });
     * ```
     */ get size() {
        return this._size;
    }
    /**
     * The time this query snapshot was obtained.
     *
     * @type {Timestamp}
     * @name QuerySnapshot#readTime
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then((querySnapshot) => {
     *   let readTime = querySnapshot.readTime;
     *   console.log(`Query results returned at '${readTime.toDate()}'`);
     * });
     * ```
     */ get readTime() {
        return this._readTime;
    }
    /**
     * Returns an array of the documents changes since the last snapshot. If
     * this is the first snapshot, all documents will be in the list as added
     * changes.
     *
     * @return {Array.<DocumentChange>}
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.onSnapshot(querySnapshot => {
     *   let changes = querySnapshot.docChanges();
     *   for (let change of changes) {
     *     console.log(`A document was ${change.type}.`);
     *   }
     * });
     * ```
     */ docChanges() {
        if (this._materializedChanges) {
            return this._materializedChanges;
        }
        this._materializedChanges = this._changes();
        this._changes = null;
        return this._materializedChanges;
    }
    /**
     * Enumerates all of the documents in the QuerySnapshot. This is a convenience
     * method for running the same callback on each {@link QueryDocumentSnapshot}
     * that is returned.
     *
     * @param {function} callback A callback to be called with a
     * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in
     * the snapshot.
     * @param {*=} thisArg The `this` binding for the callback..
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ forEach(callback, thisArg) {
        (0, validate_1.validateFunction)('callback', callback);
        for (const doc of this.docs){
            callback.call(thisArg, doc);
        }
    }
    /**
     * Returns true if the document data in this `QuerySnapshot` is equal to the
     * provided value.
     *
     * @param {*} other The value to compare against.
     * @return {boolean} true if this `QuerySnapshot` is equal to the provided
     * value.
     */ isEqual(other) {
        // Since the read time is different on every query read, we explicitly
        // ignore all metadata in this comparison.
        if (this === other) {
            return true;
        }
        if (!(other instanceof QuerySnapshot)) {
            return false;
        }
        if (this._size !== other._size) {
            return false;
        }
        if (!this._query.isEqual(other._query)) {
            return false;
        }
        if (this._materializedDocs && !this._materializedChanges) {
            // If we have only materialized the documents, we compare them first.
            return (0, util_1.isArrayEqual)(this.docs, other.docs) && (0, util_1.isArrayEqual)(this.docChanges(), other.docChanges());
        }
        // Otherwise, we compare the changes first as we expect there to be fewer.
        return (0, util_1.isArrayEqual)(this.docChanges(), other.docChanges()) && (0, util_1.isArrayEqual)(this.docs, other.docs);
    }
}
exports.QuerySnapshot = QuerySnapshot; //# sourceMappingURL=query-snapshot.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/filter.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2023 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CompositeFilter = exports.UnaryFilter = exports.Filter = void 0;
/**
 * A `Filter` represents a restriction on one or more field values and can
 * be used to refine the results of a {@link Query}.
 * `Filters`s are created by invoking {@link Filter#where}, {@link Filter#or},
 * or {@link Filter#and} and can then be passed to {@link Query#where}
 * to create a new {@link Query} instance that also contains this `Filter`.
 */ class Filter {
    /**
     * Creates and returns a new [Filter]{@link Filter}, which can be
     * applied to [Query.where()]{@link Query#where}, [Filter.or()]{@link Filter#or},
     * or [Filter.and()]{@link Filter#and}. When applied to a [Query]{@link Query}
     * it requires that documents must contain the specified field and that its value should
     * satisfy the relation constraint provided.
     *
     * @param {string|FieldPath} fieldPath The name of a property value to compare.
     * @param {string} opStr A comparison operation in the form of a string.
     * Acceptable operator strings are "<", "<=", "==", "!=", ">=", ">", "array-contains",
     * "in", "not-in", and "array-contains-any".
     * @param {*} value The value to which to compare the field for inclusion in
     * a query.
     * @returns {Filter} The created Filter.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * collectionRef.where(Filter.where('foo', '==', 'bar')).get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ static where(fieldPath, opStr, value) {
        return new UnaryFilter(fieldPath, opStr, value);
    }
    /**
     * Creates and returns a new [Filter]{@link Filter} that is a
     * disjunction of the given {@link Filter}s. A disjunction filter includes
     * a document if it satisfies any of the given {@link Filter}s.
     *
     * The returned Filter can be applied to [Query.where()]{@link Query#where},
     * [Filter.or()]{@link Filter#or}, or [Filter.and()]{@link Filter#and}. When
     * applied to a [Query]{@link Query} it requires that documents must satisfy
     * one of the provided {@link Filter}s.
     *
     * @param {...Filter} filters  Optional. The {@link Filter}s
     * for OR operation. These must be created with calls to {@link Filter#where},
     * {@link Filter#or}, or {@link Filter#and}.
     * @returns {Filter} The created {@link Filter}.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * // doc.foo == 'bar' || doc.baz > 0
     * let orFilter = Filter.or(Filter.where('foo', '==', 'bar'), Filter.where('baz', '>', 0));
     *
     * collectionRef.where(orFilter).get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ static or(...filters) {
        return new CompositeFilter(filters, 'OR');
    }
    /**
     * Creates and returns a new [Filter]{@link Filter} that is a
     * conjunction of the given {@link Filter}s. A conjunction filter includes
     * a document if it satisfies all of the given {@link Filter}s.
     *
     * The returned Filter can be applied to [Query.where()]{@link Query#where},
     * [Filter.or()]{@link Filter#or}, or [Filter.and()]{@link Filter#and}. When
     * applied to a [Query]{@link Query} it requires that documents must satisfy
     * one of the provided {@link Filter}s.
     *
     * @param {...Filter} filters  Optional. The {@link Filter}s
     * for AND operation. These must be created with calls to {@link Filter#where},
     * {@link Filter#or}, or {@link Filter#and}.
     * @returns {Filter} The created {@link Filter}.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * // doc.foo == 'bar' && doc.baz > 0
     * let andFilter = Filter.and(Filter.where('foo', '==', 'bar'), Filter.where('baz', '>', 0));
     *
     * collectionRef.where(andFilter).get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ static and(...filters) {
        return new CompositeFilter(filters, 'AND');
    }
}
exports.Filter = Filter;
/**
 * A `UnaryFilter` represents a restriction on one field value and can
 * be used to refine the results of a {@link Query}.
 * `UnaryFilter`s are created by invoking {@link Filter#where} and can then
 * be passed to {@link Query#where} to create a new {@link Query} instance
 * that also contains this `UnaryFilter`.
 *
 * @private
 * @internal
 */ class UnaryFilter extends Filter {
    /**
     @private
     @internal
     */ constructor(field, operator, value){
        super();
        this.field = field;
        this.operator = operator;
        this.value = value;
    }
    /**
     @private
     @internal
     */ _getField() {
        return this.field;
    }
    /**
     @private
     @internal
     */ _getOperator() {
        return this.operator;
    }
    /**
     @private
     @internal
     */ _getValue() {
        return this.value;
    }
}
exports.UnaryFilter = UnaryFilter;
/**
 * A `CompositeFilter` is used to narrow the set of documents returned
 * by a Firestore query by performing the logical OR or AND of multiple
 * {@link Filters}s. `CompositeFilters`s are created by invoking {@link Filter#or}
 * or {@link Filter#and} and can then be passed to {@link Query#where}
 * to create a new query instance that also contains the `CompositeFilter`.
 *
 * @private
 * @internal
 */ class CompositeFilter extends Filter {
    /**
     @private
     @internal
     */ constructor(filters, operator){
        super();
        this.filters = filters;
        this.operator = operator;
    }
    /**
     @private
     @internal
     */ _getFilters() {
        return this.filters;
    }
    /**
     @private
     @internal
     */ _getOperator() {
        return this.operator;
    }
}
exports.CompositeFilter = CompositeFilter; //# sourceMappingURL=filter.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/helpers.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateQueryOrder = validateQueryOrder;
exports.validateQueryOperator = validateQueryOperator;
exports.validateDocumentReference = validateDocumentReference;
exports.validateQueryValue = validateQueryValue;
exports.coalesce = coalesce;
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const serializer_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/serializer.js [app-client] (ecmascript)");
const document_reference_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/constants.js [app-client] (ecmascript)");
/**
 * Validates the input string as a field order direction.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param op Order direction to validate.
 * @throws when the direction is invalid
 * @return a validated input value, which may be different from the provided
 * value.
 */ function validateQueryOrder(arg, op) {
    // For backwards compatibility, we support both lower and uppercase values.
    op = typeof op === 'string' ? op.toLowerCase() : op;
    (0, validate_1.validateEnumValue)(arg, op, Object.keys(constants_1.directionOperators), {
        optional: true
    });
    return op;
}
/**
 * Validates the input string as a field comparison operator.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param op Field comparison operator to validate.
 * @param fieldValue Value that is used in the filter.
 * @throws when the comparison operation is invalid
 * @return a validated input value, which may be different from the provided
 * value.
 */ function validateQueryOperator(arg, op, fieldValue) {
    // For backwards compatibility, we support both `=` and `==` for "equals".
    if (op === '=') {
        op = '==';
    }
    (0, validate_1.validateEnumValue)(arg, op, Object.keys(constants_1.comparisonOperators));
    if (typeof fieldValue === 'number' && isNaN(fieldValue) && op !== '==' && op !== '!=') {
        throw new Error("Invalid query. You can only perform '==' and '!=' comparisons on NaN.");
    }
    if (fieldValue === null && op !== '==' && op !== '!=') {
        throw new Error("Invalid query. You can only perform '==' and '!=' comparisons on Null.");
    }
    return op;
}
/**
 * Validates that 'value' is a DocumentReference.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The argument to validate.
 * @return the DocumentReference if valid
 */ function validateDocumentReference(arg, value) {
    if (!(value instanceof document_reference_1.DocumentReference)) {
        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'DocumentReference'));
    }
    return value;
}
/**
 * Validates that 'value' can be used as a query value.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The argument to validate.
 * @param allowUndefined Whether to allow nested properties that are `undefined`.
 */ function validateQueryValue(arg, value, allowUndefined) {
    (0, serializer_1.validateUserInput)(arg, value, 'query constraint', {
        allowDeletes: 'none',
        allowTransforms: false,
        allowUndefined
    });
}
/**
 * Returns the first non-undefined value or `undefined` if no such value exists.
 * @private
 * @internal
 */ function coalesce(...values) {
    return values.find((value)=>value !== undefined);
} //# sourceMappingURL=helpers.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/aggregate.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2023 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AggregateField = exports.Aggregate = void 0;
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
/**
 * Concrete implementation of the Aggregate type.
 */ class Aggregate {
    constructor(alias, aggregateType, fieldPath){
        this.alias = alias;
        this.aggregateType = aggregateType;
        this.fieldPath = fieldPath;
    }
    /**
     * Converts this object to the proto representation of an Aggregate.
     * @internal
     */ toProto() {
        const proto = {};
        if (this.aggregateType === 'count') {
            proto.count = {};
        } else if (this.aggregateType === 'sum') {
            assert(this.fieldPath !== undefined, 'Missing field path for sum aggregation.');
            proto.sum = {
                field: {
                    fieldPath: path_1.FieldPath.fromArgument(this.fieldPath).formattedName
                }
            };
        } else if (this.aggregateType === 'avg') {
            assert(this.fieldPath !== undefined, 'Missing field path for average aggregation.');
            proto.avg = {
                field: {
                    fieldPath: path_1.FieldPath.fromArgument(this.fieldPath).formattedName
                }
            };
        } else {
            throw new Error(`Aggregate type ${this.aggregateType} unimplemented.`);
        }
        proto.alias = this.alias;
        return proto;
    }
}
exports.Aggregate = Aggregate;
/**
 * Represents an aggregation that can be performed by Firestore.
 */ class AggregateField {
    /**
     * Create a new AggregateField<T>
     * @param aggregateType Specifies the type of aggregation operation to perform.
     * @param field Optionally specifies the field that is aggregated.
     * @internal
     */ constructor(aggregateType, field){
        this.aggregateType = aggregateType;
        /** A type string to uniquely identify instances of this class. */ this.type = 'AggregateField';
        this._field = field;
    }
    /**
     * Compares this object with the given object for equality.
     *
     * This object is considered "equal" to the other object if and only if
     * `other` performs the same kind of aggregation on the same field (if any).
     *
     * @param other The object to compare to this object for equality.
     * @return `true` if this object is "equal" to the given object, as
     * defined above, or `false` otherwise.
     */ isEqual(other) {
        return other instanceof AggregateField && this.aggregateType === other.aggregateType && (this._field === undefined && other._field === undefined || this._field !== undefined && other._field !== undefined && path_1.FieldPath.fromArgument(this._field).isEqual(path_1.FieldPath.fromArgument(other._field)));
    }
    /**
     * Create an AggregateField object that can be used to compute the count of
     * documents in the result set of a query.
     */ static count() {
        return new AggregateField('count');
    }
    /**
     * Create an AggregateField object that can be used to compute the average of
     * a specified field over a range of documents in the result set of a query.
     * @param field Specifies the field to average across the result set.
     */ static average(field) {
        return new AggregateField('avg', field);
    }
    /**
     * Create an AggregateField object that can be used to compute the sum of
     * a specified field over a range of documents in the result set of a query.
     * @param field Specifies the field to sum across the result set.
     */ static sum(field) {
        return new AggregateField('sum', field);
    }
}
exports.AggregateField = AggregateField; //# sourceMappingURL=aggregate.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/aggregate-query-snapshot.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AggregateQuerySnapshot = void 0;
const deepEqual = __turbopack_context__.r("[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)");
/**
 * The results of executing an aggregation query.
 */ class AggregateQuerySnapshot {
    /**
     * @internal
     *
     * @param _query The query that was executed to produce this result.
     * @param _readTime The time this snapshot was read.
     * @param _data The results of the aggregations performed over the underlying
     * query.
     */ constructor(_query, _readTime, _data){
        this._query = _query;
        this._readTime = _readTime;
        this._data = _data;
    }
    /** The query that was executed to produce this result. */ get query() {
        return this._query;
    }
    /** The time this snapshot was read. */ get readTime() {
        return this._readTime;
    }
    /**
     * Returns the results of the aggregations performed over the underlying
     * query.
     *
     * The keys of the returned object will be the same as those of the
     * `AggregateSpec` object specified to the aggregation method, and the
     * values will be the corresponding aggregation result.
     *
     * @returns The results of the aggregations performed over the underlying
     * query.
     */ data() {
        return this._data;
    }
    /**
     * Compares this object with the given object for equality.
     *
     * Two `AggregateQuerySnapshot` instances are considered "equal" if they
     * have the same data and their underlying queries compare "equal" using
     * `AggregateQuery.isEqual()`.
     *
     * @param other The object to compare to this object for equality.
     * @return `true` if this object is "equal" to the given object, as
     * defined above, or `false` otherwise.
     */ isEqual(other) {
        if (this === other) {
            return true;
        }
        if (!(other instanceof AggregateQuerySnapshot)) {
            return false;
        }
        // Since the read time is different on every read, we explicitly ignore all
        // document metadata in this comparison, just like
        // `DocumentSnapshot.isEqual()` does.
        if (!this.query.isEqual(other.query)) {
            return false;
        }
        return deepEqual(this._data, other._data);
    }
}
exports.AggregateQuerySnapshot = AggregateQuerySnapshot; //# sourceMappingURL=aggregate-query-snapshot.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/aggregate-query.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AggregateQuery = void 0;
const assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
const deepEqual = __turbopack_context__.r("[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)");
const aggregate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/aggregate.js [app-client] (ecmascript)");
const timestamp_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const query_profile_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/query-profile.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
const aggregate_query_snapshot_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/aggregate-query-snapshot.js [app-client] (ecmascript)");
const stream_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
/**
 * A query that calculates aggregations over an underlying query.
 */ class AggregateQuery {
    /**
     * @internal
     * @param _query The query whose aggregations will be calculated by this
     * object.
     * @param _aggregates The aggregations that will be performed by this query.
     */ constructor(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    _query, _aggregates){
        this._query = _query;
        this._aggregates = _aggregates;
        this.clientAliasToServerAliasMap = {};
        this.serverAliasToClientAliasMap = {};
        // Client-side aliases may be too long and exceed the 1500-byte string size limit.
        // Such long strings do not need to be transferred over the wire either.
        // The client maps the user's alias to a short form alias and send that to the server.
        let aggregationNum = 0;
        for(const clientAlias in this._aggregates){
            if (Object.prototype.hasOwnProperty.call(this._aggregates, clientAlias)) {
                const serverAlias = `aggregate_${aggregationNum++}`;
                this.clientAliasToServerAliasMap[clientAlias] = serverAlias;
                this.serverAliasToClientAliasMap[serverAlias] = clientAlias;
            }
        }
    }
    /** The query whose aggregations will be calculated by this object. */ get query() {
        return this._query;
    }
    /**
     * Executes this query.
     *
     * @return A promise that will be resolved with the results of the query.
     */ async get() {
        return this._query._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_AGGREGATION_QUERY_GET, async ()=>{
            const { result } = await this._get();
            return result;
        });
    }
    /**
     * Internal get() method that accepts an optional transaction options and
     * returns a snapshot with transaction and explain metadata.
     *
     * @private
     * @internal
     * @param transactionOrReadTime A transaction ID, options to start a new
     *  transaction, or timestamp to use as read time.
     */ async _get(transactionOrReadTime) {
        const response = await this._getResponse(transactionOrReadTime);
        if (!response.result) {
            throw new Error('No AggregateQuery results');
        }
        return response;
    }
    /**
     * Internal get() method that accepts an optional transaction id, and returns
     * transaction metadata.
     *
     * @private
     * @internal
     * @param transactionOrReadTime A transaction ID, options to start a new
     *  transaction, or timestamp to use as read time.
     */ _getResponse(transactionOrReadTime, explainOptions) {
        // Capture the error stack to preserve stack tracing across async calls.
        const stack = Error().stack;
        return new Promise((resolve, reject)=>{
            const output = {};
            const stream = this._stream(transactionOrReadTime, explainOptions);
            stream.on('error', (err)=>{
                reject((0, util_1.wrapError)(err, stack));
            });
            stream.on('data', (data)=>{
                if (data.transaction) {
                    output.transaction = data.transaction;
                }
                if (data.explainMetrics) {
                    output.explainMetrics = data.explainMetrics;
                }
                if (data.result) {
                    output.result = data.result;
                }
            });
            stream.on('end', ()=>{
                stream.destroy();
                resolve(output);
            });
        });
    }
    /**
     * Internal streaming method that accepts an optional transaction ID.
     *
     * BEWARE: If `transactionOrReadTime` is `ITransactionOptions`, then the first
     * response in the stream will be a transaction response.
     *
     * @private
     * @internal
     * @param transactionOrReadTime A transaction ID, options to start a new
     *  transaction, or timestamp to use as read time.
     * @param explainOptions Options to use for explaining the query (if any).
     * @returns A stream of document results optionally preceded by a transaction response.
     */ _stream(transactionOrReadTime, explainOptions) {
        const tag = (0, util_1.requestTag)();
        const firestore = this._query.firestore;
        const stream = new stream_1.Transform({
            objectMode: true,
            transform: (proto, enc, callback)=>{
                var _a;
                const output = {};
                // Proto comes with zero-length buffer by default
                if ((_a = proto.transaction) === null || _a === void 0 ? void 0 : _a.length) {
                    output.transaction = proto.transaction;
                }
                if (proto.explainMetrics) {
                    output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, firestore._serializer);
                }
                if (proto.result) {
                    const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);
                    const data = this.decodeResult(proto.result);
                    output.result = new aggregate_query_snapshot_1.AggregateQuerySnapshot(this, readTime, data);
                }
                callback(undefined, output);
            }
        });
        firestore.initializeIfNeeded(tag).then(async ()=>{
            // `toProto()` might throw an exception. We rely on the behavior of an
            // async function to convert this exception into the rejected Promise we
            // catch below.
            const request = this.toProto(transactionOrReadTime, explainOptions);
            const backendStream = await firestore.requestStream('runAggregationQuery', /* bidirectional= */ false, request, tag);
            stream.on('close', ()=>{
                backendStream.resume();
                backendStream.end();
            });
            backendStream.on('error', (err)=>{
                // TODO(group-by) When group-by queries are supported for aggregates
                // consider implementing retries if the stream is making progress
                // receiving results for groups. See the use of lastReceivedDocument
                // in the retry strategy for runQuery.
                // Also note that explain queries should not be retried.
                backendStream.unpipe(stream);
                (0, logger_1.logger)('AggregateQuery._stream', tag, 'AggregateQuery failed with stream error:', err);
                this._query._firestore._traceUtil.currentSpan().addEvent(`${trace_util_1.SPAN_NAME_RUN_AGGREGATION_QUERY}: Error.`, {
                    'error.message': err.message
                });
                stream.destroy(err);
            });
            backendStream.resume();
            backendStream.pipe(stream);
        }).catch((e)=>stream.destroy(e));
        return stream;
    }
    /**
     * Internal method to decode values within result.
     * @private
     */ decodeResult(proto) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const data = {};
        const fields = proto.aggregateFields;
        if (fields) {
            const serializer = this._query.firestore._serializer;
            for (const prop of Object.keys(fields)){
                const alias = this.serverAliasToClientAliasMap[prop];
                assert(alias !== null && alias !== undefined, `'${prop}' not present in server-client alias mapping.`);
                if (this._aggregates[alias] === undefined) {
                    throw new Error(`Unexpected alias [${prop}] in result aggregate result`);
                }
                data[alias] = serializer.decodeValue(fields[prop]);
            }
        }
        return data;
    }
    /**
     * Internal method for serializing a query to its RunAggregationQuery proto
     * representation with an optional transaction id.
     *
     * @private
     * @internal
     * @returns Serialized JSON for the query.
     */ toProto(transactionOrReadTime, explainOptions) {
        const queryProto = this._query.toProto();
        const runQueryRequest = {
            parent: queryProto.parent,
            structuredAggregationQuery: {
                structuredQuery: queryProto.structuredQuery,
                aggregations: (0, util_1.mapToArray)(this._aggregates, (aggregate, clientAlias)=>{
                    const serverAlias = this.clientAliasToServerAliasMap[clientAlias];
                    assert(serverAlias !== null && serverAlias !== undefined, `'${clientAlias}' not present in client-server alias mapping.`);
                    return new aggregate_1.Aggregate(serverAlias, aggregate.aggregateType, aggregate._field).toProto();
                })
            }
        };
        if (transactionOrReadTime instanceof Uint8Array) {
            runQueryRequest.transaction = transactionOrReadTime;
        } else if (transactionOrReadTime instanceof timestamp_1.Timestamp) {
            runQueryRequest.readTime = transactionOrReadTime.toProto().timestampValue;
        } else if (transactionOrReadTime) {
            runQueryRequest.newTransaction = transactionOrReadTime;
        }
        if (explainOptions) {
            runQueryRequest.explainOptions = explainOptions;
        }
        return runQueryRequest;
    }
    /**
     * Compares this object with the given object for equality.
     *
     * This object is considered "equal" to the other object if and only if
     * `other` performs the same aggregations as this `AggregateQuery` and
     * the underlying Query of `other` compares equal to that of this object
     * using `Query.isEqual()`.
     *
     * @param other The object to compare to this object for equality.
     * @return `true` if this object is "equal" to the given object, as
     * defined above, or `false` otherwise.
     */ isEqual(other) {
        if (this === other) {
            return true;
        }
        if (!(other instanceof AggregateQuery)) {
            return false;
        }
        if (!this.query.isEqual(other.query)) {
            return false;
        }
        return deepEqual(this._aggregates, other._aggregates);
    }
    /**
     * Plans and optionally executes this query. Returns a Promise that will be
     * resolved with the planner information, statistics from the query
     * execution (if any), and the query results (if any).
     *
     * @return A Promise that will be resolved with the planner information,
     * statistics from the query execution (if any), and the query results (if any).
     */ async explain(options) {
        const { result, explainMetrics } = await this._getResponse(undefined, options || {});
        if (!explainMetrics) {
            throw new Error('No explain results');
        }
        return new query_profile_1.ExplainResults(explainMetrics, result || null);
    }
}
exports.AggregateQuery = AggregateQuery; //# sourceMappingURL=aggregate-query.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/watch.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryWatch = exports.DocumentWatch = exports.WATCH_IDLE_TIMEOUT_MS = void 0;
const assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
const rbtree = __turbopack_context__.r("[project]/node_modules/functional-red-black-tree/rbtree.js [app-client] (ecmascript)");
const google_gax_1 = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)");
const backoff_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/backoff.js [app-client] (ecmascript)");
const document_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document.js [app-client] (ecmascript)");
const document_change_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document-change.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const timestamp_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/types.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
/*!
 * Target ID used by watch. Watch uses a fixed target id since we only support
 * one target per stream.
 * @type {number}
 */ const WATCH_TARGET_ID = 0x1;
/*!
 * Idle timeout used to detect Watch streams that stall (see
 * https://github.com/googleapis/nodejs-firestore/issues/1057, b/156308554).
 * Under normal load, the Watch backend will send a TARGET_CHANGE message
 * roughly every 30 seconds. As discussed with the backend team, we reset the
 * Watch stream if we do not receive any message within 120 seconds.
 */ exports.WATCH_IDLE_TIMEOUT_MS = 120 * 1000;
/*!
 * Sentinel value for a document remove.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const REMOVED = {};
/*!
 * The change type for document change events.
 */ // tslint:disable-next-line:variable-name
const ChangeType = {
    added: 'added',
    modified: 'modified',
    removed: 'removed'
};
/*!
 * The comparator used for document watches (which should always get called with
 * the same document).
 */ const DOCUMENT_WATCH_COMPARATOR = (doc1, doc2)=>{
    assert(doc1 === doc2, 'Document watches only support one document.');
    return 0;
};
const EMPTY_FUNCTION = ()=>{};
/**
 * Watch provides listen functionality and exposes the 'onSnapshot' observer. It
 * can be used with a valid Firestore Listen target.
 *
 * @class
 * @private
 * @internal
 */ class Watch {
    /**
     * @private
     * @internal
     *
     * @param firestore The Firestore Database client.
     */ constructor(firestore, _converter = (0, types_1.defaultConverter)()){
        this._converter = _converter;
        /**
         * Indicates whether we are interested in data from the stream. Set to false in the
         * 'unsubscribe()' callback.
         * @private
         * @internal
         */ this.isActive = true;
        /**
         * The current stream to the backend.
         * @private
         * @internal
         */ this.currentStream = null;
        /**
         * The server assigns and updates the resume token.
         * @private
         * @internal
         */ this.resumeToken = undefined;
        /**
         * A map of document names to QueryDocumentSnapshots for the last sent snapshot.
         * @private
         * @internal
         */ this.docMap = new Map();
        /**
         * The accumulated map of document changes (keyed by document name) for the
         * current snapshot.
         * @private
         * @internal
         */ this.changeMap = new Map();
        /**
         * The current state of the query results. *
         * @private
         * @internal
         */ this.current = false;
        /**
         * We need this to track whether we've pushed an initial set of changes,
         * since we should push those even when there are no changes, if there
         * aren't docs.
         * @private
         * @internal
         */ this.hasPushed = false;
        this.firestore = firestore;
        this.backoff = new backoff_1.ExponentialBackoff();
        this.requestTag = (0, util_1.requestTag)();
        this.onNext = EMPTY_FUNCTION;
        this.onError = EMPTY_FUNCTION;
    }
    /**
     * Starts a watch and attaches a listener for document change events.
     *
     * @private
     * @internal
     * @param onNext A callback to be called every time a new snapshot is
     * available.
     * @param onError A callback to be called if the listen fails or is cancelled.
     * No further callbacks will occur.
     *
     * @returns An unsubscribe function that can be called to cancel the snapshot
     * listener.
     */ onSnapshot(onNext, onError) {
        assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');
        assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');
        assert(this.docTree === undefined, 'docTree should not already be defined.');
        this.onNext = onNext;
        this.onError = onError;
        this.docTree = rbtree(this.getComparator());
        this.initStream();
        const unsubscribe = ()=>{
            (0, logger_1.logger)('Watch.onSnapshot', this.requestTag, 'Unsubscribe called');
            // Prevent further callbacks.
            this.onNext = ()=>{};
            this.onError = ()=>{};
            this.shutdown();
        };
        this.firestore.registerListener();
        return unsubscribe;
    }
    /**
     * Returns the current count of all documents, including the changes from
     * the current changeMap.
     * @private
     * @internal
     */ currentSize() {
        const changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());
        return this.docMap.size + changes.adds.length - changes.deletes.length;
    }
    /**
     * Splits up document changes into removals, additions, and updates.
     * @private
     * @internal
     */ extractCurrentChanges(readTime) {
        const deletes = [];
        const adds = [];
        const updates = [];
        this.changeMap.forEach((value, name)=>{
            if (value === REMOVED) {
                if (this.docMap.has(name)) {
                    deletes.push(name);
                }
            } else if (this.docMap.has(name)) {
                value.readTime = readTime;
                updates.push(value.build());
            } else {
                value.readTime = readTime;
                adds.push(value.build());
            }
        });
        return {
            deletes,
            adds,
            updates
        };
    }
    /**
     * Helper to clear the docs on RESET or filter mismatch.
     * @private
     * @internal
     */ resetDocs() {
        (0, logger_1.logger)('Watch.resetDocs', this.requestTag, 'Resetting documents');
        this.changeMap.clear();
        this.resumeToken = undefined;
        this.docTree.forEach((snapshot)=>{
            // Mark each document as deleted. If documents are not deleted, they
            // will be send again by the server.
            this.changeMap.set(snapshot.ref.path, REMOVED);
        });
        this.current = false;
    }
    /**
     * Closes the stream and calls onError() if the stream is still active.
     * @private
     * @internal
     */ closeStream(err) {
        if (this.isActive) {
            (0, logger_1.logger)('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);
            this.onError(err);
        }
        this.shutdown();
    }
    /**
     * Re-opens the stream unless the specified error is considered permanent.
     * Clears the change map.
     * @private
     * @internal
     */ maybeReopenStream(err) {
        if (this.isActive && !this.isPermanentWatchError(err)) {
            (0, logger_1.logger)('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error:', err);
            this.changeMap.clear();
            if (this.isResourceExhaustedError(err)) {
                this.backoff.resetToMax();
            }
            this.initStream();
        } else {
            this.closeStream(err);
        }
    }
    /**
     * Cancels the current idle timeout and reschedules a new timer.
     *
     * @private
     * @internal
     */ resetIdleTimeout() {
        if (this.idleTimeoutHandle) {
            clearTimeout(this.idleTimeoutHandle);
        }
        this.idleTimeoutHandle = (0, backoff_1.delayExecution)(()=>{
            var _a;
            (0, logger_1.logger)('Watch.resetIdleTimeout', this.requestTag, 'Resetting stream after idle timeout');
            (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();
            this.currentStream = null;
            const error = new google_gax_1.GoogleError('Watch stream idle timeout');
            error.code = google_gax_1.Status.UNKNOWN;
            this.maybeReopenStream(error);
        }, exports.WATCH_IDLE_TIMEOUT_MS);
    }
    /**
     * Helper to restart the outgoing stream to the backend.
     * @private
     * @internal
     */ resetStream() {
        (0, logger_1.logger)('Watch.resetStream', this.requestTag, 'Restarting stream');
        if (this.currentStream) {
            this.currentStream.end();
            this.currentStream = null;
        }
        this.initStream();
    }
    /**
     * Initializes a new stream to the backend with backoff.
     * @private
     * @internal
     */ initStream() {
        this.backoff.backoffAndWait().then(async ()=>{
            if (!this.isActive) {
                (0, logger_1.logger)('Watch.initStream', this.requestTag, 'Not initializing inactive stream');
                return;
            }
            await this.firestore.initializeIfNeeded(this.requestTag);
            const request = {};
            request.database = this.firestore.formattedName;
            request.addTarget = this.getTarget(this.resumeToken);
            // Note that we need to call the internal _listen API to pass additional
            // header values in readWriteStream.
            return this.firestore.requestStream('listen', /* bidirectional= */ true, request, this.requestTag).then((backendStream)=>{
                if (!this.isActive) {
                    (0, logger_1.logger)('Watch.initStream', this.requestTag, 'Closing inactive stream');
                    backendStream.emit('end');
                    backendStream.on('error', ()=>{
                    // Note that emitting 'end' above does not prevent the Duplex
                    // from receiving potential errors from the backend. Since the
                    // stream is no longer active (`isActive` is false), we
                    // swallow / ignore any errors it may receive.
                    });
                    return;
                }
                (0, logger_1.logger)('Watch.initStream', this.requestTag, 'Opened new stream');
                this.currentStream = backendStream;
                this.resetIdleTimeout();
                this.currentStream.on('data', (proto)=>{
                    this.resetIdleTimeout();
                    this.onData(proto);
                }).on('error', (err)=>{
                    if (this.currentStream === backendStream) {
                        this.currentStream = null;
                        this.maybeReopenStream(err);
                    }
                }).on('end', ()=>{
                    if (this.currentStream === backendStream) {
                        this.currentStream = null;
                        const err = new google_gax_1.GoogleError('Stream ended unexpectedly');
                        err.code = google_gax_1.Status.UNKNOWN;
                        this.maybeReopenStream(err);
                    }
                });
                this.currentStream.resume();
            });
        }).catch((err)=>{
            this.closeStream(err);
        });
    }
    /**
     * Handles 'data' events and closes the stream if the response type is
     * invalid.
     * @private
     * @internal
     */ onData(proto) {
        if (proto.targetChange) {
            (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing target change');
            const change = proto.targetChange;
            const noTargetIds = !change.targetIds || change.targetIds.length === 0;
            if (change.targetChangeType === 'NO_CHANGE') {
                if (noTargetIds && change.readTime && this.current) {
                    // This means everything is up-to-date, so emit the current
                    // set of docs as a snapshot, if there were changes.
                    this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);
                }
            } else if (change.targetChangeType === 'ADD') {
                if (WATCH_TARGET_ID !== change.targetIds[0]) {
                    this.closeStream(Error('Unexpected target ID sent by server'));
                }
            } else if (change.targetChangeType === 'REMOVE') {
                let code = google_gax_1.Status.INTERNAL;
                let message = 'internal error';
                if (change.cause) {
                    code = change.cause.code;
                    message = change.cause.message;
                }
                // @todo: Surface a .code property on the exception.
                this.closeStream(new Error('Error ' + code + ': ' + message));
            } else if (change.targetChangeType === 'RESET') {
                // Whatever changes have happened so far no longer matter.
                this.resetDocs();
            } else if (change.targetChangeType === 'CURRENT') {
                this.current = true;
            } else {
                this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));
            }
            if (change.resumeToken && this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {
                this.backoff.reset();
            }
        } else if (proto.documentChange) {
            (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing change event');
            // No other targetIds can show up here, but we still need to see
            // if the targetId was in the added list or removed list.
            const targetIds = proto.documentChange.targetIds || [];
            const removedTargetIds = proto.documentChange.removedTargetIds || [];
            let changed = false;
            let removed = false;
            for(let i = 0; i < targetIds.length; i++){
                if (targetIds[i] === WATCH_TARGET_ID) {
                    changed = true;
                }
            }
            for(let i = 0; i < removedTargetIds.length; i++){
                if (removedTargetIds[i] === WATCH_TARGET_ID) {
                    removed = true;
                }
            }
            const document = proto.documentChange.document;
            const name = document.name;
            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;
            if (changed) {
                (0, logger_1.logger)('Watch.onData', this.requestTag, 'Received document change');
                const ref = this.firestore.doc(relativeName);
                const snapshot = new document_1.DocumentSnapshotBuilder(ref.withConverter(this._converter));
                snapshot.fieldsProto = document.fields || {};
                snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);
                snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);
                this.changeMap.set(relativeName, snapshot);
            } else if (removed) {
                (0, logger_1.logger)('Watch.onData', this.requestTag, 'Received document remove');
                this.changeMap.set(relativeName, REMOVED);
            }
        } else if (proto.documentDelete || proto.documentRemove) {
            (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing remove event');
            const name = (proto.documentDelete || proto.documentRemove).document;
            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;
            this.changeMap.set(relativeName, REMOVED);
        } else if (proto.filter) {
            (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing filter update');
            if (proto.filter.count !== this.currentSize()) {
                // We need to remove all the current results.
                this.resetDocs();
                // The filter didn't match, so re-issue the query.
                this.resetStream();
            }
        } else {
            this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));
        }
    }
    /**
     * Checks if the current target id is included in the list of target ids.
     * If no targetIds are provided, returns true.
     * @private
     * @internal
     */ affectsTarget(targetIds, currentId) {
        if (targetIds === undefined || targetIds.length === 0) {
            return true;
        }
        for (const targetId of targetIds){
            if (targetId === currentId) {
                return true;
            }
        }
        return false;
    }
    /**
     * Assembles a new snapshot from the current set of changes and invokes the
     * user's callback. Clears the current changes on completion.
     * @private
     * @internal
     */ pushSnapshot(readTime, nextResumeToken) {
        const appliedChanges = this.computeSnapshot(readTime);
        if (!this.hasPushed || appliedChanges.length > 0) {
            (0, logger_1.logger)('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length);
            // We pass the current set of changes, even if `docTree` is modified later.
            const currentTree = this.docTree;
            this.onNext(readTime, currentTree.length, ()=>currentTree.keys, ()=>appliedChanges);
            this.hasPushed = true;
        }
        this.changeMap.clear();
        this.resumeToken = nextResumeToken;
    }
    /**
     * Applies a document delete to the document tree and the document map.
     * Returns the corresponding DocumentChange event.
     * @private
     * @internal
     */ deleteDoc(name) {
        assert(this.docMap.has(name), 'Document to delete does not exist');
        const oldDocument = this.docMap.get(name);
        const existing = this.docTree.find(oldDocument);
        const oldIndex = existing.index;
        this.docTree = existing.remove();
        this.docMap.delete(name);
        return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);
    }
    /**
     * Applies a document add to the document tree and the document map. Returns
     * the corresponding DocumentChange event.
     * @private
     * @internal
     */ addDoc(newDocument) {
        const name = newDocument.ref.path;
        assert(!this.docMap.has(name), 'Document to add already exists');
        this.docTree = this.docTree.insert(newDocument, null);
        const newIndex = this.docTree.find(newDocument).index;
        this.docMap.set(name, newDocument);
        return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);
    }
    /**
     * Applies a document modification to the document tree and the document map.
     * Returns the DocumentChange event for successful modifications.
     * @private
     * @internal
     */ modifyDoc(newDocument) {
        const name = newDocument.ref.path;
        assert(this.docMap.has(name), 'Document to modify does not exist');
        const oldDocument = this.docMap.get(name);
        if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {
            const removeChange = this.deleteDoc(name);
            const addChange = this.addDoc(newDocument);
            return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);
        }
        return null;
    }
    /**
     * Applies the mutations in changeMap to both the document tree and the
     * document lookup map. Modified docMap in-place and returns the updated
     * state.
     * @private
     * @internal
     */ computeSnapshot(readTime) {
        const changeSet = this.extractCurrentChanges(readTime);
        const appliedChanges = [];
        // Process the sorted changes in the order that is expected by our clients
        // (removals, additions, and then modifications). We also need to sort the
        // individual changes to assure that oldIndex/newIndex keep incrementing.
        changeSet.deletes.sort((name1, name2)=>{
            // Deletes are sorted based on the order of the existing document.
            return this.getComparator()(this.docMap.get(name1), this.docMap.get(name2));
        });
        changeSet.deletes.forEach((name)=>{
            const change = this.deleteDoc(name);
            appliedChanges.push(change);
        });
        changeSet.adds.sort(this.getComparator());
        changeSet.adds.forEach((snapshot)=>{
            const change = this.addDoc(snapshot);
            appliedChanges.push(change);
        });
        changeSet.updates.sort(this.getComparator());
        changeSet.updates.forEach((snapshot)=>{
            const change = this.modifyDoc(snapshot);
            if (change) {
                appliedChanges.push(change);
            }
        });
        assert(this.docTree.length === this.docMap.size, 'The update document ' + 'tree and document map should have the same number of entries.');
        return appliedChanges;
    }
    /**
     * Determines whether a watch error is considered permanent and should not be
     * retried. Errors that don't provide a GRPC error code are always considered
     * transient in this context.
     *
     * @private
     * @internal
     * @param error An error object.
     * @return Whether the error is permanent.
     */ isPermanentWatchError(error) {
        if (error.code === undefined) {
            (0, logger_1.logger)('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);
            return false;
        }
        switch(error.code){
            case google_gax_1.Status.ABORTED:
            case google_gax_1.Status.CANCELLED:
            case google_gax_1.Status.UNKNOWN:
            case google_gax_1.Status.DEADLINE_EXCEEDED:
            case google_gax_1.Status.RESOURCE_EXHAUSTED:
            case google_gax_1.Status.INTERNAL:
            case google_gax_1.Status.UNAVAILABLE:
            case google_gax_1.Status.UNAUTHENTICATED:
                return false;
            default:
                return true;
        }
    }
    /**
     * Determines whether we need to initiate a longer backoff due to system
     * overload.
     *
     * @private
     * @internal
     * @param error A GRPC Error object that exposes an error code.
     * @return Whether we need to back off our retries.
     */ isResourceExhaustedError(error) {
        return error.code === google_gax_1.Status.RESOURCE_EXHAUSTED;
    }
    /** Closes the stream and clears all timeouts. */ shutdown() {
        var _a;
        if (this.isActive) {
            this.isActive = false;
            if (this.idleTimeoutHandle) {
                clearTimeout(this.idleTimeoutHandle);
                this.idleTimeoutHandle = undefined;
            }
            this.firestore.unregisterListener();
        }
        (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();
        this.currentStream = null;
    }
}
/**
 * Creates a new Watch instance to listen on DocumentReferences.
 *
 * @private
 * @internal
 */ class DocumentWatch extends Watch {
    constructor(firestore, ref){
        super(firestore, ref._converter);
        this.ref = ref;
    }
    getComparator() {
        return DOCUMENT_WATCH_COMPARATOR;
    }
    getTarget(resumeToken) {
        const formattedName = this.ref.formattedName;
        return {
            documents: {
                documents: [
                    formattedName
                ]
            },
            targetId: WATCH_TARGET_ID,
            resumeToken
        };
    }
}
exports.DocumentWatch = DocumentWatch;
/**
 * Creates a new Watch instance to listen on Queries.
 *
 * @private
 * @internal
 */ class QueryWatch extends Watch {
    constructor(firestore, query, converter){
        super(firestore, converter);
        this.query = query;
        this.comparator = query.comparator();
    }
    getComparator() {
        return this.query.comparator();
    }
    getTarget(resumeToken) {
        const query = this.query.toProto();
        return {
            query,
            targetId: WATCH_TARGET_ID,
            resumeToken
        };
    }
}
exports.QueryWatch = QueryWatch; //# sourceMappingURL=watch.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/query.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Query = void 0;
const stream_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
const query_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query-util.js [app-client] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/index.js [app-client] (ecmascript)");
const field_order_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/field-order.js [app-client] (ecmascript)");
const field_filter_internal_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/field-filter-internal.js [app-client] (ecmascript)");
const composite_filter_internal_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/composite-filter-internal.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/constants.js [app-client] (ecmascript)");
const document_reference_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js [app-client] (ecmascript)");
const query_snapshot_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query-snapshot.js [app-client] (ecmascript)");
const serializer_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/serializer.js [app-client] (ecmascript)");
const query_profile_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/query-profile.js [app-client] (ecmascript)");
const filter_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/filter.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const helpers_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/helpers.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/types.js [app-client] (ecmascript)");
const aggregate_query_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/aggregate-query.js [app-client] (ecmascript)");
const vector_query_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/vector-query.js [app-client] (ecmascript)");
const order_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/order.js [app-client] (ecmascript)");
const types_2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/types.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
/**
 * A Query refers to a query which you can read or stream from. You can also
 * construct refined Query objects by adding filters and ordering.
 *
 * @class Query
 */ class Query {
    /**
     * @internal
     * @private
     *
     * @param _firestore The Firestore Database client.
     * @param _queryOptions Options that define the query.
     */ constructor(/**
     * @internal
     * @private
     **/ _firestore, /**
     * @internal
     * @private
     **/ _queryOptions){
        this._firestore = _firestore;
        this._queryOptions = _queryOptions;
        this._serializer = new serializer_1.Serializer(_firestore);
        this._allowUndefined = !!this._firestore._settings.ignoreUndefinedProperties;
        this._queryUtil = new query_util_1.QueryUtil(_firestore, _queryOptions, this._serializer);
    }
    /**
     * Extracts field values from the DocumentSnapshot based on the provided
     * field order.
     *
     * @private
     * @internal
     * @param documentSnapshot The document to extract the fields from.
     * @param fieldOrders The field order that defines what fields we should
     * extract.
     * @return {Array.<*>} The field values to use.
     */ static _extractFieldValues(documentSnapshot, fieldOrders) {
        const fieldValues = [];
        for (const fieldOrder of fieldOrders){
            if (index_1.FieldPath.documentId().isEqual(fieldOrder.field)) {
                fieldValues.push(documentSnapshot.ref);
            } else {
                const fieldValue = documentSnapshot.get(fieldOrder.field);
                if (fieldValue === undefined) {
                    throw new Error(`Field "${fieldOrder.field}" is missing in the provided DocumentSnapshot. ` + 'Please provide a document that contains values for all specified ' + 'orderBy() and where() constraints.');
                } else {
                    fieldValues.push(fieldValue);
                }
            }
        }
        return fieldValues;
    }
    /**
     * The [Firestore]{@link Firestore} instance for the Firestore
     * database (useful for performing transactions, etc.).
     *
     * @type {Firestore}
     * @name Query#firestore
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * collectionRef.add({foo: 'bar'}).then(documentReference => {
     *   let firestore = documentReference.firestore;
     *   console.log(`Root location for document is ${firestore.formattedName}`);
     * });
     * ```
     */ get firestore() {
        return this._firestore;
    }
    where(fieldPathOrFilter, opStr, value) {
        let filter;
        if (fieldPathOrFilter instanceof index_1.Filter) {
            filter = fieldPathOrFilter;
        } else {
            filter = index_1.Filter.where(fieldPathOrFilter, opStr, value);
        }
        if (this._queryOptions.startAt || this._queryOptions.endAt) {
            throw new Error('Cannot specify a where() filter after calling startAt(), ' + 'startAfter(), endBefore() or endAt().');
        }
        const parsedFilter = this._parseFilter(filter);
        if (parsedFilter.getFilters().length === 0) {
            // Return the existing query if not adding any more filters (e.g. an empty composite filter).
            return this;
        }
        const options = this._queryOptions.with({
            filters: this._queryOptions.filters.concat(parsedFilter)
        });
        return new Query(this._firestore, options);
    }
    /**
     * @internal
     * @private
     */ _parseFilter(filter) {
        if (filter instanceof filter_1.UnaryFilter) {
            return this._parseFieldFilter(filter);
        }
        return this._parseCompositeFilter(filter);
    }
    /**
     * @internal
     * @private
     */ _parseFieldFilter(fieldFilterData) {
        let value = fieldFilterData._getValue();
        let operator = fieldFilterData._getOperator();
        const fieldPath = fieldFilterData._getField();
        (0, path_1.validateFieldPath)('fieldPath', fieldPath);
        operator = (0, helpers_1.validateQueryOperator)('opStr', operator, value);
        (0, helpers_1.validateQueryValue)('value', value, this._allowUndefined);
        const path = index_1.FieldPath.fromArgument(fieldPath);
        if (index_1.FieldPath.documentId().isEqual(path)) {
            if (operator === 'array-contains' || operator === 'array-contains-any') {
                throw new Error(`Invalid Query. You can't perform '${operator}' ` + 'queries on FieldPath.documentId().');
            } else if (operator === 'in' || operator === 'not-in') {
                if (!Array.isArray(value) || value.length === 0) {
                    throw new Error(`Invalid Query. A non-empty array is required for '${operator}' filters.`);
                }
                value = value.map((el)=>this.validateReference(el));
            } else {
                value = this.validateReference(value);
            }
        }
        return new field_filter_internal_1.FieldFilterInternal(this._serializer, path, constants_1.comparisonOperators[operator], value);
    }
    /**
     * @internal
     * @private
     */ _parseCompositeFilter(compositeFilterData) {
        const parsedFilters = compositeFilterData._getFilters().map((filter)=>this._parseFilter(filter)).filter((parsedFilter)=>parsedFilter.getFilters().length > 0);
        // For composite filters containing 1 filter, return the only filter.
        // For example: AND(FieldFilter1) == FieldFilter1
        if (parsedFilters.length === 1) {
            return parsedFilters[0];
        }
        return new composite_filter_internal_1.CompositeFilterInternal(parsedFilters, compositeFilterData._getOperator() === 'AND' ? 'AND' : 'OR');
    }
    /**
     * Creates and returns a new [Query]{@link Query} instance that applies a
     * field mask to the result and returns only the specified subset of fields.
     * You can specify a list of field paths to return, or use an empty list to
     * only return the references of matching documents.
     *
     * Queries that contain field masks cannot be listened to via `onSnapshot()`
     * listeners.
     *
     * This function returns a new (immutable) instance of the Query (rather than
     * modify the existing instance) to impose the field mask.
     *
     * @param {...(string|FieldPath)} fieldPaths The field paths to return.
     * @returns {Query} The created Query.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     * let documentRef = collectionRef.doc('doc');
     *
     * return documentRef.set({x:10, y:5}).then(() => {
     *   return collectionRef.where('x', '>', 5).select('y').get();
     * }).then((res) => {
     *   console.log(`y is ${res.docs[0].get('y')}.`);
     * });
     * ```
     */ select(...fieldPaths) {
        const fields = [];
        if (fieldPaths.length === 0) {
            fields.push({
                fieldPath: index_1.FieldPath.documentId().formattedName
            });
        } else {
            for(let i = 0; i < fieldPaths.length; ++i){
                (0, path_1.validateFieldPath)(i, fieldPaths[i]);
                fields.push({
                    fieldPath: index_1.FieldPath.fromArgument(fieldPaths[i]).formattedName
                });
            }
        }
        // By specifying a field mask, the query result no longer conforms to type
        // `T`. We there return `Query<DocumentData>`;
        const options = this._queryOptions.with({
            projection: {
                fields
            }
        });
        return new Query(this._firestore, options);
    }
    /**
     * Creates and returns a new [Query]{@link Query} that's additionally sorted
     * by the specified field, optionally in descending order instead of
     * ascending.
     *
     * This function returns a new (immutable) instance of the Query (rather than
     * modify the existing instance) to impose the field mask.
     *
     * @param {string|FieldPath} fieldPath The field to sort by.
     * @param {string=} directionStr Optional direction to sort by ('asc' or
     * 'desc'). If not specified, order will be ascending.
     * @returns {Query} The created Query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '>', 42);
     *
     * query.orderBy('foo', 'desc').get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ orderBy(fieldPath, directionStr) {
        (0, path_1.validateFieldPath)('fieldPath', fieldPath);
        directionStr = (0, helpers_1.validateQueryOrder)('directionStr', directionStr);
        if (this._queryOptions.startAt || this._queryOptions.endAt) {
            throw new Error('Cannot specify an orderBy() constraint after calling ' + 'startAt(), startAfter(), endBefore() or endAt().');
        }
        const newOrder = new field_order_1.FieldOrder(index_1.FieldPath.fromArgument(fieldPath), constants_1.directionOperators[directionStr || 'asc']);
        const options = this._queryOptions.with({
            fieldOrders: this._queryOptions.fieldOrders.concat(newOrder)
        });
        return new Query(this._firestore, options);
    }
    /**
     * Creates and returns a new [Query]{@link Query} that only returns the
     * first matching documents.
     *
     * This function returns a new (immutable) instance of the Query (rather than
     * modify the existing instance) to impose the limit.
     *
     * @param {number} limit The maximum number of items to return.
     * @returns {Query} The created Query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '>', 42);
     *
     * query.limit(1).get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ limit(limit) {
        (0, validate_1.validateInteger)('limit', limit);
        const options = this._queryOptions.with({
            limit,
            limitType: types_1.LimitType.First
        });
        return new Query(this._firestore, options);
    }
    /**
     * Creates and returns a new [Query]{@link Query} that only returns the
     * last matching documents.
     *
     * You must specify at least one orderBy clause for limitToLast queries,
     * otherwise an exception will be thrown during execution.
     *
     * Results for limitToLast queries cannot be streamed via the `stream()` API.
     *
     * @param limit The maximum number of items to return.
     * @return The created Query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '>', 42);
     *
     * query.limitToLast(1).get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Last matching document is ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ limitToLast(limit) {
        (0, validate_1.validateInteger)('limitToLast', limit);
        const options = this._queryOptions.with({
            limit,
            limitType: types_1.LimitType.Last
        });
        return new Query(this._firestore, options);
    }
    /**
     * Specifies the offset of the returned results.
     *
     * This function returns a new (immutable) instance of the
     * [Query]{@link Query} (rather than modify the existing instance)
     * to impose the offset.
     *
     * @param {number} offset The offset to apply to the Query results
     * @returns {Query} The created Query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '>', 42);
     *
     * query.limit(10).offset(20).get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ offset(offset) {
        (0, validate_1.validateInteger)('offset', offset);
        const options = this._queryOptions.with({
            offset
        });
        return new Query(this._firestore, options);
    }
    /**
     * Returns a query that counts the documents in the result set of this
     * query.
     *
     * The returned query, when executed, counts the documents in the result set
     * of this query without actually downloading the documents.
     *
     * Using the returned query to count the documents is efficient because only
     * the final count, not the documents' data, is downloaded. The returned
     * query can count the documents in cases where the result set is
     * prohibitively large to download entirely (thousands of documents).
     *
     * @return a query that counts the documents in the result set of this
     * query. The count can be retrieved from `snapshot.data().count`, where
     * `snapshot` is the `AggregateQuerySnapshot` resulting from running the
     * returned query.
     */ count() {
        return this.aggregate({
            count: index_1.AggregateField.count()
        });
    }
    /**
     * Returns a query that can perform the given aggregations.
     *
     * The returned query, when executed, calculates the specified aggregations
     * over the documents in the result set of this query without actually
     * downloading the documents.
     *
     * Using the returned query to perform aggregations is efficient because only
     * the final aggregation values, not the documents' data, is downloaded. The
     * returned query can perform aggregations of the documents count the
     * documents in cases where the result set is prohibitively large to download
     * entirely (thousands of documents).
     *
     * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates
     * to perform over the result set. The AggregateSpec specifies aliases for each
     * aggregate, which can be used to retrieve the aggregate result.
     * @example
     * ```typescript
     * const aggregateQuery = col.aggregate(query, {
     *   countOfDocs: count(),
     *   totalHours: sum('hours'),
     *   averageScore: average('score')
     * });
     *
     * const aggregateSnapshot = await aggregateQuery.get();
     * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;
     * const totalHours: number = aggregateSnapshot.data().totalHours;
     * const averageScore: number | null = aggregateSnapshot.data().averageScore;
     * ```
     */ aggregate(aggregateSpec) {
        return new aggregate_query_1.AggregateQuery(this, aggregateSpec);
    }
    findNearest(vectorFieldOrOptions, queryVector, options) {
        if (typeof vectorFieldOrOptions === 'string' || vectorFieldOrOptions instanceof index_1.FieldPath) {
            const vqOptions = {
                distanceMeasure: options.distanceMeasure,
                limit: options.limit,
                queryVector: queryVector,
                vectorField: vectorFieldOrOptions
            };
            return this._findNearest(vqOptions);
        } else {
            return this._findNearest(vectorFieldOrOptions);
        }
    }
    _findNearest(options) {
        (0, path_1.validateFieldPath)('vectorField', options.vectorField);
        if (options.limit <= 0) {
            throw (0, validate_1.invalidArgumentMessage)('limit', 'positive limit number');
        }
        if ((Array.isArray(options.queryVector) ? options.queryVector.length : options.queryVector.toArray().length) === 0) {
            throw (0, validate_1.invalidArgumentMessage)('queryVector', 'vector size must be larger than 0');
        }
        return new vector_query_1.VectorQuery(this, options);
    }
    /**
     * Returns true if this `Query` is equal to the provided value.
     *
     * @param {*} other The value to compare against.
     * @return {boolean} true if this `Query` is equal to the provided value.
     */ isEqual(other) {
        if (this === other) {
            return true;
        }
        return other instanceof Query && this._queryOptions.isEqual(other._queryOptions);
    }
    /**
     * Returns the sorted array of inequality filter fields used in this query.
     *
     * @return An array of inequality filter fields sorted lexicographically by FieldPath.
     */ getInequalityFilterFields() {
        const inequalityFields = [];
        for (const filter of this._queryOptions.filters){
            for (const subFilter of filter.getFlattenedFilters()){
                if (subFilter.isInequalityFilter()) {
                    inequalityFields.push(subFilter.field);
                }
            }
        }
        return inequalityFields.sort((a, b)=>a.compareTo(b));
    }
    /**
     * Computes the backend ordering semantics for DocumentSnapshot cursors.
     *
     * @private
     * @internal
     * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the
     * set of field values to use as the boundary.
     * @returns The implicit ordering semantics.
     */ createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {
        // Add an implicit orderBy if the only cursor value is a DocumentSnapshot.
        if (cursorValuesOrDocumentSnapshot.length !== 1 || !(cursorValuesOrDocumentSnapshot[0] instanceof index_1.DocumentSnapshot)) {
            return this._queryOptions.fieldOrders;
        }
        const fieldOrders = this._queryOptions.fieldOrders.slice();
        const fieldsNormalized = new Set([
            ...fieldOrders.map((item)=>item.field.toString())
        ]);
        /** The order of the implicit ordering always matches the last explicit order by. */ const lastDirection = fieldOrders.length === 0 ? constants_1.directionOperators.ASC : fieldOrders[fieldOrders.length - 1].direction;
        /**
         * Any inequality fields not explicitly ordered should be implicitly ordered in a
         * lexicographical order. When there are multiple inequality filters on the same field, the
         * field should be added only once.
         * Note: getInequalityFilterFields function sorts the key field before
         * other fields. However, we want the key field to be sorted last.
         */ const inequalityFields = this.getInequalityFilterFields();
        for (const field of inequalityFields){
            if (!fieldsNormalized.has(field.toString()) && !field.isEqual(index_1.FieldPath.documentId())) {
                fieldOrders.push(new field_order_1.FieldOrder(field, lastDirection));
                fieldsNormalized.add(field.toString());
            }
        }
        // Add the document key field to the last if it is not explicitly ordered.
        if (!fieldsNormalized.has(index_1.FieldPath.documentId().toString())) {
            fieldOrders.push(new field_order_1.FieldOrder(index_1.FieldPath.documentId(), lastDirection));
        }
        return fieldOrders;
    }
    /**
     * Builds a Firestore 'Position' proto message.
     *
     * @private
     * @internal
     * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this
     * cursor.
     * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The
     * snapshot of the document or the set of field values to use as the boundary.
     * @param before Whether the query boundary lies just before or after the
     * provided data.
     * @returns {Object} The proto message.
     */ createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {
        let fieldValues;
        if (cursorValuesOrDocumentSnapshot.length === 1 && cursorValuesOrDocumentSnapshot[0] instanceof index_1.DocumentSnapshot) {
            fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);
        } else {
            fieldValues = cursorValuesOrDocumentSnapshot;
        }
        if (fieldValues.length > fieldOrders.length) {
            throw new Error('Too many cursor values specified. The specified ' + 'values must match the orderBy() constraints of the query.');
        }
        const options = {
            values: [],
            before
        };
        for(let i = 0; i < fieldValues.length; ++i){
            let fieldValue = fieldValues[i];
            if (index_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {
                fieldValue = this.validateReference(fieldValue);
            }
            (0, helpers_1.validateQueryValue)(i, fieldValue, this._allowUndefined);
            options.values.push(this._serializer.encodeValue(fieldValue));
        }
        return options;
    }
    /**
     * Validates that a value used with FieldValue.documentId() is either a
     * string or a DocumentReference that is part of the query`s result set.
     * Throws a validation error or returns a DocumentReference that can
     * directly be used in the Query.
     *
     * @param val The value to validate.
     * @throws If the value cannot be used for this query.
     * @return If valid, returns a DocumentReference that can be used with the
     * query.
     * @private
     * @internal
     */ validateReference(val) {
        const basePath = this._queryOptions.allDescendants ? this._queryOptions.parentPath : this._queryOptions.parentPath.append(this._queryOptions.collectionId);
        let reference;
        if (typeof val === 'string') {
            const path = basePath.append(val);
            if (this._queryOptions.allDescendants) {
                if (!path.isDocument) {
                    throw new Error('When querying a collection group and ordering by ' + 'FieldPath.documentId(), the corresponding value must result in ' + `a valid document path, but '${val}' is not because it ` + 'contains an odd number of segments.');
                }
            } else if (val.indexOf('/') !== -1) {
                throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' + `the corresponding value must be a plain document ID, but '${val}' ` + 'contains a slash.');
            }
            reference = new document_reference_1.DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);
        } else if (val instanceof document_reference_1.DocumentReference) {
            reference = val;
            if (!basePath.isPrefixOf(reference._path)) {
                throw new Error(`"${reference.path}" is not part of the query result set and ` + 'cannot be used as a query boundary.');
            }
        } else {
            throw new Error('The corresponding value for FieldPath.documentId() must be a ' + `string or a DocumentReference, but was "${val}".`);
        }
        if (!this._queryOptions.allDescendants && reference._path.parent().compareTo(basePath) !== 0) {
            throw new Error('Only a direct child can be used as a query boundary. ' + `Found: "${reference.path}".`);
        }
        return reference;
    }
    /**
     * Creates and returns a new [Query]{@link Query} that starts at the provided
     * set of field values relative to the order of the query. The order of the
     * provided values must match the order of the order by clauses of the query.
     *
     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot
     * of the document the query results should start at or the field values to
     * start this query at, in order of the query's order by.
     * @returns {Query} A query with the new starting point.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.orderBy('foo').startAt(42).get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ startAt(...fieldValuesOrDocumentSnapshot) {
        (0, validate_1.validateMinNumberOfArguments)('Query.startAt', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);
        const options = this._queryOptions.with({
            fieldOrders,
            startAt
        });
        return new Query(this._firestore, options);
    }
    /**
     * Creates and returns a new [Query]{@link Query} that starts after the
     * provided set of field values relative to the order of the query. The order
     * of the provided values must match the order of the order by clauses of the
     * query.
     *
     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot
     * of the document the query results should start after or the field values to
     * start this query after, in order of the query's order by.
     * @returns {Query} A query with the new starting point.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ startAfter(...fieldValuesOrDocumentSnapshot) {
        (0, validate_1.validateMinNumberOfArguments)('Query.startAfter', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);
        const options = this._queryOptions.with({
            fieldOrders,
            startAt
        });
        return new Query(this._firestore, options);
    }
    /**
     * Creates and returns a new [Query]{@link Query} that ends before the set of
     * field values relative to the order of the query. The order of the provided
     * values must match the order of the order by clauses of the query.
     *
     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot
     * of the document the query results should end before or the field values to
     * end this query before, in order of the query's order by.
     * @returns {Query} A query with the new ending point.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ endBefore(...fieldValuesOrDocumentSnapshot) {
        (0, validate_1.validateMinNumberOfArguments)('Query.endBefore', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);
        const options = this._queryOptions.with({
            fieldOrders,
            endAt
        });
        return new Query(this._firestore, options);
    }
    /**
     * Creates and returns a new [Query]{@link Query} that ends at the provided
     * set of field values relative to the order of the query. The order of the
     * provided values must match the order of the order by clauses of the query.
     *
     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot
     * of the document the query results should end at or the field values to end
     * this query at, in order of the query's order by.
     * @returns {Query} A query with the new ending point.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.orderBy('foo').endAt(42).get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ endAt(...fieldValuesOrDocumentSnapshot) {
        (0, validate_1.validateMinNumberOfArguments)('Query.endAt', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);
        const options = this._queryOptions.with({
            fieldOrders,
            endAt
        });
        return new Query(this._firestore, options);
    }
    /**
     * Executes the query and returns the results as a
     * [QuerySnapshot]{@link QuerySnapshot}.
     *
     * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results
     * of the Query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then(querySnapshot => {
     *   querySnapshot.forEach(documentSnapshot => {
     *     console.log(`Found document at ${documentSnapshot.ref.path}`);
     *   });
     * });
     * ```
     */ async get() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_QUERY_GET, async ()=>{
            const { result } = await this._get();
            return result;
        });
    }
    /**
     * Plans and optionally executes this query. Returns a Promise that will be
     * resolved with the planner information, statistics from the query execution (if any),
     * and the query results (if any).
     *
     * @return A Promise that will be resolved with the planner information, statistics
     *  from the query execution (if any), and the query results (if any).
     */ async explain(options) {
        if (options === undefined) {
            options = {};
        }
        const { result, explainMetrics } = await this._getResponse(undefined, options);
        if (!explainMetrics) {
            throw new Error('No explain results');
        }
        return new query_profile_1.ExplainResults(explainMetrics, result || null);
    }
    /**
     * Internal get() method that accepts an optional transaction options, and
     * returns a query snapshot with transaction and explain metadata.
     *
     * @private
     * @internal
     * @param transactionOrReadTime A transaction ID, options to start a new
     *  transaction, or timestamp to use as read time.
     */ async _get(transactionOrReadTime) {
        const result = await this._getResponse(transactionOrReadTime);
        if (!result.result) {
            throw new Error('No QuerySnapshot result');
        }
        return result;
    }
    _getResponse(transactionOrReadTime, explainOptions) {
        return this._queryUtil._getResponse(this, transactionOrReadTime, true, explainOptions);
    }
    /**
     * Executes the query and streams the results as
     * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.
     *
     * @returns {Stream.<QueryDocumentSnapshot>} A stream of
     * QueryDocumentSnapshots.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * let count = 0;
     *
     * query.stream().on('data', (documentSnapshot) => {
     *   console.log(`Found document with name '${documentSnapshot.id}'`);
     *   ++count;
     * }).on('end', () => {
     *   console.log(`Total count is ${count}`);
     * });
     * ```
     */ stream() {
        return this._queryUtil.stream(this);
    }
    /**
     * Executes the query and streams the results as the following object:
     * {document?: DocumentSnapshot, metrics?: ExplainMetrics}
     *
     * The stream surfaces documents one at a time as they are received from the
     * server, and at the end, it will surface the metrics associated with
     * executing the query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * let count = 0;
     *
     * query.explainStream({analyze: true}).on('data', (data) => {
     *   if (data.document) {
     *     // Use data.document which is a DocumentSnapshot instance.
     *     console.log(`Found document with name '${data.document.id}'`);
     *     ++count;
     *   }
     *   if (data.metrics) {
     *     // Use data.metrics which is an ExplainMetrics instance.
     *   }
     * }).on('end', () => {
     *   console.log(`Received ${count} documents.`);
     * });
     * ```
     */ explainStream(explainOptions) {
        if (explainOptions === undefined) {
            explainOptions = {};
        }
        if (this._queryOptions.limitType === types_1.LimitType.Last) {
            throw new Error('Query results for queries that include limitToLast() ' + 'constraints cannot be streamed. Use Query.explain() instead.');
        }
        const responseStream = this._stream(undefined, explainOptions);
        const transform = new stream_1.Transform({
            objectMode: true,
            transform (chunk, encoding, callback) {
                if (chunk.document || chunk.explainMetrics) {
                    callback(undefined, {
                        document: chunk.document,
                        metrics: chunk.explainMetrics
                    });
                }
            }
        });
        responseStream.pipe(transform);
        responseStream.on('error', (e)=>transform.destroy(e));
        return transform;
    }
    /**
     * Converts a QueryCursor to its proto representation.
     *
     * @param cursor The original cursor value
     * @private
     * @internal
     */ toCursor(cursor) {
        if (cursor) {
            return cursor.before ? {
                before: true,
                values: cursor.values
            } : {
                values: cursor.values
            };
        }
        return undefined;
    }
    /**
     * Internal method for serializing a query to its RunQuery proto
     * representation with an optional transaction id or read time.
     *
     * @param transactionOrReadTime A transaction ID, options to start a new
     *  transaction, or timestamp to use as read time.
     * @param explainOptions Options to use for explaining the query (if any).
     * @private
     * @internal
     * @returns Serialized JSON for the query.
     */ toProto(transactionOrReadTime, explainOptions) {
        const projectId = this.firestore.projectId;
        const databaseId = this.firestore.databaseId;
        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);
        const structuredQuery = this.toStructuredQuery();
        // For limitToLast queries, the structured query has to be translated to a version with
        // reversed ordered, and flipped startAt/endAt to work properly.
        if (this._queryOptions.limitType === types_1.LimitType.Last) {
            if (!this._queryOptions.hasFieldOrders()) {
                throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');
            }
            structuredQuery.orderBy = this._queryOptions.fieldOrders.map((order)=>{
                // Flip the orderBy directions since we want the last results
                const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';
                return new field_order_1.FieldOrder(order.field, dir).toProto();
            });
            // Swap the cursors to match the now-flipped query ordering.
            structuredQuery.startAt = this._queryOptions.endAt ? this.toCursor({
                values: this._queryOptions.endAt.values,
                before: !this._queryOptions.endAt.before
            }) : undefined;
            structuredQuery.endAt = this._queryOptions.startAt ? this.toCursor({
                values: this._queryOptions.startAt.values,
                before: !this._queryOptions.startAt.before
            }) : undefined;
        }
        const runQueryRequest = {
            parent: parentPath.formattedName,
            structuredQuery
        };
        if (transactionOrReadTime instanceof Uint8Array) {
            runQueryRequest.transaction = transactionOrReadTime;
        } else if (transactionOrReadTime instanceof index_1.Timestamp) {
            runQueryRequest.readTime = transactionOrReadTime.toProto().timestampValue;
        } else if (transactionOrReadTime) {
            runQueryRequest.newTransaction = transactionOrReadTime;
        }
        if (explainOptions) {
            runQueryRequest.explainOptions = explainOptions;
        }
        return runQueryRequest;
    }
    /**
     * Converts current Query to an IBundledQuery.
     *
     * @private
     * @internal
     */ _toBundledQuery() {
        const projectId = this.firestore.projectId;
        const databaseId = this.firestore.databaseId;
        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);
        const structuredQuery = this.toStructuredQuery();
        const bundledQuery = {
            parent: parentPath.formattedName,
            structuredQuery
        };
        if (this._queryOptions.limitType === types_1.LimitType.First) {
            bundledQuery.limitType = 'FIRST';
        } else if (this._queryOptions.limitType === types_1.LimitType.Last) {
            bundledQuery.limitType = 'LAST';
        }
        return bundledQuery;
    }
    toStructuredQuery() {
        const structuredQuery = {
            from: [
                {}
            ]
        };
        if (this._queryOptions.allDescendants) {
            structuredQuery.from[0].allDescendants = true;
        }
        // Kindless queries select all descendant documents, so we remove the
        // collectionId field.
        if (!this._queryOptions.kindless) {
            structuredQuery.from[0].collectionId = this._queryOptions.collectionId;
        }
        if (this._queryOptions.filters.length >= 1) {
            structuredQuery.where = new composite_filter_internal_1.CompositeFilterInternal(this._queryOptions.filters, 'AND').toProto();
        }
        if (this._queryOptions.hasFieldOrders()) {
            structuredQuery.orderBy = this._queryOptions.fieldOrders.map((o)=>o.toProto());
        }
        structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);
        structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);
        if (this._queryOptions.limit) {
            structuredQuery.limit = {
                value: this._queryOptions.limit
            };
        }
        structuredQuery.offset = this._queryOptions.offset;
        structuredQuery.select = this._queryOptions.projection;
        return structuredQuery;
    }
    /**
     * @internal
     * @private
     * This method exists solely to maintain backward compatability.
     */ _isPermanentRpcError(err, methodName) {
        return this._queryUtil._isPermanentRpcError(err, methodName);
    }
    /**
     * @internal
     * @private
     * This method exists solely to maintain backward compatability.
     */ _hasRetryTimedOut(methodName, startTime) {
        return this._queryUtil._hasRetryTimedOut(methodName, startTime);
    }
    /**
     * Internal streaming method that accepts an optional transaction ID.
     *
     * BEWARE: If `transactionOrReadTime` is `ITransactionOptions`, then the first
     * response in the stream will be a transaction response.
     *
     * @param transactionOrReadTime A transaction ID, options to start a new
     *  transaction, or timestamp to use as read time.
     * @param explainOptions Options to use for explaining the query (if any).
     * @private
     * @internal
     * @returns A stream of document results, optionally preceded by a transaction response.
     */ _stream(transactionOrReadTime, explainOptions) {
        return this._queryUtil._stream(this, transactionOrReadTime, true, explainOptions);
    }
    /**
     * Attaches a listener for QuerySnapshot events.
     *
     * @param {querySnapshotCallback} onNext A callback to be called every time
     * a new [QuerySnapshot]{@link QuerySnapshot} is available.
     * @param {errorCallback=} onError A callback to be called if the listen
     * fails or is cancelled. No further callbacks will occur.
     *
     * @returns {function()} An unsubscribe function that can be called to cancel
     * the snapshot listener.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * let unsubscribe = query.onSnapshot(querySnapshot => {
     *   console.log(`Received query snapshot of size ${querySnapshot.size}`);
     * }, err => {
     *   console.log(`Encountered error: ${err}`);
     * });
     *
     * // Remove this listener.
     * unsubscribe();
     * ```
     */ onSnapshot(onNext, onError) {
        (0, validate_1.validateFunction)('onNext', onNext);
        (0, validate_1.validateFunction)('onError', onError, {
            optional: true
        });
        const watch = new (__turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/watch.js [app-client] (ecmascript)")).QueryWatch(this.firestore, this, this._queryOptions.converter);
        return watch.onSnapshot((readTime, size, docs, changes)=>{
            onNext(new query_snapshot_1.QuerySnapshot(this, readTime, size, docs, changes));
        }, onError || console.error);
    }
    /**
     * Returns a function that can be used to sort QueryDocumentSnapshots
     * according to the sort criteria of this query.
     *
     * @private
     * @internal
     */ comparator() {
        return (doc1, doc2)=>{
            // Add implicit sorting by name, using the last specified direction.
            const lastDirection = this._queryOptions.hasFieldOrders() ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction : 'ASCENDING';
            const orderBys = this._queryOptions.fieldOrders.concat(new field_order_1.FieldOrder(index_1.FieldPath.documentId(), lastDirection));
            for (const orderBy of orderBys){
                let comp;
                if (index_1.FieldPath.documentId().isEqual(orderBy.field)) {
                    comp = doc1.ref._path.compareTo(doc2.ref._path);
                } else {
                    const v1 = doc1.protoField(orderBy.field);
                    const v2 = doc2.protoField(orderBy.field);
                    if (v1 === undefined || v2 === undefined) {
                        throw new Error('Trying to compare documents on fields that ' + "don't exist. Please include the fields you are ordering on " + 'in your select() call.');
                    }
                    comp = (0, order_1.compare)(v1, v2);
                }
                if (comp !== 0) {
                    const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;
                    return direction * comp;
                }
            }
            return 0;
        };
    }
    /**
     * Applies a custom data converter to this Query, allowing you to use your
     * own custom model objects with Firestore. When you call get() on the
     * returned Query, the provided converter will convert between Firestore
     * data of type `NewDbModelType` and your custom type `NewAppModelType`.
     *
     * Using the converter allows you to specify generic type arguments when
     * storing and retrieving objects from Firestore.
     *
     * Passing in `null` as the converter parameter removes the current
     * converter.
     *
     * @example
     * ```
     * class Post {
     *   constructor(readonly title: string, readonly author: string) {}
     *
     *   toString(): string {
     *     return this.title + ', by ' + this.author;
     *   }
     * }
     *
     * const postConverter = {
     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {
     *     return {title: post.title, author: post.author};
     *   },
     *   fromFirestore(
     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot
     *   ): Post {
     *     const data = snapshot.data();
     *     return new Post(data.title, data.author);
     *   }
     * };
     *
     * const postSnap = await Firestore()
     *   .collection('posts')
     *   .withConverter(postConverter)
     *   .doc().get();
     * const post = postSnap.data();
     * if (post !== undefined) {
     *   post.title; // string
     *   post.toString(); // Should be defined
     *   post.someNonExistentProperty; // TS error
     * }
     *
     * ```
     * @param {FirestoreDataConverter | null} converter Converts objects to and
     * from Firestore. Passing in `null` removes the current converter.
     * @return A Query that uses the provided converter.
     */ withConverter(converter) {
        return new Query(this.firestore, this._queryOptions.withConverter(converter !== null && converter !== void 0 ? converter : (0, types_2.defaultConverter)()));
    }
    /**
     * Construct the resulting snapshot for this query with given documents.
     *
     * @private
     * @internal
     */ _createSnapshot(readTime, size, docs, changes) {
        return new query_snapshot_1.QuerySnapshot(this, readTime, size, docs, changes);
    }
}
exports.Query = Query; //# sourceMappingURL=query.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/query-options.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryOptions = void 0;
const deepEqual = __turbopack_context__.r("[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/types.js [app-client] (ecmascript)");
const helpers_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/helpers.js [app-client] (ecmascript)");
/**
 * Internal class representing custom Query options.
 *
 * These options are immutable. Modified options can be created using `with()`.
 * @private
 * @internal
 */ class QueryOptions {
    constructor(parentPath, collectionId, converter, allDescendants, filters, fieldOrders, startAt, endAt, limit, limitType, offset, projection, // Whether to select all documents under `parentPath`. By default, only
    // collections that match `collectionId` are selected.
    kindless = false, // Whether to require consistent documents when restarting the query. By
    // default, restarting the query uses the readTime offset of the original
    // query to provide consistent results.
    requireConsistency = true){
        this.parentPath = parentPath;
        this.collectionId = collectionId;
        this.converter = converter;
        this.allDescendants = allDescendants;
        this.filters = filters;
        this.fieldOrders = fieldOrders;
        this.startAt = startAt;
        this.endAt = endAt;
        this.limit = limit;
        this.limitType = limitType;
        this.offset = offset;
        this.projection = projection;
        this.kindless = kindless;
        this.requireConsistency = requireConsistency;
    }
    /**
     * Returns query options for a collection group query.
     * @private
     * @internal
     */ static forCollectionGroupQuery(collectionId, converter = (0, types_1.defaultConverter)()) {
        return new QueryOptions(/*parentPath=*/ path_1.ResourcePath.EMPTY, collectionId, converter, /*allDescendants=*/ true, /*fieldFilters=*/ [], /*fieldOrders=*/ []);
    }
    /**
     * Returns query options for a single-collection query.
     * @private
     * @internal
     */ static forCollectionQuery(collectionRef, converter = (0, types_1.defaultConverter)()) {
        return new QueryOptions(collectionRef.parent(), collectionRef.id, converter, /*allDescendants=*/ false, /*fieldFilters=*/ [], /*fieldOrders=*/ []);
    }
    /**
     * Returns query options for a query that fetches all descendants under the
     * specified reference.
     *
     * @private
     * @internal
     */ static forKindlessAllDescendants(parent, id, requireConsistency = true) {
        let options = new QueryOptions(parent, id, (0, types_1.defaultConverter)(), /*allDescendants=*/ true, /*fieldFilters=*/ [], /*fieldOrders=*/ []);
        options = options.with({
            kindless: true,
            requireConsistency
        });
        return options;
    }
    /**
     * Returns the union of the current and the provided options.
     * @private
     * @internal
     */ with(settings) {
        return new QueryOptions((0, helpers_1.coalesce)(settings.parentPath, this.parentPath), (0, helpers_1.coalesce)(settings.collectionId, this.collectionId), this.converter, (0, helpers_1.coalesce)(settings.allDescendants, this.allDescendants), (0, helpers_1.coalesce)(settings.filters, this.filters), (0, helpers_1.coalesce)(settings.fieldOrders, this.fieldOrders), (0, helpers_1.coalesce)(settings.startAt, this.startAt), (0, helpers_1.coalesce)(settings.endAt, this.endAt), (0, helpers_1.coalesce)(settings.limit, this.limit), (0, helpers_1.coalesce)(settings.limitType, this.limitType), (0, helpers_1.coalesce)(settings.offset, this.offset), (0, helpers_1.coalesce)(settings.projection, this.projection), (0, helpers_1.coalesce)(settings.kindless, this.kindless), (0, helpers_1.coalesce)(settings.requireConsistency, this.requireConsistency));
    }
    withConverter(converter) {
        return new QueryOptions(this.parentPath, this.collectionId, converter, this.allDescendants, this.filters, this.fieldOrders, this.startAt, this.endAt, this.limit, this.limitType, this.offset, this.projection);
    }
    hasFieldOrders() {
        return this.fieldOrders.length > 0;
    }
    isEqual(other) {
        if (this === other) {
            return true;
        }
        return other instanceof QueryOptions && this.parentPath.isEqual(other.parentPath) && this.filtersEqual(other.filters) && this.collectionId === other.collectionId && this.converter === other.converter && this.allDescendants === other.allDescendants && this.limit === other.limit && this.offset === other.offset && deepEqual(this.fieldOrders, other.fieldOrders) && deepEqual(this.startAt, other.startAt) && deepEqual(this.endAt, other.endAt) && deepEqual(this.projection, other.projection) && this.kindless === other.kindless && this.requireConsistency === other.requireConsistency;
    }
    filtersEqual(other) {
        if (this.filters.length !== other.length) {
            return false;
        }
        for(let i = 0; i < other.length; i++){
            if (!this.filters[i].isEqual(other[i])) {
                return false;
            }
        }
        return true;
    }
}
exports.QueryOptions = QueryOptions; //# sourceMappingURL=query-options.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/collection-reference.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CollectionReference = void 0;
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const write_batch_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/write-batch.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/types.js [app-client] (ecmascript)");
const query_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query.js [app-client] (ecmascript)");
const document_reference_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js [app-client] (ecmascript)");
const query_options_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query-options.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
/**
 * A CollectionReference object can be used for adding documents, getting
 * document references, and querying for documents (using the methods
 * inherited from [Query]{@link Query}).
 *
 * @class CollectionReference
 * @extends Query
 */ class CollectionReference extends query_1.Query {
    /**
     * @private
     *
     * @param firestore The Firestore Database client.
     * @param path The Path of this collection.
     */ constructor(firestore, path, converter){
        super(firestore, query_options_1.QueryOptions.forCollectionQuery(path, converter));
    }
    /**
     * Returns a resource path for this collection.
     * @private
     * @internal
     */ get _resourcePath() {
        return this._queryOptions.parentPath.append(this._queryOptions.collectionId);
    }
    /**
     * The last path element of the referenced collection.
     *
     * @type {string}
     * @name CollectionReference#id
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col/doc/subcollection');
     * console.log(`ID of the subcollection: ${collectionRef.id}`);
     * ```
     */ get id() {
        return this._queryOptions.collectionId;
    }
    /**
     * A reference to the containing Document if this is a subcollection, else
     * null.
     *
     * @type {DocumentReference|null}
     * @name CollectionReference#parent
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col/doc/subcollection');
     * let documentRef = collectionRef.parent;
     * console.log(`Parent name: ${documentRef.path}`);
     * ```
     */ get parent() {
        if (this._queryOptions.parentPath.isDocument) {
            return new document_reference_1.DocumentReference(this.firestore, this._queryOptions.parentPath);
        }
        return null;
    }
    /**
     * A string representing the path of the referenced collection (relative
     * to the root of the database).
     *
     * @type {string}
     * @name CollectionReference#path
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col/doc/subcollection');
     * console.log(`Path of the subcollection: ${collectionRef.path}`);
     * ```
     */ get path() {
        return this._resourcePath.relativeName;
    }
    /**
     * Retrieves the list of documents in this collection.
     *
     * The document references returned may include references to "missing
     * documents", i.e. document locations that have no document present but
     * which contain subcollections with documents. Attempting to read such a
     * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a
     * `DocumentSnapshot` whose `.exists` property is false.
     *
     * @return {Promise<DocumentReference[]>} The list of documents in this
     * collection.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * return collectionRef.listDocuments().then(documentRefs => {
     *    return firestore.getAll(...documentRefs);
     * }).then(documentSnapshots => {
     *    for (let documentSnapshot of documentSnapshots) {
     *       if (documentSnapshot.exists) {
     *         console.log(`Found document with data: ${documentSnapshot.id}`);
     *       } else {
     *         console.log(`Found missing document: ${documentSnapshot.id}`);
     *       }
     *    }
     * });
     * ```
     */ listDocuments() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_COL_REF_LIST_DOCUMENTS, ()=>{
            const tag = (0, util_1.requestTag)();
            return this.firestore.initializeIfNeeded(tag).then(()=>{
                const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId, this.firestore.databaseId);
                const request = {
                    parent: parentPath.formattedName,
                    collectionId: this.id,
                    showMissing: true,
                    mask: {
                        fieldPaths: []
                    }
                };
                return this.firestore.request('listDocuments', request, tag).then((documents)=>{
                    // Note that the backend already orders these documents by name,
                    // so we do not need to manually sort them.
                    return documents.map((doc)=>{
                        const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);
                        return this.doc(path.id);
                    });
                });
            });
        });
    }
    /**
     * Gets a [DocumentReference]{@link DocumentReference} instance that
     * refers to the document at the specified path. If no path is specified, an
     * automatically-generated unique ID will be used for the returned
     * DocumentReference.
     *
     * @param {string=} documentPath A slash-separated path to a document.
     * @returns {DocumentReference} The `DocumentReference`
     * instance.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     * let documentRefWithName = collectionRef.doc('doc');
     * let documentRefWithAutoId = collectionRef.doc();
     * console.log(`Reference with name: ${documentRefWithName.path}`);
     * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);
     * ```
     */ doc(documentPath) {
        if (arguments.length === 0) {
            documentPath = (0, util_1.autoId)();
        } else {
            (0, path_1.validateResourcePath)('documentPath', documentPath);
        }
        const path = this._resourcePath.append(documentPath);
        if (!path.isDocument) {
            throw new Error(`Value for argument "documentPath" must point to a document, but was "${documentPath}". Your path does not contain an even number of components.`);
        }
        return new document_reference_1.DocumentReference(this.firestore, path, this._queryOptions.converter);
    }
    /**
     * Add a new document to this collection with the specified data, assigning
     * it a document ID automatically.
     *
     * @param {DocumentData} data An Object containing the data for the new
     * document.
     * @throws {Error} If the provided input is not a valid Firestore document.
     * @returns {Promise.<DocumentReference>} A Promise resolved with a
     * [DocumentReference]{@link DocumentReference} pointing to the
     * newly created document.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     * collectionRef.add({foo: 'bar'}).then(documentReference => {
     *   console.log(`Added document with name: ${documentReference.id}`);
     * });
     * ```
     */ add(data) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_COL_REF_ADD, ()=>{
            const firestoreData = this._queryOptions.converter.toFirestore(data);
            (0, write_batch_1.validateDocumentData)('data', firestoreData, /*allowDeletes=*/ false, this._allowUndefined);
            const documentRef = this.doc();
            return documentRef.create(data).then(()=>documentRef);
        });
    }
    /**
     * Returns true if this `CollectionReference` is equal to the provided value.
     *
     * @param {*} other The value to compare against.
     * @return {boolean} true if this `CollectionReference` is equal to the
     * provided value.
     */ isEqual(other) {
        return this === other || other instanceof CollectionReference && super.isEqual(other);
    }
    /**
     * Applies a custom data converter to this CollectionReference, allowing you
     * to use your own custom model objects with Firestore. When you call add() on
     * the returned CollectionReference instance, the provided converter will
     * convert between Firestore data of type `NewDbModelType` and your custom
     * type `NewAppModelType`.
     *
     * Using the converter allows you to specify generic type arguments when
     * storing and retrieving objects from Firestore.
     *
     * Passing in `null` as the converter parameter removes the current
     * converter.
     *
     * @example
     * ```
     * class Post {
     *   constructor(readonly title: string, readonly author: string) {}
     *
     *   toString(): string {
     *     return this.title + ', by ' + this.author;
     *   }
     * }
     *
     * const postConverter = {
     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {
     *     return {title: post.title, author: post.author};
     *   },
     *   fromFirestore(
     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot
     *   ): Post {
     *     const data = snapshot.data();
     *     return new Post(data.title, data.author);
     *   }
     * };
     *
     * const postSnap = await Firestore()
     *   .collection('posts')
     *   .withConverter(postConverter)
     *   .doc().get();
     * const post = postSnap.data();
     * if (post !== undefined) {
     *   post.title; // string
     *   post.toString(); // Should be defined
     *   post.someNonExistentProperty; // TS error
     * }
     *
     * ```
     * @param {FirestoreDataConverter | null} converter Converts objects to and
     * from Firestore. Passing in `null` removes the current converter.
     * @return A CollectionReference that uses the provided converter.
     */ withConverter(converter) {
        return new CollectionReference(this.firestore, this._resourcePath, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());
    }
}
exports.CollectionReference = CollectionReference; //# sourceMappingURL=collection-reference.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DocumentReference = void 0;
const index_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/index.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/types.js [app-client] (ecmascript)");
const collection_reference_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/collection-reference.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const document_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
/**
 * A DocumentReference refers to a document location in a Firestore database
 * and can be used to write, read, or listen to the location. The document at
 * the referenced location may or may not exist. A DocumentReference can
 * also be used to create a
 * [CollectionReference]{@link CollectionReference} to a
 * subcollection.
 *
 * @class DocumentReference
 */ class DocumentReference {
    /**
     * @private
     * @internal
     * @param _firestore The Firestore Database client.
     * @param _path The Path of this reference.
     * @param _converter The converter to use when serializing data.
     */ constructor(_firestore, /**
     * @private
     * @internal
     **/ _path, /**
     * @internal
     * @private
     **/ _converter = (0, types_1.defaultConverter)()){
        this._firestore = _firestore;
        this._path = _path;
        this._converter = _converter;
    }
    /**
     * The string representation of the DocumentReference's location.
     * @private
     * @internal
     * @type {string}
     * @name DocumentReference#formattedName
     */ get formattedName() {
        const projectId = this.firestore.projectId;
        const databaseId = this.firestore.databaseId;
        return this._path.toQualifiedResourcePath(projectId, databaseId).formattedName;
    }
    /**
     * The [Firestore]{@link Firestore} instance for the Firestore
     * database (useful for performing transactions, etc.).
     *
     * @type {Firestore}
     * @name DocumentReference#firestore
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * collectionRef.add({foo: 'bar'}).then(documentReference => {
     *   let firestore = documentReference.firestore;
     *   console.log(`Root location for document is ${firestore.formattedName}`);
     * });
     * ```
     */ get firestore() {
        return this._firestore;
    }
    /**
     * A string representing the path of the referenced document (relative
     * to the root of the database).
     *
     * @type {string}
     * @name DocumentReference#path
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * collectionRef.add({foo: 'bar'}).then(documentReference => {
     *   console.log(`Added document at '${documentReference.path}'`);
     * });
     * ```
     */ get path() {
        return this._path.relativeName;
    }
    /**
     * The last path element of the referenced document.
     *
     * @type {string}
     * @name DocumentReference#id
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * collectionRef.add({foo: 'bar'}).then(documentReference => {
     *   console.log(`Added document with name '${documentReference.id}'`);
     * });
     * ```
     */ get id() {
        return this._path.id;
    }
    /**
     * Returns a resource path for this document.
     * @private
     * @internal
     */ get _resourcePath() {
        return this._path;
    }
    /**
     * A reference to the collection to which this DocumentReference belongs.
     *
     * @name DocumentReference#parent
     * @type {CollectionReference}
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     * let collectionRef = documentRef.parent;
     *
     * collectionRef.where('foo', '==', 'bar').get().then(results => {
     *   console.log(`Found ${results.size} matches in parent collection`);
     * }):
     * ```
     */ get parent() {
        return new collection_reference_1.CollectionReference(this._firestore, this._path.parent(), this._converter);
    }
    /**
     * Reads the document referred to by this DocumentReference.
     *
     * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a
     * DocumentSnapshot for the retrieved document on success. For missing
     * documents, DocumentSnapshot.exists will be false. If the get() fails for
     * other reasons, the Promise will be rejected.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(documentSnapshot => {
     *   if (documentSnapshot.exists) {
     *     console.log('Document retrieved successfully.');
     *   }
     * });
     * ```
     */ get() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_GET, ()=>{
            return this._firestore.getAll(this).then(([result])=>result);
        });
    }
    /**
     * Gets a [CollectionReference]{@link CollectionReference} instance
     * that refers to the collection at the specified path.
     *
     * @param {string} collectionPath A slash-separated path to a collection.
     * @returns {CollectionReference} A reference to the new
     * subcollection.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     * let subcollection = documentRef.collection('subcollection');
     * console.log(`Path to subcollection: ${subcollection.path}`);
     * ```
     */ collection(collectionPath) {
        (0, path_1.validateResourcePath)('collectionPath', collectionPath);
        const path = this._path.append(collectionPath);
        if (!path.isCollection) {
            throw new Error(`Value for argument "collectionPath" must point to a collection, but was "${collectionPath}". Your path does not contain an odd number of components.`);
        }
        return new collection_reference_1.CollectionReference(this._firestore, path);
    }
    /**
     * Fetches the subcollections that are direct children of this document.
     *
     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves
     * with an array of CollectionReferences.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.listCollections().then(collections => {
     *   for (let collection of collections) {
     *     console.log(`Found subcollection with id: ${collection.id}`);
     *   }
     * });
     * ```
     */ listCollections() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_LIST_COLLECTIONS, ()=>{
            const tag = (0, util_1.requestTag)();
            return this.firestore.initializeIfNeeded(tag).then(()=>{
                const request = {
                    parent: this.formattedName
                };
                return this._firestore.request('listCollectionIds', request, tag).then((collectionIds)=>{
                    const collections = [];
                    // We can just sort this list using the default comparator since it
                    // will only contain collection ids.
                    collectionIds.sort();
                    for (const collectionId of collectionIds){
                        collections.push(this.collection(collectionId));
                    }
                    return collections;
                });
            });
        });
    }
    /**
     * Create a document with the provided object values. This will fail the write
     * if a document exists at its location.
     *
     * @param {DocumentData} data An object that contains the fields and data to
     * serialize as the document.
     * @throws {Error} If the provided input is not a valid Firestore document or if the document already exists.
     * @returns {Promise.<WriteResult>} A Promise that resolves with the
     * write time of this create.
     *
     * @example
     * ```
     * let documentRef = firestore.collection('col').doc();
     *
     * documentRef.create({foo: 'bar'}).then((res) => {
     *   console.log(`Document created at ${res.updateTime}`);
     * }).catch((err) => {
     *   console.log(`Failed to create document: ${err}`);
     * });
     * ```
     */ create(data) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_CREATE, ()=>{
            const writeBatch = new index_1.WriteBatch(this._firestore);
            return writeBatch.create(this, data).commit().then(([writeResult])=>writeResult);
        });
    }
    /**
     * Deletes the document referred to by this `DocumentReference`.
     *
     * A delete for a non-existing document is treated as a success (unless
     * lastUptimeTime is provided).
     *
     * @param {Precondition=} precondition A precondition to enforce for this
     * delete.
     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the
     * document was last updated at lastUpdateTime. Fails the delete if the
     * document was last updated at a different time.
     * @param {boolean=} precondition.exists If set, enforces that the target
     * document must or must not exist.
     * @returns {Promise.<WriteResult>} A Promise that resolves with the
     * delete time.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.delete().then(() => {
     *   console.log('Document successfully deleted.');
     * });
     * ```
     */ delete(precondition) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_DELETE, ()=>{
            const writeBatch = new index_1.WriteBatch(this._firestore);
            return writeBatch.delete(this, precondition).commit().then(([writeResult])=>writeResult);
        });
    }
    /**
     * Writes to the document referred to by this DocumentReference. If the
     * document does not yet exist, it will be created. If you pass
     * [SetOptions]{@link SetOptions}, the provided data can be merged into an
     * existing document.
     *
     * @param {T|Partial<AppModelType>} data A map of the fields and values for
     * the document.
     * @param {SetOptions=} options An object to configure the set behavior.
     * @param {boolean=} options.merge If true, set() merges the values specified
     * in its data argument. Fields omitted from this set() call remain untouched.
     * If your input sets any field to an empty map, all nested fields are
     * overwritten.
     * @param {Array.<string|FieldPath>=} options.mergeFields If provided,
     * set() only replaces the specified field paths. Any field path that is not
     * specified is ignored and remains untouched. If your input sets any field to
     * an empty map, all nested fields are overwritten.
     * @throws {Error} If the provided input is not a valid Firestore document.
     * @returns {Promise.<WriteResult>} A Promise that resolves with the
     * write time of this set.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.set({foo: 'bar'}).then(res => {
     *   console.log(`Document written at ${res.updateTime}`);
     * });
     * ```
     */ set(data, options) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_SET, ()=>{
            let writeBatch = new index_1.WriteBatch(this._firestore);
            if (options) {
                writeBatch = writeBatch.set(this, data, options);
            } else {
                writeBatch = writeBatch.set(this, data);
            }
            return writeBatch.commit().then(([writeResult])=>writeResult);
        });
    }
    /**
     * Updates fields in the document referred to by this DocumentReference.
     * If the document doesn't yet exist, the update fails and the returned
     * Promise will be rejected.
     *
     * The update() method accepts either an object with field paths encoded as
     * keys and field values encoded as values, or a variable number of arguments
     * that alternate between field paths and field values.
     *
     * A Precondition restricting this update can be specified as the last
     * argument.
     *
     * @param {UpdateData|string|FieldPath} dataOrField An object containing the
     * fields and values with which to update the document or the path of the
     * first field to update.
     * @param {
     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating
     * list of field paths and values to update or a Precondition to restrict
     * this update.
     * @throws {Error} If the provided input is not valid Firestore data.
     * @returns {Promise.<WriteResult>} A Promise that resolves once the
     * data has been successfully written to the backend.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.update({foo: 'bar'}).then(res => {
     *   console.log(`Document updated at ${res.updateTime}`);
     * });
     * ```
     */ update(dataOrField, ...preconditionOrValues) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_UPDATE, ()=>{
            // eslint-disable-next-line prefer-rest-params
            (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);
            const writeBatch = new index_1.WriteBatch(this._firestore);
            return writeBatch.update(this, dataOrField, ...preconditionOrValues).commit().then(([writeResult])=>writeResult);
        });
    }
    /**
     * Attaches a listener for DocumentSnapshot events.
     *
     * @param {documentSnapshotCallback} onNext A callback to be called every
     * time a new `DocumentSnapshot` is available.
     * @param {errorCallback=} onError A callback to be called if the listen fails
     * or is cancelled. No further callbacks will occur. If unset, errors will be
     * logged to the console.
     *
     * @returns {function()} An unsubscribe function that can be called to cancel
     * the snapshot listener.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {
     *   if (documentSnapshot.exists) {
     *     console.log(documentSnapshot.data());
     *   }
     * }, err => {
     *   console.log(`Encountered error: ${err}`);
     * });
     *
     * // Remove this listener.
     * unsubscribe();
     * ```
     */ onSnapshot(onNext, onError) {
        (0, validate_1.validateFunction)('onNext', onNext);
        (0, validate_1.validateFunction)('onError', onError, {
            optional: true
        });
        const watch = new (__turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/watch.js [app-client] (ecmascript)")).DocumentWatch(this.firestore, this);
        return watch.onSnapshot((readTime, size, docs)=>{
            for (const document of docs()){
                if (document.ref.path === this.path) {
                    onNext(document);
                    return;
                }
            }
            // The document is missing.
            const ref = new DocumentReference(this._firestore, this._path, this._converter);
            const document = new document_1.DocumentSnapshotBuilder(ref);
            document.readTime = readTime;
            onNext(document.build());
        }, onError || console.error);
    }
    /**
     * Returns true if this `DocumentReference` is equal to the provided value.
     *
     * @param {*} other The value to compare against.
     * @return {boolean} true if this `DocumentReference` is equal to the provided
     * value.
     */ isEqual(other) {
        return this === other || other instanceof DocumentReference && this._firestore === other._firestore && this._path.isEqual(other._path) && this._converter === other._converter;
    }
    /**
     * Converts this DocumentReference to the Firestore Proto representation.
     *
     * @private
     * @internal
     */ toProto() {
        return {
            referenceValue: this.formattedName
        };
    }
    /**
     * Applies a custom data converter to this DocumentReference, allowing you to
     * use your own custom model objects with Firestore. When you call set(),
     * get(), etc. on the returned DocumentReference instance, the provided
     * converter will convert between Firestore data of type `NewDbModelType` and
     * your custom type `NewAppModelType`.
     *
     * Using the converter allows you to specify generic type arguments when
     * storing and retrieving objects from Firestore.
     *
     * Passing in `null` as the converter parameter removes the current
     * converter.
     *
     * @example
     * ```
     * class Post {
     *   constructor(readonly title: string, readonly author: string) {}
     *
     *   toString(): string {
     *     return this.title + ', by ' + this.author;
     *   }
     * }
     *
     * const postConverter = {
     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {
     *     return {title: post.title, author: post.author};
     *   },
     *   fromFirestore(
     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot
     *   ): Post {
     *     const data = snapshot.data();
     *     return new Post(data.title, data.author);
     *   }
     * };
     *
     * const postSnap = await Firestore()
     *   .collection('posts')
     *   .withConverter(postConverter)
     *   .doc().get();
     * const post = postSnap.data();
     * if (post !== undefined) {
     *   post.title; // string
     *   post.toString(); // Should be defined
     *   post.someNonExistentProperty; // TS error
     * }
     *
     * ```
     * @param {FirestoreDataConverter | null} converter Converts objects to and
     * from Firestore. Passing in `null` removes the current converter.
     * @return A DocumentReference that uses the provided converter.
     */ withConverter(converter) {
        return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());
    }
}
exports.DocumentReference = DocumentReference; //# sourceMappingURL=document-reference.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/document.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Precondition = exports.DocumentTransform = exports.DocumentMask = exports.QueryDocumentSnapshot = exports.DocumentSnapshot = exports.DocumentSnapshotBuilder = void 0;
const deepEqual = __turbopack_context__.r("[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)");
const assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
const field_value_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/field-value.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const document_reference_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/types.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
/**
 * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.
 * Invoke `.build()' to assemble the final snapshot.
 *
 * @private
 * @internal
 */ class DocumentSnapshotBuilder {
    // We include the DocumentReference in the constructor in order to allow the
    // DocumentSnapshotBuilder to be typed with <AppModelType, DbModelType> when
    // it is constructed.
    constructor(ref){
        this.ref = ref;
    }
    /**
     * Builds the DocumentSnapshot.
     *
     * @private
     * @internal
     * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was
     * provided) or a DocumentSnapshot.
     */ build() {
        assert(this.fieldsProto !== undefined === (this.createTime !== undefined), 'Create time should be set iff document exists.');
        assert(this.fieldsProto !== undefined === (this.updateTime !== undefined), 'Update time should be set iff document exists.');
        return this.fieldsProto ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime) : new DocumentSnapshot(this.ref, undefined, this.readTime);
    }
}
exports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;
/**
 * A DocumentSnapshot is an immutable representation for a document in a
 * Firestore database. The data can be extracted with
 * [data()]{@link DocumentSnapshot#data} or
 * [get(fieldPath)]{@link DocumentSnapshot#get} to get a
 * specific field.
 *
 * <p>For a DocumentSnapshot that points to a non-existing document, any data
 * access will return 'undefined'. You can use the
 * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a
 * document's existence.
 *
 * @class DocumentSnapshot
 */ class DocumentSnapshot {
    /**
     * @private
     * @internal
     *
     * @param ref The reference to the document.
     * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing
     * this document (or undefined if the document does not exist).
     * @param readTime The time when this snapshot was read  (or undefined if
     * the document exists only locally).
     * @param createTime The time when the document was created (or undefined if
     * the document does not exist).
     * @param updateTime The time when the document was last updated (or undefined
     * if the document does not exist).
     */ constructor(ref, /**
     * @internal
     * @private
     **/ _fieldsProto, readTime, createTime, updateTime){
        this._fieldsProto = _fieldsProto;
        this._ref = ref;
        this._serializer = ref.firestore._serializer;
        this._readTime = readTime;
        this._createTime = createTime;
        this._updateTime = updateTime;
    }
    /**
     * Creates a DocumentSnapshot from an object.
     *
     * @private
     * @internal
     * @param ref The reference to the document.
     * @param obj The object to store in the DocumentSnapshot.
     * @return The created DocumentSnapshot.
     */ static fromObject(ref, obj) {
        const serializer = ref.firestore._serializer;
        return new DocumentSnapshot(ref, serializer.encodeFields(obj));
    }
    /**
     * Creates a DocumentSnapshot from an UpdateMap.
     *
     * This methods expands the top-level field paths in a JavaScript map and
     * turns { foo.bar : foobar } into { foo { bar : foobar }}
     *
     * @private
     * @internal
     * @param ref The reference to the document.
     * @param data The field/value map to expand.
     * @return The created DocumentSnapshot.
     */ static fromUpdateMap(ref, data) {
        const serializer = ref.firestore._serializer;
        /**
         * Merges 'value' at the field path specified by the path array into
         * 'target'.
         */ function merge(target, value, path, pos) {
            const key = path[pos];
            const isLast = pos === path.length - 1;
            if (target[key] === undefined) {
                if (isLast) {
                    if (value instanceof field_value_1.FieldTransform) {
                        // If there is already data at this path, we need to retain it.
                        // Otherwise, we don't include it in the DocumentSnapshot.
                        return !(0, util_1.isEmpty)(target) ? target : null;
                    }
                    // The merge is done.
                    const leafNode = serializer.encodeValue(value);
                    if (leafNode) {
                        target[key] = leafNode;
                    }
                    return target;
                } else {
                    // We need to expand the target object.
                    const childNode = {
                        mapValue: {
                            fields: {}
                        }
                    };
                    const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);
                    if (nestedValue) {
                        childNode.mapValue.fields = nestedValue;
                        target[key] = childNode;
                        return target;
                    } else {
                        return !(0, util_1.isEmpty)(target) ? target : null;
                    }
                }
            } else {
                assert(!isLast, "Can't merge current value into a nested object");
                target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);
                return target;
            }
        }
        const res = {};
        for (const [key, value] of data){
            const path = key.toArray();
            merge(res, value, path, 0);
        }
        return new DocumentSnapshot(ref, res);
    }
    /**
     * True if the document exists.
     *
     * @type {boolean}
     * @name DocumentSnapshot#exists
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then((documentSnapshot) => {
     *   if (documentSnapshot.exists) {
     *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);
     *   }
     * });
     * ```
     */ get exists() {
        return this._fieldsProto !== undefined;
    }
    /**
     * A [DocumentReference]{@link DocumentReference} for the document
     * stored in this snapshot.
     *
     * @type {DocumentReference}
     * @name DocumentSnapshot#ref
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then((documentSnapshot) => {
     *   if (documentSnapshot.exists) {
     *     console.log(`Found document at '${documentSnapshot.ref.path}'`);
     *   }
     * });
     * ```
     */ get ref() {
        return this._ref;
    }
    /**
     * The ID of the document for which this DocumentSnapshot contains data.
     *
     * @type {string}
     * @name DocumentSnapshot#id
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then((documentSnapshot) => {
     *   if (documentSnapshot.exists) {
     *     console.log(`Document found with name '${documentSnapshot.id}'`);
     *   }
     * });
     * ```
     */ get id() {
        return this._ref.id;
    }
    /**
     * The time the document was created. Undefined for documents that don't
     * exist.
     *
     * @type {Timestamp|undefined}
     * @name DocumentSnapshot#createTime
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(documentSnapshot => {
     *   if (documentSnapshot.exists) {
     *     let createTime = documentSnapshot.createTime;
     *     console.log(`Document created at '${createTime.toDate()}'`);
     *   }
     * });
     * ```
     */ get createTime() {
        return this._createTime;
    }
    /**
     * The time the document was last updated (at the time the snapshot was
     * generated). Undefined for documents that don't exist.
     *
     * @type {Timestamp|undefined}
     * @name DocumentSnapshot#updateTime
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(documentSnapshot => {
     *   if (documentSnapshot.exists) {
     *     let updateTime = documentSnapshot.updateTime;
     *     console.log(`Document updated at '${updateTime.toDate()}'`);
     *   }
     * });
     * ```
     */ get updateTime() {
        return this._updateTime;
    }
    /**
     * The time this snapshot was read.
     *
     * @type {Timestamp}
     * @name DocumentSnapshot#readTime
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(documentSnapshot => {
     *   let readTime = documentSnapshot.readTime;
     *   console.log(`Document read at '${readTime.toDate()}'`);
     * });
     * ```
     */ get readTime() {
        if (this._readTime === undefined) {
            throw new Error("Called 'readTime' on a local document");
        }
        return this._readTime;
    }
    /**
     * Retrieves all fields in the document as an object. Returns 'undefined' if
     * the document doesn't exist.
     *
     * @returns {T|undefined} An object containing all fields in the document or
     * 'undefined' if the document doesn't exist.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(documentSnapshot => {
     *   let data = documentSnapshot.data();
     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);
     * });
     * ```
     */ data() {
        const fields = this._fieldsProto;
        if (fields === undefined) {
            return undefined;
        }
        // We only want to use the converter and create a new QueryDocumentSnapshot
        // if a converter has been provided.
        if (this.ref._converter !== (0, types_1.defaultConverter)()) {
            const untypedReference = new document_reference_1.DocumentReference(this.ref.firestore, this.ref._path);
            return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));
        } else {
            const obj = {};
            for (const prop of Object.keys(fields)){
                obj[prop] = this._serializer.decodeValue(fields[prop]);
            }
            return obj;
        }
    }
    /**
     * Retrieves the field specified by `field`.
     *
     * @param {string|FieldPath} field The field path
     * (e.g. 'foo' or 'foo.bar') to a specific field.
     * @returns {*} The data at the specified field location or undefined if no
     * such field exists.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.set({ a: { b: 'c' }}).then(() => {
     *   return documentRef.get();
     * }).then(documentSnapshot => {
     *   let field = documentSnapshot.get('a.b');
     *   console.log(`Retrieved field value: ${field}`);
     * });
     * ```
     */ // We deliberately use `any` in the external API to not impose type-checking
    // on end users.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get(field) {
        (0, path_1.validateFieldPath)('field', field);
        const protoField = this.protoField(field);
        if (protoField === undefined) {
            return undefined;
        }
        return this._serializer.decodeValue(protoField);
    }
    /**
     * Retrieves the field specified by 'fieldPath' in its Protobuf JS
     * representation.
     *
     * @private
     * @internal
     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.
     * @returns The Protobuf-encoded data at the specified field location or
     * undefined if no such field exists.
     */ protoField(field) {
        let fields = this._fieldsProto;
        if (fields === undefined) {
            return undefined;
        }
        const components = path_1.FieldPath.fromArgument(field).toArray();
        while(components.length > 1){
            fields = fields[components.shift()];
            if (!fields || !fields.mapValue) {
                return undefined;
            }
            fields = fields.mapValue.fields;
        }
        return fields[components[0]];
    }
    /**
     * Convert a document snapshot to the Firestore 'Write' proto.
     *
     * @private
     * @internal
     */ toWriteProto() {
        return {
            update: {
                name: this._ref.formattedName,
                fields: this._fieldsProto
            }
        };
    }
    /**
     * Convert a document snapshot to the Firestore 'Document' proto.
     *
     * @private
     * @internal
     */ toDocumentProto() {
        var _a, _b;
        return {
            name: this._ref.formattedName,
            createTime: (_a = this.createTime) === null || _a === void 0 ? void 0 : _a.toProto().timestampValue,
            updateTime: (_b = this.updateTime) === null || _b === void 0 ? void 0 : _b.toProto().timestampValue,
            fields: this._fieldsProto
        };
    }
    /**
     * Returns true if the document's data and path in this `DocumentSnapshot` is
     * equal to the provided value.
     *
     * @param {*} other The value to compare against.
     * @return {boolean} true if this `DocumentSnapshot` is equal to the provided
     * value.
     */ isEqual(other) {
        // Since the read time is different on every document read, we explicitly
        // ignore all document metadata in this comparison.
        return this === other || other instanceof DocumentSnapshot && this._ref.isEqual(other._ref) && deepEqual(this._fieldsProto, other._fieldsProto);
    }
}
exports.DocumentSnapshot = DocumentSnapshot;
/**
 * A QueryDocumentSnapshot contains data read from a document in your
 * Firestore database as part of a query. The document is guaranteed to exist
 * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}
 * or [get()]{@link DocumentSnapshot#get} to get a specific field.
 *
 * A QueryDocumentSnapshot offers the same API surface as a
 * {@link DocumentSnapshot}. Since query results contain only existing
 * documents, the [exists]{@link DocumentSnapshot#exists} property will
 * always be true and [data()]{@link QueryDocumentSnapshot#data} will never
 * return 'undefined'.
 *
 * @class QueryDocumentSnapshot
 * @extends DocumentSnapshot
 */ class QueryDocumentSnapshot extends DocumentSnapshot {
    /**
     * The time the document was created.
     *
     * @type {Timestamp}
     * @name QueryDocumentSnapshot#createTime
     * @readonly
     * @override
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.get().forEach(snapshot => {
     *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);
     * });
     * ```
     */ get createTime() {
        return super.createTime;
    }
    /**
     * The time the document was last updated (at the time the snapshot was
     * generated).
     *
     * @type {Timestamp}
     * @name QueryDocumentSnapshot#updateTime
     * @readonly
     * @override
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.get().forEach(snapshot => {
     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);
     * });
     * ```
     */ get updateTime() {
        return super.updateTime;
    }
    /**
     * Retrieves all fields in the document as an object.
     *
     * @override
     *
     * @returns {T} An object containing all fields in the document.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.get().forEach(documentSnapshot => {
     *   let data = documentSnapshot.data();
     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);
     * });
     * ```
     */ data() {
        const data = super.data();
        if (!data) {
            throw new Error('The data in a QueryDocumentSnapshot should always exist.');
        }
        return data;
    }
}
exports.QueryDocumentSnapshot = QueryDocumentSnapshot;
/**
 * A Firestore Document Mask contains the field paths affected by an update.
 *
 * @class
 * @private
 * @internal
 */ class DocumentMask {
    /**
     * @private
     * @internal
     * @private
     *
     * @param fieldPaths The field paths in this mask.
     */ constructor(fieldPaths){
        this._sortedPaths = fieldPaths;
        this._sortedPaths.sort((a, b)=>a.compareTo(b));
    }
    /**
     * Creates a document mask with the field paths of a document.
     *
     * @private
     * @internal
     * @param data A map with fields to modify. Only the keys are used to extract
     * the document mask.
     */ static fromUpdateMap(data) {
        const fieldPaths = [];
        data.forEach((value, key)=>{
            if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {
                fieldPaths.push(path_1.FieldPath.fromArgument(key));
            }
        });
        return new DocumentMask(fieldPaths);
    }
    /**
     * Creates a document mask from an array of field paths.
     *
     * @private
     * @internal
     * @param fieldMask A list of field paths.
     */ static fromFieldMask(fieldMask) {
        const fieldPaths = [];
        for (const fieldPath of fieldMask){
            fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));
        }
        return new DocumentMask(fieldPaths);
    }
    /**
     * Creates a document mask with the field names of a document.
     *
     * @private
     * @internal
     * @param data An object with fields to modify. Only the keys are used to
     * extract the document mask.
     */ static fromObject(data) {
        const fieldPaths = [];
        function extractFieldPaths(currentData, currentPath) {
            let isEmpty = true;
            for (const key of Object.keys(currentData)){
                isEmpty = false;
                // We don't split on dots since fromObject is called with
                // DocumentData.
                const childSegment = new path_1.FieldPath(key);
                const childPath = currentPath ? currentPath.append(childSegment) : childSegment;
                const value = currentData[key];
                if (value instanceof field_value_1.FieldTransform) {
                    if (value.includeInDocumentMask) {
                        fieldPaths.push(childPath);
                    }
                } else if ((0, util_1.isPlainObject)(value)) {
                    extractFieldPaths(value, childPath);
                } else if (value !== undefined) {
                    // If the value is undefined it can never participate in the document
                    // mask. With `ignoreUndefinedProperties` set to false,
                    // `validateDocumentData` will reject an undefined value before even
                    // computing the document mask.
                    fieldPaths.push(childPath);
                }
            }
            // Add a field path for an explicitly updated empty map.
            if (currentPath && isEmpty) {
                fieldPaths.push(currentPath);
            }
        }
        extractFieldPaths(data);
        return new DocumentMask(fieldPaths);
    }
    /**
     * Returns true if this document mask contains no fields.
     *
     * @private
     * @internal
     * @return {boolean} Whether this document mask is empty.
     */ get isEmpty() {
        return this._sortedPaths.length === 0;
    }
    /**
     * Removes the specified values from a sorted field path array.
     *
     * @private
     * @internal
     * @param input A sorted array of FieldPaths.
     * @param values An array of FieldPaths to remove.
     */ static removeFromSortedArray(input, values) {
        for(let i = 0; i < input.length;){
            let removed = false;
            for (const fieldPath of values){
                if (input[i].isEqual(fieldPath)) {
                    input.splice(i, 1);
                    removed = true;
                    break;
                }
            }
            if (!removed) {
                ++i;
            }
        }
    }
    /**
     * Removes the field path specified in 'fieldPaths' from this document mask.
     *
     * @private
     * @internal
     * @param fieldPaths An array of FieldPaths.
     */ removeFields(fieldPaths) {
        DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);
    }
    /**
     * Returns whether this document mask contains 'fieldPath'.
     *
     * @private
     * @internal
     * @param fieldPath The field path to test.
     * @return Whether this document mask contains 'fieldPath'.
     */ contains(fieldPath) {
        for (const sortedPath of this._sortedPaths){
            const cmp = sortedPath.compareTo(fieldPath);
            if (cmp === 0) {
                return true;
            } else if (cmp > 0) {
                return false;
            }
        }
        return false;
    }
    /**
     * Removes all properties from 'data' that are not contained in this document
     * mask.
     *
     * @private
     * @internal
     * @param data An object to filter.
     * @return A shallow copy of the object filtered by this document mask.
     */ applyTo(data) {
        /*!
         * Applies this DocumentMask to 'data' and computes the list of field paths
         * that were specified in the mask but are not present in 'data'.
         */ const applyDocumentMask = (data)=>{
            const remainingPaths = this._sortedPaths.slice(0);
            const processObject = (currentData, currentPath)=>{
                let result = null;
                Object.keys(currentData).forEach((key)=>{
                    const childPath = currentPath ? currentPath.append(key) : new path_1.FieldPath(key);
                    if (this.contains(childPath)) {
                        DocumentMask.removeFromSortedArray(remainingPaths, [
                            childPath
                        ]);
                        result = result || {};
                        result[key] = currentData[key];
                    } else if ((0, util_1.isObject)(currentData[key])) {
                        const childObject = processObject(currentData[key], childPath);
                        if (childObject) {
                            result = result || {};
                            result[key] = childObject;
                        }
                    }
                });
                return result;
            };
            // processObject() returns 'null' if the DocumentMask is empty.
            const filteredData = processObject(data) || {};
            return {
                filteredData,
                remainingPaths
            };
        };
        const result = applyDocumentMask(data);
        if (result.remainingPaths.length !== 0) {
            throw new Error(`Input data is missing for field "${result.remainingPaths[0]}".`);
        }
        return result.filteredData;
    }
    /**
     * Converts a document mask to the Firestore 'DocumentMask' Proto.
     *
     * @private
     * @internal
     * @returns A Firestore 'DocumentMask' Proto.
     */ toProto() {
        if (this.isEmpty) {
            return {};
        }
        const encodedPaths = [];
        for (const fieldPath of this._sortedPaths){
            encodedPaths.push(fieldPath.formattedName);
        }
        return {
            fieldPaths: encodedPaths
        };
    }
}
exports.DocumentMask = DocumentMask;
/**
 * A Firestore Document Transform.
 *
 * A DocumentTransform contains pending server-side transforms and their
 * corresponding field paths.
 *
 * @private
 * @internal
 * @class
 */ class DocumentTransform {
    /**
     * @private
     * @internal
     * @private
     *
     * @param ref The DocumentReference for this transform.
     * @param transforms A Map of FieldPaths to FieldTransforms.
     */ constructor(ref, transforms){
        this.ref = ref;
        this.transforms = transforms;
    }
    /**
     * Generates a DocumentTransform from a JavaScript object.
     *
     * @private
     * @internal
     * @param ref The `DocumentReference` to use for the DocumentTransform.
     * @param obj The object to extract the transformations from.
     * @returns The Document Transform.
     */ static fromObject(ref, obj) {
        const updateMap = new Map();
        for (const prop of Object.keys(obj)){
            updateMap.set(new path_1.FieldPath(prop), obj[prop]);
        }
        return DocumentTransform.fromUpdateMap(ref, updateMap);
    }
    /**
     * Generates a DocumentTransform from an Update Map.
     *
     * @private
     * @internal
     * @param ref The `DocumentReference` to use for the DocumentTransform.
     * @param data The update data to extract the transformations from.
     * @returns The Document Transform.
     */ static fromUpdateMap(ref, data) {
        const transforms = new Map();
        function encode_(val, path, allowTransforms) {
            if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {
                if (allowTransforms) {
                    transforms.set(path, val);
                } else {
                    throw new Error(`${val.methodName}() is not supported inside of array values.`);
                }
            } else if (Array.isArray(val)) {
                for(let i = 0; i < val.length; ++i){
                    // We need to verify that no array value contains a document transform
                    encode_(val[i], path.append(String(i)), false);
                }
            } else if ((0, util_1.isPlainObject)(val)) {
                for (const prop of Object.keys(val)){
                    encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);
                }
            }
        }
        data.forEach((value, key)=>{
            encode_(value, path_1.FieldPath.fromArgument(key), true);
        });
        return new DocumentTransform(ref, transforms);
    }
    /**
     * Whether this DocumentTransform contains any actionable transformations.
     *
     * @private
     * @internal
     */ get isEmpty() {
        return this.transforms.size === 0;
    }
    /**
     * Returns the array of fields in this DocumentTransform.
     *
     * @private
     * @internal
     */ get fields() {
        return Array.from(this.transforms.keys());
    }
    /**
     * Validates the user provided field values in this document transform.
     * @private
     * @internal
     */ validate() {
        const allowUndefined = !!this.ref.firestore._settings.ignoreUndefinedProperties;
        this.transforms.forEach((transform)=>transform.validate(allowUndefined));
    }
    /**
     * Converts a document transform to the Firestore 'FieldTransform' Proto.
     *
     * @private
     * @internal
     * @param serializer The Firestore serializer
     * @returns A list of Firestore 'FieldTransform' Protos
     */ toProto(serializer) {
        return Array.from(this.transforms, ([path, transform])=>transform.toProto(serializer, path));
    }
}
exports.DocumentTransform = DocumentTransform;
/**
 * A Firestore Precondition encapsulates options for database writes.
 *
 * @private
 * @internal
 * @class
 */ class Precondition {
    /**
     * @private
     * @internal
     * @private
     *
     * @param options.exists - Whether the referenced document should exist in
     * Firestore,
     * @param options.lastUpdateTime - The last update time of the referenced
     * document in Firestore.
     * @param options
     */ constructor(options){
        if (options !== undefined) {
            this._exists = options.exists;
            this._lastUpdateTime = options.lastUpdateTime;
        }
    }
    /**
     * Generates the Protobuf `Preconditon` object for this precondition.
     *
     * @private
     * @internal
     * @returns The `Preconditon` Protobuf object or 'null' if there are no
     * preconditions.
     */ toProto() {
        if (this.isEmpty) {
            return null;
        }
        const proto = {};
        if (this._lastUpdateTime !== undefined) {
            proto.updateTime = this._lastUpdateTime.toProto().timestampValue;
        } else {
            proto.exists = this._exists;
        }
        return proto;
    }
    /**
     * Whether this DocumentTransform contains any enforcement.
     *
     * @private
     * @internal
     */ get isEmpty() {
        return this._exists === undefined && !this._lastUpdateTime;
    }
}
exports.Precondition = Precondition; //# sourceMappingURL=document.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/write-batch.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WriteBatch = exports.WriteResult = void 0;
exports.validateSetOptions = validateSetOptions;
exports.validateDocumentData = validateDocumentData;
exports.validateFieldValue = validateFieldValue;
const document_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const helpers_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/helpers.js [app-client] (ecmascript)");
const serializer_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/serializer.js [app-client] (ecmascript)");
const timestamp_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
/**
 * A WriteResult wraps the write time set by the Firestore servers on sets(),
 * updates(), and creates().
 *
 * @class WriteResult
 */ class WriteResult {
    /**
     * @private
     *
     * @param _writeTime The time of the corresponding document write.
     */ constructor(_writeTime){
        this._writeTime = _writeTime;
    }
    /**
     * The write time as set by the Firestore servers.
     *
     * @type {Timestamp}
     * @name WriteResult#writeTime
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.set({foo: 'bar'}).then(writeResult => {
     *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);
     * });
     * ```
     */ get writeTime() {
        return this._writeTime;
    }
    /**
     * Returns true if this `WriteResult` is equal to the provided value.
     *
     * @param {*} other The value to compare against.
     * @return true if this `WriteResult` is equal to the provided value.
     */ isEqual(other) {
        return this === other || other instanceof WriteResult && this._writeTime.isEqual(other._writeTime);
    }
}
exports.WriteResult = WriteResult;
/**
 * A Firestore WriteBatch that can be used to atomically commit multiple write
 * operations at once.
 *
 * @class WriteBatch
 */ class WriteBatch {
    /**
     * The number of writes in this batch.
     * @private
     * @internal
     */ get _opCount() {
        return this._ops.length;
    }
    /** @private */ constructor(firestore){
        /**
         * An array of document paths and the corresponding write operations that are
         * executed as part of the commit. The resulting `api.IWrite` will be sent to
         * the backend.
         *
         * @private
         * @internal
         */ this._ops = [];
        this._committed = false;
        this._firestore = firestore;
        this._serializer = new serializer_1.Serializer(firestore);
        this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;
    }
    /**
     * Checks if this write batch has any pending operations.
     *
     * @private
     * @internal
     */ get isEmpty() {
        return this._ops.length === 0;
    }
    /**
     * Throws an error if this batch has already been committed.
     *
     * @private
     * @internal
     */ verifyNotCommitted() {
        if (this._committed) {
            throw new Error('Cannot modify a WriteBatch that has been committed.');
        }
    }
    /**
     * Create a document with the provided object values. This will fail the batch
     * if a document exists at its location.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * created.
     * @param {T} data The object to serialize as the document.
     * @throws {Error} If the provided input is not a valid Firestore document.
     * @returns {WriteBatch} This WriteBatch instance. Used for chaining
     * method calls.
     *
     * @example
     * ```
     * let writeBatch = firestore.batch();
     * let documentRef = firestore.collection('col').doc();
     *
     * writeBatch.create(documentRef, {foo: 'bar'});
     *
     * writeBatch.commit().then(() => {
     *   console.log('Successfully executed batch.');
     * });
     * ```
     */ create(documentRef, data) {
        const ref = (0, helpers_1.validateDocumentReference)('documentRef', documentRef);
        const firestoreData = ref._converter.toFirestore(data);
        validateDocumentData('data', firestoreData, /* allowDeletes= */ false, this._allowUndefined);
        this.verifyNotCommitted();
        const transform = document_1.DocumentTransform.fromObject(ref, firestoreData);
        transform.validate();
        const precondition = new document_1.Precondition({
            exists: false
        });
        const op = ()=>{
            const document = document_1.DocumentSnapshot.fromObject(ref, firestoreData);
            const write = document.toWriteProto();
            if (!transform.isEmpty) {
                write.updateTransforms = transform.toProto(this._serializer);
            }
            write.currentDocument = precondition.toProto();
            return write;
        };
        this._ops.push({
            docPath: documentRef.path,
            op
        });
        return this;
    }
    /**
     * Deletes a document from the database.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * deleted.
     * @param {Precondition=} precondition A precondition to enforce for this
     * delete.
     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the
     * document was last updated at lastUpdateTime. Fails the batch if the
     * document doesn't exist or was last updated at a different time.
     * @param {boolean= } precondition.exists If set to true, enforces that the target
     * document must or must not exist.
     * @returns {WriteBatch} This WriteBatch instance. Used for chaining
     * method calls.
     *
     * @example
     * ```
     * let writeBatch = firestore.batch();
     * let documentRef = firestore.doc('col/doc');
     *
     * writeBatch.delete(documentRef);
     *
     * writeBatch.commit().then(() => {
     *   console.log('Successfully executed batch.');
     * });
     * ```
     */ delete(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    documentRef, precondition) {
        const ref = (0, helpers_1.validateDocumentReference)('documentRef', documentRef);
        validateDeletePrecondition('precondition', precondition, {
            optional: true
        });
        this.verifyNotCommitted();
        const conditions = new document_1.Precondition(precondition);
        const op = ()=>{
            const write = {
                delete: ref.formattedName
            };
            if (!conditions.isEmpty) {
                write.currentDocument = conditions.toProto();
            }
            return write;
        };
        this._ops.push({
            docPath: documentRef.path,
            op
        });
        return this;
    }
    /**
     * Write to the document referred to by the provided
     * [DocumentReference]{@link DocumentReference}. If the document does not
     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions},
     * the provided data can be merged into the existing document.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * set.
     * @param {T|Partial<T>} data The object to serialize as the document.
     * @param {SetOptions=} options An object to configure the set behavior.
     * @param {boolean=} options.merge - If true, set() merges the values
     * specified in its data argument. Fields omitted from this set() call
     * remain untouched. If your input sets any field to an empty map, all nested
     * fields are overwritten.
     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,
     * set() only replaces the specified field paths. Any field path that is no
     * specified is ignored and remains untouched. If your input sets any field to
     * an empty map, all nested fields are overwritten.
     * @throws {Error} If the provided input is not a valid Firestore document.
     * @returns {WriteBatch} This WriteBatch instance. Used for chaining
     * method calls.
     *
     * @example
     * ```
     * let writeBatch = firestore.batch();
     * let documentRef = firestore.doc('col/doc');
     *
     * writeBatch.set(documentRef, {foo: 'bar'});
     *
     * writeBatch.commit().then(() => {
     *   console.log('Successfully executed batch.');
     * });
     * ```
     */ set(documentRef, data, options) {
        validateSetOptions('options', options, {
            optional: true
        });
        const mergeLeaves = options && 'merge' in options && options.merge;
        const mergePaths = options && 'mergeFields' in options;
        const ref = (0, helpers_1.validateDocumentReference)('documentRef', documentRef);
        let firestoreData;
        if (mergeLeaves || mergePaths) {
            firestoreData = ref._converter.toFirestore(data, options);
        } else {
            firestoreData = ref._converter.toFirestore(data);
        }
        validateDocumentData('data', firestoreData, /* allowDeletes= */ !!(mergePaths || mergeLeaves), this._allowUndefined);
        this.verifyNotCommitted();
        let documentMask;
        if (mergePaths) {
            documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);
            firestoreData = documentMask.applyTo(firestoreData);
        }
        const transform = document_1.DocumentTransform.fromObject(ref, firestoreData);
        transform.validate();
        const op = ()=>{
            const document = document_1.DocumentSnapshot.fromObject(ref, firestoreData);
            if (mergePaths) {
                documentMask.removeFields(transform.fields);
            } else if (mergeLeaves) {
                documentMask = document_1.DocumentMask.fromObject(firestoreData);
            }
            const write = document.toWriteProto();
            if (!transform.isEmpty) {
                write.updateTransforms = transform.toProto(this._serializer);
            }
            if (mergePaths || mergeLeaves) {
                write.updateMask = documentMask.toProto();
            }
            return write;
        };
        this._ops.push({
            docPath: documentRef.path,
            op
        });
        return this;
    }
    /**
     * Update fields of the document referred to by the provided
     * [DocumentReference]{@link DocumentReference}. If the document
     * doesn't yet exist, the update fails and the entire batch will be rejected.
     *
     * The update() method accepts either an object with field paths encoded as
     * keys and field values encoded as values, or a variable number of arguments
     * that alternate between field paths and field values. Nested fields can be
     * updated by providing dot-separated field path strings or by providing
     * FieldPath objects.
     *
     * A Precondition restricting this update can be specified as the last
     * argument.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * updated.
     * @param {UpdateData|string|FieldPath} dataOrField An object
     * containing the fields and values with which to update the document
     * or the path of the first field to update.
     * @param {
     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -
     * An alternating list of field paths and values to update or a Precondition
     * to restrict this update.
     * @throws {Error} If the provided input is not valid Firestore data.
     * @returns {WriteBatch} This WriteBatch instance. Used for chaining
     * method calls.
     *
     * @example
     * ```
     * let writeBatch = firestore.batch();
     * let documentRef = firestore.doc('col/doc');
     *
     * writeBatch.update(documentRef, {foo: 'bar'});
     *
     * writeBatch.commit().then(() => {
     *   console.log('Successfully executed batch.');
     * });
     * ```
     */ update(documentRef, dataOrField, ...preconditionOrValues) {
        // eslint-disable-next-line prefer-rest-params
        (0, validate_1.validateMinNumberOfArguments)('WriteBatch.update', arguments, 2);
        (0, helpers_1.validateDocumentReference)('documentRef', documentRef);
        this.verifyNotCommitted();
        const updateMap = new Map();
        let precondition = new document_1.Precondition({
            exists: true
        });
        const argumentError = 'Update() requires either a single JavaScript ' + 'object or an alternating list of field/value pairs that can be ' + 'followed by an optional precondition.';
        const usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;
        if (usesVarargs) {
            const argumentOffset = 1; // Respect 'documentRef' in the error message
            const fieldOrValues = [
                dataOrField,
                ...preconditionOrValues
            ];
            try {
                for(let i = 0; i < fieldOrValues.length; i += 2){
                    if (i === fieldOrValues.length - 1) {
                        const maybePrecondition = fieldOrValues[i];
                        validateUpdatePrecondition(i + argumentOffset, maybePrecondition);
                        precondition = new document_1.Precondition(maybePrecondition);
                    } else {
                        const maybeFieldPath = fieldOrValues[i];
                        (0, path_1.validateFieldPath)(i + argumentOffset, maybeFieldPath);
                        // Unlike the `validateMinNumberOfArguments` invocation above, this
                        // validation can be triggered both from `WriteBatch.update()` and
                        // `DocumentReference.update()`. Hence, we don't use the fully
                        // qualified API name in the error message.
                        (0, validate_1.validateMinNumberOfArguments)('update', fieldOrValues, i + 1);
                        const fieldPath = path_1.FieldPath.fromArgument(maybeFieldPath);
                        validateFieldValue(i + argumentOffset, fieldOrValues[i + 1], this._allowUndefined, fieldPath);
                        updateMap.set(fieldPath, fieldOrValues[i + 1]);
                    }
                }
            } catch (err) {
                (0, logger_1.logger)('WriteBatch.update', null, 'Varargs validation failed:', err);
                // We catch the validation error here and re-throw to provide a better
                // error message.
                throw new Error(`${argumentError} ${err.message}`);
            }
        } else {
            try {
                validateUpdateMap('dataOrField', dataOrField, this._allowUndefined);
                // eslint-disable-next-line prefer-rest-params
                (0, validate_1.validateMaxNumberOfArguments)('update', arguments, 3);
                Object.entries(dataOrField).forEach(([key, value])=>{
                    // Skip `undefined` values (can be hit if `ignoreUndefinedProperties`
                    // is set)
                    if (value !== undefined) {
                        (0, path_1.validateFieldPath)(key, key);
                        updateMap.set(path_1.FieldPath.fromArgument(key), value);
                    }
                });
                if (preconditionOrValues.length > 0) {
                    validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);
                    precondition = new document_1.Precondition(preconditionOrValues[0]);
                }
            } catch (err) {
                (0, logger_1.logger)('WriteBatch.update', null, 'Non-varargs validation failed:', err);
                // We catch the validation error here and prefix the error with a custom
                // message to describe the usage of update() better.
                throw new Error(`${argumentError} ${err.message}`);
            }
        }
        validateNoConflictingFields('dataOrField', updateMap);
        const transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);
        transform.validate();
        const documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);
        const op = ()=>{
            const document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);
            const write = document.toWriteProto();
            write.updateMask = documentMask.toProto();
            if (!transform.isEmpty) {
                write.updateTransforms = transform.toProto(this._serializer);
            }
            write.currentDocument = precondition.toProto();
            return write;
        };
        this._ops.push({
            docPath: documentRef.path,
            op
        });
        return this;
    }
    /**
     * Atomically commits all pending operations to the database and verifies all
     * preconditions. Fails the entire write if any precondition is not met.
     *
     * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves
     * when this batch completes.
     *
     * @example
     * ```
     * let writeBatch = firestore.batch();
     * let documentRef = firestore.doc('col/doc');
     *
     * writeBatch.set(documentRef, {foo: 'bar'});
     *
     * writeBatch.commit().then(() => {
     *   console.log('Successfully executed batch.');
     * });
     * ```
     */ commit() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_BATCH_COMMIT, async ()=>{
            // Capture the error stack to preserve stack tracing across async calls.
            const stack = Error().stack;
            // Commits should also be retried when they fail with status code ABORTED.
            const retryCodes = [
                10 /* StatusCode.ABORTED */ ,
                ...(0, util_1.getRetryCodes)('commit')
            ];
            return this._commit({
                retryCodes
            }).then((response)=>{
                return (response.writeResults || []).map((writeResult)=>new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime)));
            }).catch((err)=>{
                throw (0, util_1.wrapError)(err, stack);
            });
        }, {
            [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: false,
            [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: this._opCount
        });
    }
    /**
     * Commit method that takes an optional transaction ID.
     *
     * @private
     * @internal
     * @param commitOptions Options to use for this commit.
     * @param commitOptions.transactionId The transaction ID of this commit.
     * @param commitOptions.requestTag A unique client-assigned identifier for
     * this request.
     * @returns  A Promise that resolves when this batch completes.
     */ async _commit(commitOptions) {
        var _a;
        // Note: We don't call `verifyNotCommitted()` to allow for retries.
        this._committed = true;
        const tag = (_a = commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.requestTag) !== null && _a !== void 0 ? _a : (0, util_1.requestTag)();
        await this._firestore.initializeIfNeeded(tag);
        // Note that the request may not always be of type ICommitRequest. This is
        // just here to ensure type safety.
        const request = {
            database: this._firestore.formattedName,
            writes: this._ops.map((op)=>op.op())
        };
        if (commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.transactionId) {
            request.transaction = commitOptions.transactionId;
        }
        (0, logger_1.logger)('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);
        return this._firestore.request((commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.methodName) || 'commit', request, tag, commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.retryCodes);
    }
    /**
     * Resets the WriteBatch and dequeues all pending operations.
     * @private
     * @internal
     */ _reset() {
        this._ops.splice(0);
        this._committed = false;
    }
}
exports.WriteBatch = WriteBatch;
/**
 * Validates the use of 'value' as a Precondition and enforces that 'exists'
 * and 'lastUpdateTime' use valid types.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The object to validate
 * @param options Options describing other things for this function to validate.
 */ function validatePrecondition(arg, value, options) {
    if (typeof value !== 'object' || value === null) {
        throw new Error('Input is not an object.');
    }
    const precondition = value;
    let conditions = 0;
    if (precondition.exists !== undefined) {
        ++conditions;
        if (typeof precondition.exists !== 'boolean') {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} "exists" is not a boolean.'`);
        }
        if ((options === null || options === void 0 ? void 0 : options.allowedExistsValues) && options.allowedExistsValues.indexOf(precondition.exists) < 0) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} ` + `"exists" is not allowed to have the value ${precondition.exists} ` + `(allowed values: ${options.allowedExistsValues.join(', ')})`);
        }
    }
    if (precondition.lastUpdateTime !== undefined) {
        ++conditions;
        if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} "lastUpdateTime" is not a Firestore Timestamp.`);
        }
    }
    if (conditions > 1) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} Input specifies more than one precondition.`);
    }
}
/**
 * Validates the use of 'value' as an update Precondition.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The object to validate.
 * @param options Optional validation options specifying whether the value can
 * be omitted.
 */ function validateUpdatePrecondition(arg, value, options) {
    if (!(0, validate_1.validateOptional)(value, options)) {
        validatePrecondition(arg, value, {
            allowedExistsValues: [
                true
            ]
        });
    }
}
/**
 * Validates the use of 'value' as a delete Precondition.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The object to validate.
 * @param options Optional validation options specifying whether the value can
 * be omitted.
 */ function validateDeletePrecondition(arg, value, options) {
    if (!(0, validate_1.validateOptional)(value, options)) {
        validatePrecondition(arg, value);
    }
}
/**
 * Validates the use of 'value' as SetOptions and enforces that 'merge' is a
 * boolean.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The object to validate.
 * @param options Optional validation options specifying whether the value can
 * be omitted.
 * @throws if the input is not a valid SetOptions object.
 */ function validateSetOptions(arg, value, options) {
    if (!(0, validate_1.validateOptional)(value, options)) {
        if (!(0, util_1.isObject)(value)) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'set() options argument')} Input is not an object.`);
        }
        const setOptions = value;
        if ('mergeFields' in setOptions) {
            for(let i = 0; i < setOptions.mergeFields.length; ++i){
                try {
                    (0, path_1.validateFieldPath)(i, setOptions.mergeFields[i]);
                } catch (err) {
                    throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'set() options argument')} "mergeFields" is not valid: ${err.message}`);
                }
            }
        }
        if ('merge' in setOptions && 'mergeFields' in setOptions) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'set() options argument')} You cannot specify both "merge" and "mergeFields".`);
        }
    }
}
/**
 * Validates a JavaScript object for usage as a Firestore document.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param obj JavaScript object to validate.
 * @param allowDeletes Whether to allow FieldValue.delete() sentinels.
 * @param allowUndefined Whether to allow nested properties that are `undefined`.
 * @throws when the object is invalid.
 */ function validateDocumentData(arg, obj, allowDeletes, allowUndefined) {
    if (!(0, util_1.isPlainObject)(obj)) {
        throw new Error((0, validate_1.customObjectMessage)(arg, obj));
    }
    (0, serializer_1.validateUserInput)(arg, obj, 'Firestore document', {
        allowDeletes: allowDeletes ? 'all' : 'none',
        allowTransforms: true,
        allowUndefined
    });
}
/**
 * Validates that a value can be used as field value during an update.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param val The value to verify.
 * @param allowUndefined Whether to allow nested properties that are `undefined`.
 * @param path The path to show in the error message.
 */ function validateFieldValue(arg, val, allowUndefined, path) {
    (0, serializer_1.validateUserInput)(arg, val, 'Firestore value', {
        allowDeletes: 'root',
        allowTransforms: true,
        allowUndefined
    }, path);
}
/**
 * Validates that the update data does not contain any ambiguous field
 * definitions (such as 'a.b' and 'a').
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param data An update map with field/value pairs.
 */ function validateNoConflictingFields(arg, data) {
    const fields = [];
    data.forEach((value, key)=>{
        fields.push(key);
    });
    fields.sort((left, right)=>left.compareTo(right));
    for(let i = 1; i < fields.length; ++i){
        if (fields[i - 1].isPrefixOf(fields[i])) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'update map')} Field "${fields[i - 1]}" was specified multiple times.`);
        }
    }
}
/**
 * Validates that a JavaScript object is a map of field paths to field values.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param obj JavaScript object to validate.
 * @param allowUndefined Whether to allow nested properties that are `undefined`.
 * @throws when the object is invalid.
 */ function validateUpdateMap(arg, obj, allowUndefined) {
    if (!(0, util_1.isPlainObject)(obj)) {
        throw new Error((0, validate_1.customObjectMessage)(arg, obj));
    }
    if (Object.keys(obj).length === 0) {
        throw new Error('At least one field must be updated.');
    }
    validateFieldValue(arg, obj, allowUndefined);
} //# sourceMappingURL=write-batch.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/bulk-writer.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BulkWriter = exports.BulkWriterError = exports.DEFAULT_JITTER_FACTOR = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = exports.RETRY_MAX_BATCH_SIZE = void 0;
const assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
const backoff_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/backoff.js [app-client] (ecmascript)");
const rate_limiter_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/rate-limiter.js [app-client] (ecmascript)");
const timestamp_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const write_batch_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/write-batch.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
/*!
 * The maximum number of writes that can be in a single batch.
 */ const MAX_BATCH_SIZE = 20;
/*!
 * The maximum number of writes can be can in a single batch that is being retried.
 */ exports.RETRY_MAX_BATCH_SIZE = 10;
/*!
 * The starting maximum number of operations per second as allowed by the
 * 500/50/5 rule.
 *
 * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.
 */ exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = 500;
/*!
 * The maximum number of operations per second as allowed by the 500/50/5 rule.
 * By default the rate limiter will not exceed this value.
 *
 * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.
 */ exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = 10000;
/*!
 * The default jitter to apply to the exponential backoff used in retries. For
 * example, a factor of 0.3 means a 30% jitter is applied.
 */ exports.DEFAULT_JITTER_FACTOR = 0.3;
/*!
 * The rate by which to increase the capacity as specified by the 500/50/5 rule.
 */ const RATE_LIMITER_MULTIPLIER = 1.5;
/*!
 * How often the operations per second capacity should increase in milliseconds
 * as specified by the 500/50/5 rule.
 */ const RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;
/*!
 * The default maximum number of pending operations that can be enqueued onto a
 * BulkWriter instance. An operation is considered pending if BulkWriter has
 * sent it via RPC and is awaiting the result. BulkWriter buffers additional
 * writes after this many pending operations in order to avoiding going OOM.
 */ const DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT = 500;
/**
 * Represents a single write for BulkWriter, encapsulating operation dispatch
 * and error handling.
 * @private
 * @internal
 */ class BulkWriterOperation {
    /**
     * @param ref The document reference being written to.
     * @param type The type of operation that created this write.
     * @param sendFn A callback to invoke when the operation should be sent.
     * @param errorFn The user provided global error callback.
     * @param successFn The user provided global success callback.
     */ constructor(ref, type, sendFn, errorFn, successFn){
        this.ref = ref;
        this.type = type;
        this.sendFn = sendFn;
        this.errorFn = errorFn;
        this.successFn = successFn;
        this.deferred = new util_1.Deferred();
        this.failedAttempts = 0;
        this._backoffDuration = 0;
        /** Whether flush() was called when this was the last enqueued operation. */ this._flushed = false;
    }
    get promise() {
        return this.deferred.promise;
    }
    get backoffDuration() {
        return this._backoffDuration;
    }
    markFlushed() {
        this._flushed = true;
    }
    get flushed() {
        return this._flushed;
    }
    onError(error) {
        ++this.failedAttempts;
        try {
            const bulkWriterError = new BulkWriterError(error.code, error.message, this.ref, this.type, this.failedAttempts);
            const shouldRetry = this.errorFn(bulkWriterError);
            (0, logger_1.logger)('BulkWriter.errorFn', null, 'Ran error callback on error code:', error.code, ', shouldRetry:', shouldRetry, ' for document:', this.ref.path);
            if (shouldRetry) {
                this.lastStatus = error.code;
                this.updateBackoffDuration();
                this.sendFn(this);
            } else {
                this.deferred.reject(bulkWriterError);
            }
        } catch (userCallbackError) {
            this.deferred.reject(userCallbackError);
        }
    }
    updateBackoffDuration() {
        if (this.lastStatus === 8 /* StatusCode.RESOURCE_EXHAUSTED */ ) {
            this._backoffDuration = backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS;
        } else if (this._backoffDuration === 0) {
            this._backoffDuration = backoff_1.DEFAULT_BACKOFF_INITIAL_DELAY_MS;
        } else {
            this._backoffDuration *= backoff_1.DEFAULT_BACKOFF_FACTOR;
        }
    }
    onSuccess(result) {
        try {
            this.successFn(this.ref, result);
            this.deferred.resolve(result);
        } catch (userCallbackError) {
            this.deferred.reject(userCallbackError);
        }
    }
}
/**
 * Used to represent a batch on the BatchQueue.
 *
 * @private
 * @internal
 */ class BulkCommitBatch extends write_batch_1.WriteBatch {
    constructor(firestore, maxBatchSize){
        super(firestore);
        // The set of document reference paths present in the WriteBatch.
        this.docPaths = new Set();
        // An array of pending write operations. Only contains writes that have not
        // been resolved.
        this.pendingOps = [];
        this._maxBatchSize = maxBatchSize;
    }
    get maxBatchSize() {
        return this._maxBatchSize;
    }
    setMaxBatchSize(size) {
        assert(this.pendingOps.length <= size, 'New batch size cannot be less than the number of enqueued writes');
        this._maxBatchSize = size;
    }
    has(documentRef) {
        return this.docPaths.has(documentRef.path);
    }
    async bulkCommit(options = {}) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_BULK_WRITER_COMMIT, async ()=>{
            var _a;
            const tag = (_a = options === null || options === void 0 ? void 0 : options.requestTag) !== null && _a !== void 0 ? _a : (0, util_1.requestTag)();
            // Capture the error stack to preserve stack tracing across async calls.
            const stack = Error().stack;
            let response;
            try {
                (0, logger_1.logger)('BulkCommitBatch.bulkCommit', tag, `Sending next batch with ${this._opCount} writes`);
                const retryCodes = (0, util_1.getRetryCodes)('batchWrite');
                response = await this._commit({
                    retryCodes,
                    methodName: 'batchWrite',
                    requestTag: tag
                });
            } catch (err) {
                // Map the failure to each individual write's result.
                const ops = Array.from({
                    length: this.pendingOps.length
                });
                response = {
                    writeResults: ops.map(()=>{
                        return {};
                    }),
                    status: ops.map(()=>err)
                };
            }
            for(let i = 0; i < (response.writeResults || []).length; ++i){
                // Since delete operations currently do not have write times, use a
                // sentinel Timestamp value.
                // TODO(b/158502664): Use actual delete timestamp.
                const DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);
                const status = (response.status || [])[i];
                if (status.code === 0 /* StatusCode.OK */ ) {
                    const updateTime = timestamp_1.Timestamp.fromProto(response.writeResults[i].updateTime || DELETE_TIMESTAMP_SENTINEL);
                    this.pendingOps[i].onSuccess(new write_batch_1.WriteResult(updateTime));
                } else {
                    const error = new (__turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)")).GoogleError(status.message || undefined);
                    error.code = status.code;
                    this.pendingOps[i].onError((0, util_1.wrapError)(error, stack));
                }
            }
        }, {
            [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: this._opCount
        });
    }
    /**
     * Helper to update data structures associated with the operation and returns
     * the result.
     */ processLastOperation(op) {
        assert(!this.docPaths.has(op.ref.path), 'Batch should not contain writes to the same document');
        this.docPaths.add(op.ref.path);
        this.pendingOps.push(op);
    }
}
/**
 * Used to represent a buffered BulkWriterOperation.
 *
 * @private
 * @internal
 */ class BufferedOperation {
    constructor(operation, sendFn){
        this.operation = operation;
        this.sendFn = sendFn;
    }
}
/**
 * The error thrown when a BulkWriter operation fails.
 *
 * @class BulkWriterError
 */ class BulkWriterError extends Error {
    /**
     * @private
     * @internal
     */ constructor(/** The status code of the error. */ code, /** The error message of the error. */ message, /** The document reference the operation was performed on. */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    documentRef, /** The type of operation performed. */ operationType, /** How many times this operation has been attempted unsuccessfully. */ failedAttempts){
        super(message);
        this.code = code;
        this.message = message;
        this.documentRef = documentRef;
        this.operationType = operationType;
        this.failedAttempts = failedAttempts;
    }
}
exports.BulkWriterError = BulkWriterError;
/**
 * A Firestore BulkWriter that can be used to perform a large number of writes
 * in parallel.
 *
 * @class BulkWriter
 */ class BulkWriter {
    // Visible for testing.
    /**
     * @private
     * @internal
     */ _getBufferedOperationsCount() {
        return this._bufferedOperations.length;
    }
    // Visible for testing.
    /**
     * @private
     * @internal
     */ _setMaxBatchSize(size) {
        assert(this._bulkCommitBatch.pendingOps.length === 0, 'BulkCommitBatch should be empty');
        this._maxBatchSize = size;
        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, size);
    }
    // Visible for testing.
    /**
     * @private
     * @internal
     */ _setMaxPendingOpCount(newMax) {
        this._maxPendingOpCount = newMax;
    }
    /** @private */ constructor(firestore, options){
        var _a, _b;
        this.firestore = firestore;
        /**
         * The maximum number of writes that can be in a single batch.
         * Visible for testing.
         * @private
         * @internal
         */ this._maxBatchSize = MAX_BATCH_SIZE;
        /**
         * The batch that is currently used to schedule operations. Once this batch
         * reaches maximum capacity, a new batch is created.
         * @private
         * @internal
         */ this._bulkCommitBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);
        /**
         * A pointer to the tail of all active BulkWriter operations. This pointer
         * is advanced every time a new write is enqueued.
         * @private
         * @internal
         */ this._lastOp = Promise.resolve();
        /**
         * The number of pending operations enqueued on this BulkWriter instance.
         * An operation is considered pending if BulkWriter has sent it via RPC and
         * is awaiting the result.
         * @private
         * @internal
         */ this._pendingOpsCount = 0;
        /**
         * An array containing buffered BulkWriter operations after the maximum number
         * of pending operations has been enqueued.
         * @private
         * @internal
         */ this._bufferedOperations = [];
        /**
         * Whether a custom error handler has been set. BulkWriter only swallows
         * errors if an error handler is set. Otherwise, an UnhandledPromiseRejection
         * is thrown by Node if an operation promise is rejected without being
         * handled.
         * @private
         * @internal
         */ this._errorHandlerSet = false;
        /**
         * The maximum number of pending operations that can be enqueued onto this
         * BulkWriter instance. Once the this number of writes have been enqueued,
         * subsequent writes are buffered.
         * @private
         * @internal
         */ this._maxPendingOpCount = DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT;
        /**
         * The user-provided callback to be run every time a BulkWriter operation
         * successfully completes.
         * @private
         * @internal
         */ this._successFn = ()=>{};
        /**
         * The user-provided callback to be run every time a BulkWriter operation
         * fails.
         * @private
         * @internal
         */ this._errorFn = (error)=>{
            const isRetryableDeleteError = error.operationType === 'delete' && error.code === 13 /* StatusCode.INTERNAL */ ;
            const retryCodes = (0, util_1.getRetryCodes)('batchWrite');
            return (retryCodes.includes(error.code) || isRetryableDeleteError) && error.failedAttempts < backoff_1.MAX_RETRY_ATTEMPTS;
        };
        this.firestore._incrementBulkWritersCount();
        validateBulkWriterOptions(options);
        if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {
            this._rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
        } else {
            let startingRate = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT;
            let maxRate = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT;
            if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {
                if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {
                    maxRate = options.throttling.maxOpsPerSecond;
                }
                if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {
                    startingRate = options.throttling.initialOpsPerSecond;
                }
                // The initial validation step ensures that the maxOpsPerSecond is
                // greater than initialOpsPerSecond. If this inequality is true, that
                // means initialOpsPerSecond was not set and maxOpsPerSecond is less
                // than the default starting rate.
                if (maxRate < startingRate) {
                    startingRate = maxRate;
                }
                // Ensure that the batch size is not larger than the number of allowed
                // operations per second.
                if (startingRate < this._maxBatchSize) {
                    this._maxBatchSize = startingRate;
                }
            }
            this._rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);
        }
    }
    /**
     * Create a document with the provided data. This single operation will fail
     * if a document exists at its location.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * created.
     * @param {T} data The object to serialize as the document.
     * @throws {Error} If the provided input is not a valid Firestore document.
     * @returns {Promise<WriteResult>} A promise that resolves with the result of
     * the write. If the write fails, the promise is rejected with a
     * [BulkWriterError]{@link BulkWriterError}.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     * let documentRef = firestore.collection('col').doc();
     *
     * bulkWriter
     *  .create(documentRef, {foo: 'bar'})
     *  .then(result => {
     *    console.log('Successfully executed write at: ', result);
     *  })
     *  .catch(err => {
     *    console.log('Write failed with: ', err);
     *  });
     * });
     * ```
     */ create(documentRef, data) {
        this._verifyNotClosed();
        return this._enqueue(documentRef, 'create', (bulkCommitBatch)=>bulkCommitBatch.create(documentRef, data));
    }
    /**
     * Delete a document from the database.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * deleted.
     * @param {Precondition=} precondition A precondition to enforce for this
     * delete.
     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the
     * document was last updated at lastUpdateTime. Fails the batch if the
     * document doesn't exist or was last updated at a different time.
     * @returns {Promise<WriteResult>} A promise that resolves with the result of
     * the delete. If the delete fails, the promise is rejected with a
     * [BulkWriterError]{@link BulkWriterError}.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     * let documentRef = firestore.doc('col/doc');
     *
     * bulkWriter
     *  .delete(documentRef)
     *  .then(result => {
     *    console.log('Successfully deleted document');
     *  })
     *  .catch(err => {
     *    console.log('Delete failed with: ', err);
     *  });
     * });
     * ```
     */ delete(documentRef, precondition) {
        this._verifyNotClosed();
        return this._enqueue(documentRef, 'delete', (bulkCommitBatch)=>bulkCommitBatch.delete(documentRef, precondition));
    }
    /**
     * Write to the document referred to by the provided
     * [DocumentReference]{@link DocumentReference}. If the document does not
     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,
     * the provided data can be merged into the existing document.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * set.
     * @param {T} data The object to serialize as the document.
     * @param {SetOptions=} options An object to configure the set behavior.
     * @throws {Error} If the provided input is not a valid Firestore document.
     * @param {boolean=} options.merge - If true, set() merges the values
     * specified in its data argument. Fields omitted from this set() call remain
     * untouched. If your input sets any field to an empty map, all nested fields
     * are overwritten.
     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()
     * only replaces the specified field paths. Any field path that is not
     * specified is ignored and remains untouched. If your input sets any field to
     * an empty map, all nested fields are overwritten.
     * @returns {Promise<WriteResult>} A promise that resolves with the result of
     * the write. If the write fails, the promise is rejected with a
     * [BulkWriterError]{@link BulkWriterError}.
     *
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     * let documentRef = firestore.collection('col').doc();
     *
     * bulkWriter
     *  .set(documentRef, {foo: 'bar'})
     *  .then(result => {
     *    console.log('Successfully executed write at: ', result);
     *  })
     *  .catch(err => {
     *    console.log('Write failed with: ', err);
     *  });
     * });
     * ```
     */ set(documentRef, data, options) {
        this._verifyNotClosed();
        return this._enqueue(documentRef, 'set', (bulkCommitBatch)=>{
            if (options) {
                return bulkCommitBatch.set(documentRef, data, options);
            } else {
                return bulkCommitBatch.set(documentRef, data);
            }
        });
    }
    /**
     * Update fields of the document referred to by the provided
     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet
     * exist, the update fails and the entire batch will be rejected.
     *
     * The update() method accepts either an object with field paths encoded as
     * keys and field values encoded as values, or a variable number of arguments
     * that alternate between field paths and field values. Nested fields can be
     * updated by providing dot-separated field path strings or by providing
     * FieldPath objects.
     *
     *
     * A Precondition restricting this update can be specified as the last
     * argument.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * updated.
     * @param {UpdateData|string|FieldPath} dataOrField An object containing the
     * fields and values with which to update the document or the path of the
     * first field to update.
     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An
     * alternating list of field paths and values to update or a Precondition to
     * restrict this update
     * @throws {Error} If the provided input is not valid Firestore data.
     * @returns {Promise<WriteResult>} A promise that resolves with the result of
     * the write. If the write fails, the promise is rejected with a
     * [BulkWriterError]{@link BulkWriterError}.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     * let documentRef = firestore.doc('col/doc');
     *
     * bulkWriter
     *  .update(documentRef, {foo: 'bar'})
     *  .then(result => {
     *    console.log('Successfully executed write at: ', result);
     *  })
     *  .catch(err => {
     *    console.log('Write failed with: ', err);
     *  });
     * });
     * ```
     */ update(documentRef, dataOrField, ...preconditionOrValues) {
        this._verifyNotClosed();
        return this._enqueue(documentRef, 'update', (bulkCommitBatch)=>bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues));
    }
    /**
     * Callback function set by {@link BulkWriter#onWriteResult} that is run
     * every time a {@link BulkWriter} operation successfully completes.
     *
     * @callback BulkWriter~successCallback
     * @param {DocumentReference} documentRef The document reference the
     * operation was performed on
     * @param {WriteResult} result The server write time of the operation.
     */ /**
     * Attaches a listener that is run every time a BulkWriter operation
     * successfully completes.
     *
     * @param {BulkWriter~successCallback} successCallback A callback to be
     * called every time a BulkWriter operation successfully completes.
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     *
     * bulkWriter
     *   .onWriteResult((documentRef, result) => {
     *     console.log(
     *       'Successfully executed write on document: ',
     *       documentRef,
     *       ' at: ',
     *       result
     *     );
     *   });
     * ```
     */ onWriteResult(successCallback) {
        this._successFn = successCallback;
    }
    /**
     * Callback function set by {@link BulkWriter#onWriteError} that is run when
     * a write fails in order to determine whether {@link BulkWriter} should
     * retry the operation.
     *
     * @callback BulkWriter~shouldRetryCallback
     * @param {BulkWriterError} error The error object with information about the
     * operation and error.
     * @returns {boolean} Whether or not to retry the failed operation. Returning
     * `true` retries the operation. Returning `false` will stop the retry loop.
     */ /**
     * Attaches an error handler listener that is run every time a BulkWriter
     * operation fails.
     *
     * BulkWriter has a default error handler that retries UNAVAILABLE and
     * ABORTED errors up to a maximum of 10 failed attempts. When an error
     * handler is specified, the default error handler will be overwritten.
     *
     * @param shouldRetryCallback {BulkWriter~shouldRetryCallback} A callback to
     * be called every time a BulkWriter operation fails. Returning `true` will
     * retry the operation. Returning `false` will stop the retry loop.
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     *
     * bulkWriter
     *   .onWriteError((error) => {
     *     if (
     *       error.code === GrpcStatus.UNAVAILABLE &&
     *       error.failedAttempts < MAX_RETRY_ATTEMPTS
     *     ) {
     *       return true;
     *     } else {
     *       console.log('Failed write at document: ', error.documentRef);
     *       return false;
     *     }
     *   });
     * ```
     */ onWriteError(shouldRetryCallback) {
        this._errorHandlerSet = true;
        this._errorFn = shouldRetryCallback;
    }
    /**
     * Commits all writes that have been enqueued up to this point in parallel.
     *
     * Returns a Promise that resolves when all currently queued operations have
     * been committed. The Promise will never be rejected since the results for
     * each individual operation are conveyed via their individual Promises.
     *
     * The Promise resolves immediately if there are no pending writes. Otherwise,
     * the Promise waits for all previously issued writes, but it does not wait
     * for writes that were added after the method is called. If you want to wait
     * for additional writes, call `flush()` again.
     *
     * @return {Promise<void>} A promise that resolves when all enqueued writes
     * up to this point have been committed.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     *
     * bulkWriter.create(documentRef, {foo: 'bar'});
     * bulkWriter.update(documentRef2, {foo: 'bar'});
     * bulkWriter.delete(documentRef3);
     * await flush().then(() => {
     *   console.log('Executed all writes');
     * });
     * ```
     */ flush() {
        this._verifyNotClosed();
        this._scheduleCurrentBatch(/* flush= */ true);
        // Mark the most recent operation as flushed to ensure that the batch
        // containing it will be sent once it's popped from the buffer.
        if (this._bufferedOperations.length > 0) {
            this._bufferedOperations[this._bufferedOperations.length - 1].operation.markFlushed();
        }
        return this._lastOp;
    }
    /**
     * Commits all enqueued writes and marks the BulkWriter instance as closed.
     *
     * After calling `close()`, calling any method will throw an error. Any
     * retries scheduled as part of an `onWriteError()` handler will be run
     * before the `close()` promise resolves.
     *
     * Returns a Promise that resolves when there are no more pending writes. The
     * Promise will never be rejected. Calling this method will send all requests.
     * The promise resolves immediately if there are no pending writes.
     *
     * @return {Promise<void>} A promise that resolves when all enqueued writes
     * up to this point have been committed.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     *
     * bulkWriter.create(documentRef, {foo: 'bar'});
     * bulkWriter.update(documentRef2, {foo: 'bar'});
     * bulkWriter.delete(documentRef3);
     * await close().then(() => {
     *   console.log('Executed all writes');
     * });
     * ```
     */ close() {
        if (!this._closePromise) {
            this._closePromise = this.flush();
            this.firestore._decrementBulkWritersCount();
        }
        return this._closePromise;
    }
    /**
     * Throws an error if the BulkWriter instance has been closed.
     * @private
     * @internal
     */ _verifyNotClosed() {
        if (this._closePromise) {
            throw new Error('BulkWriter has already been closed.');
        }
    }
    /**
     * Sends the current batch and resets `this._bulkCommitBatch`.
     *
     * @param flush If provided, keeps re-sending operations until no more
     * operations are enqueued. This allows retries to resolve as part of a
     * `flush()` or `close()` call.
     * @private
     * @internal
     */ _scheduleCurrentBatch(flush = false) {
        if (this._bulkCommitBatch._opCount === 0) return;
        const pendingBatch = this._bulkCommitBatch;
        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);
        // Use the write with the longest backoff duration when determining backoff.
        const highestBackoffDuration = pendingBatch.pendingOps.reduce((prev, cur)=>prev.backoffDuration > cur.backoffDuration ? prev : cur).backoffDuration;
        const backoffMsWithJitter = BulkWriter._applyJitter(highestBackoffDuration);
        const delayedExecution = new util_1.Deferred();
        if (backoffMsWithJitter > 0) {
            (0, backoff_1.delayExecution)(()=>delayedExecution.resolve(), backoffMsWithJitter);
        } else {
            delayedExecution.resolve();
        }
        delayedExecution.promise.then(()=>this._sendBatch(pendingBatch, flush));
    }
    /**
     * Sends the provided batch once the rate limiter does not require any delay.
     * @private
     * @internal
     */ async _sendBatch(batch, flush = false) {
        const tag = (0, util_1.requestTag)();
        // Send the batch if it is does not require any delay, or schedule another
        // attempt after the appropriate timeout.
        const underRateLimit = this._rateLimiter.tryMakeRequest(batch._opCount);
        if (underRateLimit) {
            await batch.bulkCommit({
                requestTag: tag
            });
            if (flush) this._scheduleCurrentBatch(flush);
        } else {
            const delayMs = this._rateLimiter.getNextRequestDelayMs(batch._opCount);
            (0, logger_1.logger)('BulkWriter._sendBatch', tag, `Backing off for ${delayMs} seconds`);
            (0, backoff_1.delayExecution)(()=>this._sendBatch(batch, flush), delayMs);
        }
    }
    /**
     * Adds a 30% jitter to the provided backoff.
     *
     * @private
     * @internal
     */ static _applyJitter(backoffMs) {
        if (backoffMs === 0) return 0;
        // Random value in [-0.3, 0.3].
        const jitter = exports.DEFAULT_JITTER_FACTOR * (Math.random() * 2 - 1);
        return Math.min(backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS, backoffMs + jitter * backoffMs);
    }
    /**
     * Schedules and runs the provided operation on the next available batch.
     * @private
     * @internal
     */ _enqueue(ref, type, enqueueOnBatchCallback) {
        const bulkWriterOp = new BulkWriterOperation(ref, type, this._sendFn.bind(this, enqueueOnBatchCallback), this._errorFn.bind(this), this._successFn.bind(this));
        // Swallow the error if the developer has set an error listener. This
        // prevents UnhandledPromiseRejections from being thrown if a floating
        // BulkWriter operation promise fails when an error handler is specified.
        //
        // This is done here in order to chain the caught promise onto `lastOp`,
        // which ensures that flush() resolves after the operation promise.
        const userPromise = bulkWriterOp.promise.catch((err)=>{
            if (!this._errorHandlerSet) {
                throw err;
            } else {
                return bulkWriterOp.promise;
            }
        });
        // Advance the `_lastOp` pointer. This ensures that `_lastOp` only resolves
        // when both the previous and the current write resolve.
        this._lastOp = this._lastOp.then(()=>(0, util_1.silencePromise)(userPromise));
        // Schedule the operation if the BulkWriter has fewer than the maximum
        // number of allowed pending operations, or add the operation to the
        // buffer.
        if (this._pendingOpsCount < this._maxPendingOpCount) {
            this._pendingOpsCount++;
            this._sendFn(enqueueOnBatchCallback, bulkWriterOp);
        } else {
            this._bufferedOperations.push(new BufferedOperation(bulkWriterOp, ()=>{
                this._pendingOpsCount++;
                this._sendFn(enqueueOnBatchCallback, bulkWriterOp);
            }));
        }
        // Chain the BulkWriter operation promise with the buffer processing logic
        // in order to ensure that it runs and that subsequent operations are
        // enqueued before the next batch is scheduled in `_sendBatch()`.
        return userPromise.then((res)=>{
            this._pendingOpsCount--;
            this._processBufferedOps();
            return res;
        }).catch((err)=>{
            this._pendingOpsCount--;
            this._processBufferedOps();
            throw err;
        });
    }
    /**
     * Manages the pending operation counter and schedules the next BulkWriter
     * operation if we're under the maximum limit.
     * @private
     * @internal
     */ _processBufferedOps() {
        if (this._pendingOpsCount < this._maxPendingOpCount && this._bufferedOperations.length > 0) {
            const nextOp = this._bufferedOperations.shift();
            nextOp.sendFn();
        }
    }
    /**
     * Schedules the provided operations on current BulkCommitBatch.
     * Sends the BulkCommitBatch if it reaches maximum capacity.
     *
     * @private
     * @internal
     */ _sendFn(enqueueOnBatchCallback, op) {
        // A backoff duration greater than 0 implies that this batch is a retry.
        // Retried writes are sent with a batch size of 10 in order to guarantee
        // that the batch is under the 10MiB limit.
        if (op.backoffDuration > 0) {
            if (this._bulkCommitBatch.pendingOps.length >= exports.RETRY_MAX_BATCH_SIZE) {
                this._scheduleCurrentBatch(/* flush= */ false);
            }
            this._bulkCommitBatch.setMaxBatchSize(exports.RETRY_MAX_BATCH_SIZE);
        }
        if (this._bulkCommitBatch.has(op.ref)) {
            // Create a new batch since the backend doesn't support batches with two
            // writes to the same document.
            this._scheduleCurrentBatch();
        }
        enqueueOnBatchCallback(this._bulkCommitBatch);
        this._bulkCommitBatch.processLastOperation(op);
        if (this._bulkCommitBatch._opCount === this._bulkCommitBatch.maxBatchSize) {
            this._scheduleCurrentBatch();
        } else if (op.flushed) {
            // If flush() was called before this operation was enqueued into a batch,
            // we still need to schedule it.
            this._scheduleCurrentBatch(/* flush= */ true);
        }
    }
}
exports.BulkWriter = BulkWriter;
/**
 * Validates the use of 'value' as BulkWriterOptions.
 *
 * @private
 * @internal
 * @param value The BulkWriterOptions object to validate.
 * @throws if the input is not a valid BulkWriterOptions object.
 */ function validateBulkWriterOptions(value) {
    if ((0, validate_1.validateOptional)(value, {
        optional: true
    })) {
        return;
    }
    const argName = 'options';
    if (!(0, util_1.isObject)(value)) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(argName, 'bulkWriter() options argument')} Input is not an object.`);
    }
    const options = value;
    if (options.throttling === undefined || typeof options.throttling === 'boolean') {
        return;
    }
    if (options.throttling.initialOpsPerSecond !== undefined) {
        (0, validate_1.validateInteger)('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {
            minValue: 1
        });
    }
    if (options.throttling.maxOpsPerSecond !== undefined) {
        (0, validate_1.validateInteger)('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {
            minValue: 1
        });
        if (options.throttling.initialOpsPerSecond !== undefined && options.throttling.initialOpsPerSecond > options.throttling.maxOpsPerSecond) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(argName, 'bulkWriter() options argument')} "maxOpsPerSecond" cannot be less than "initialOpsPerSecond".`);
        }
    }
} //# sourceMappingURL=bulk-writer.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/bundle.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BundleBuilder = void 0;
const document_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document.js [app-client] (ecmascript)");
const query_snapshot_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query-snapshot.js [app-client] (ecmascript)");
const timestamp_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const BUNDLE_VERSION = 1;
/**
 * Builds a Firestore data bundle with results from the given document and query snapshots.
 */ class BundleBuilder {
    constructor(bundleId){
        this.bundleId = bundleId;
        // Resulting documents for the bundle, keyed by full document path.
        this.documents = new Map();
        // Named queries saved in the bundle, keyed by query name.
        this.namedQueries = new Map();
        // The latest read time among all bundled documents and queries.
        this.latestReadTime = new timestamp_1.Timestamp(0, 0);
    }
    /**
     * Adds a Firestore document snapshot or query snapshot to the bundle.
     * Both the documents data and the query read time will be included in the bundle.
     *
     * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.
     * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.
     * @returns {BundleBuilder} This instance.
     *
     * @example
     * ```
     * const bundle = firestore.bundle('data-bundle');
     * const docSnapshot = await firestore.doc('abc/123').get();
     * const querySnapshot = await firestore.collection('coll').get();
     *
     * const bundleBuffer = bundle.add(docSnapshot) // Add a document
     *                            .add('coll-query', querySnapshot) // Add a named query.
     *                            .build()
     * // Save `bundleBuffer` to CDN or stream it to clients.
     * ```
     */ add(documentOrName, querySnapshot) {
        // eslint-disable-next-line prefer-rest-params
        (0, validate_1.validateMinNumberOfArguments)('BundleBuilder.add', arguments, 1);
        // eslint-disable-next-line prefer-rest-params
        (0, validate_1.validateMaxNumberOfArguments)('BundleBuilder.add', arguments, 2);
        if (arguments.length === 1) {
            validateDocumentSnapshot('documentOrName', documentOrName);
            this.addBundledDocument(documentOrName);
        } else {
            (0, validate_1.validateString)('documentOrName', documentOrName);
            validateQuerySnapshot('querySnapshot', querySnapshot);
            this.addNamedQuery(documentOrName, querySnapshot);
        }
        return this;
    }
    addBundledDocument(snap, queryName) {
        const originalDocument = this.documents.get(snap.ref.path);
        const originalQueries = originalDocument === null || originalDocument === void 0 ? void 0 : originalDocument.metadata.queries;
        // Update with document built from `snap` because it is newer.
        if (!originalDocument || timestamp_1.Timestamp.fromProto(originalDocument.metadata.readTime) < snap.readTime) {
            const docProto = snap.toDocumentProto();
            this.documents.set(snap.ref.path, {
                document: snap.exists ? docProto : undefined,
                metadata: {
                    name: docProto.name,
                    readTime: snap.readTime.toProto().timestampValue,
                    exists: snap.exists
                }
            });
        }
        // Update `queries` to include both original and `queryName`.
        const newDocument = this.documents.get(snap.ref.path);
        newDocument.metadata.queries = originalQueries || [];
        if (queryName) {
            newDocument.metadata.queries.push(queryName);
        }
        if (snap.readTime > this.latestReadTime) {
            this.latestReadTime = snap.readTime;
        }
    }
    addNamedQuery(name, querySnap) {
        if (this.namedQueries.has(name)) {
            throw new Error(`Query name conflict: ${name} has already been added.`);
        }
        this.namedQueries.set(name, {
            name,
            bundledQuery: querySnap.query._toBundledQuery(),
            readTime: querySnap.readTime.toProto().timestampValue
        });
        for (const snap of querySnap.docs){
            this.addBundledDocument(snap, name);
        }
        if (querySnap.readTime > this.latestReadTime) {
            this.latestReadTime = querySnap.readTime;
        }
    }
    /**
     * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation
     * of the element.
     * @private
     * @internal
     */ elementToLengthPrefixedBuffer(bundleElement) {
        // Convert to a valid proto message object then take its JSON representation.
        // This take cares of stuff like converting internal byte array fields
        // to Base64 encodings.
        // We lazy-load the Proto file to reduce cold-start times.
        const message = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/protos/firestore_v1_proto_api.js [app-client] (ecmascript)").firestore.BundleElement.fromObject(bundleElement).toJSON();
        const buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(JSON.stringify(message), 'utf-8');
        const lengthBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(buffer.length.toString());
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
            lengthBuffer,
            buffer
        ]);
    }
    build() {
        let bundleBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(0);
        for (const namedQuery of this.namedQueries.values()){
            bundleBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                bundleBuffer,
                this.elementToLengthPrefixedBuffer({
                    namedQuery
                })
            ]);
        }
        for (const bundledDocument of this.documents.values()){
            const documentMetadata = bundledDocument.metadata;
            bundleBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                bundleBuffer,
                this.elementToLengthPrefixedBuffer({
                    documentMetadata
                })
            ]);
            // Write to the bundle if document exists.
            const document = bundledDocument.document;
            if (document) {
                bundleBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                    bundleBuffer,
                    this.elementToLengthPrefixedBuffer({
                        document
                    })
                ]);
            }
        }
        const metadata = {
            id: this.bundleId,
            createTime: this.latestReadTime.toProto().timestampValue,
            version: BUNDLE_VERSION,
            totalDocuments: this.documents.size,
            totalBytes: bundleBuffer.length
        };
        // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.
        bundleBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
            this.elementToLengthPrefixedBuffer({
                metadata
            }),
            bundleBuffer
        ]);
        return bundleBuffer;
    }
}
exports.BundleBuilder = BundleBuilder;
/**
 * Convenient class to hold both the metadata and the actual content of a document to be bundled.
 * @private
 * @internal
 */ class BundledDocument {
    constructor(metadata, document){
        this.metadata = metadata;
        this.document = document;
    }
}
/**
 * Validates that 'value' is DocumentSnapshot.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 */ function validateDocumentSnapshot(arg, value) {
    if (!(value instanceof document_1.DocumentSnapshot)) {
        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'DocumentSnapshot'));
    }
}
/**
 * Validates that 'value' is QuerySnapshot.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 */ function validateQuerySnapshot(arg, value) {
    if (!(value instanceof query_snapshot_1.QuerySnapshot)) {
        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'QuerySnapshot'));
    }
} //# sourceMappingURL=bundle.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/document-reader.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2021 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DocumentReader = void 0;
const document_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
const timestamp_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
/**
 * A wrapper around BatchGetDocumentsRequest that retries request upon stream
 * failure and returns ordered results.
 *
 * @private
 * @internal
 */ class DocumentReader {
    /**
     * Creates a new DocumentReader that fetches the provided documents (via
     * `get()`).
     *
     * @param firestore The Firestore instance to use.
     * @param allDocuments The documents to get.
     * @param fieldMask An optional field mask to apply to this read
     * @param transactionOrReadTime An optional transaction ID to use for this
     * read or options for beginning a new transaction with this read
     */ constructor(firestore, allDocuments, fieldMask, transactionOrReadTime){
        this.firestore = firestore;
        this.allDocuments = allDocuments;
        this.fieldMask = fieldMask;
        this.transactionOrReadTime = transactionOrReadTime;
        this.outstandingDocuments = new Set();
        this.retrievedDocuments = new Map();
        for (const docRef of this.allDocuments){
            this.outstandingDocuments.add(docRef.formattedName);
        }
    }
    /**
     * Invokes the BatchGetDocuments RPC and returns the results as an array of
     * documents.
     *
     * @param requestTag A unique client-assigned identifier for this request.
     */ async get(requestTag) {
        const { result } = await this._get(requestTag);
        return result;
    }
    /**
     * Invokes the BatchGetDocuments RPC and returns the results with transaction
     * metadata.
     *
     * @param requestTag A unique client-assigned identifier for this request.
     */ async _get(requestTag) {
        await this.fetchDocuments(requestTag);
        // BatchGetDocuments doesn't preserve document order. We use the request
        // order to sort the resulting documents.
        const orderedDocuments = [];
        for (const docRef of this.allDocuments){
            const document = this.retrievedDocuments.get(docRef.formattedName);
            if (document !== undefined) {
                // Recreate the DocumentSnapshot with the DocumentReference
                // containing the original converter.
                const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);
                finalDoc.fieldsProto = document._fieldsProto;
                finalDoc.readTime = document.readTime;
                finalDoc.createTime = document.createTime;
                finalDoc.updateTime = document.updateTime;
                orderedDocuments.push(finalDoc.build());
            } else {
                throw new Error(`Did not receive document for "${docRef.path}".`);
            }
        }
        return {
            result: orderedDocuments,
            transaction: this.retrievedTransactionId
        };
    }
    async fetchDocuments(requestTag) {
        var _a;
        if (!this.outstandingDocuments.size) {
            return;
        }
        const request = {
            database: this.firestore.formattedName,
            documents: Array.from(this.outstandingDocuments)
        };
        if (this.transactionOrReadTime instanceof Uint8Array) {
            request.transaction = this.transactionOrReadTime;
        } else if (this.transactionOrReadTime instanceof timestamp_1.Timestamp) {
            request.readTime = this.transactionOrReadTime.toProto().timestampValue;
        } else if (this.transactionOrReadTime) {
            request.newTransaction = this.transactionOrReadTime;
        }
        if (this.fieldMask) {
            const fieldPaths = this.fieldMask.map((fieldPath)=>fieldPath.formattedName);
            request.mask = {
                fieldPaths
            };
        }
        let resultCount = 0;
        try {
            const stream = await this.firestore.requestStream('batchGetDocuments', /* bidirectional= */ false, request, requestTag);
            stream.resume();
            for await (const response of stream){
                // Proto comes with zero-length buffer by default
                if ((_a = response.transaction) === null || _a === void 0 ? void 0 : _a.length) {
                    this.retrievedTransactionId = response.transaction;
                }
                let snapshot;
                if (response.found) {
                    (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);
                    snapshot = this.firestore.snapshot_(response.found, response.readTime);
                } else if (response.missing) {
                    (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);
                    snapshot = this.firestore.snapshot_(response.missing, response.readTime);
                }
                if (snapshot) {
                    const path = snapshot.ref.formattedName;
                    this.outstandingDocuments.delete(path);
                    this.retrievedDocuments.set(path, snapshot);
                    ++resultCount;
                }
            }
        } catch (error) {
            const shouldRetry = // Transactional reads are retried via the transaction runner.
            !request.transaction && !request.newTransaction && // Only retry if we made progress.
            resultCount > 0 && // Don't retry permanent errors.
            error.code !== undefined && !(0, util_1.isPermanentRpcError)(error, 'batchGetDocuments');
            (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);
            if (shouldRetry) {
                return this.fetchDocuments(requestTag);
            } else {
                throw error;
            }
        } finally{
            (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);
        }
    }
}
exports.DocumentReader = DocumentReader; //# sourceMappingURL=document-reader.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/pool.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ClientPool = exports.CLIENT_TERMINATED_ERROR_MSG = void 0;
const assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
exports.CLIENT_TERMINATED_ERROR_MSG = 'The client has already been terminated';
/**
 * An auto-resizing pool that distributes concurrent operations over multiple
 * clients of type `T`.
 *
 * ClientPool is used within Firestore to manage a pool of GAPIC clients and
 * automatically initializes multiple clients if we issue more than 100
 * concurrent operations.
 *
 * @private
 * @internal
 */ class ClientPool {
    /**
     * @param concurrentOperationLimit The number of operations that each client
     * can handle.
     * @param maxIdleClients The maximum number of idle clients to keep before
     * garbage collecting.
     * @param clientFactory A factory function called as needed when new clients
     * are required.
     * @param clientDestructor A cleanup function that is called when a client is
     * disposed of.
     */ constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = ()=>Promise.resolve()){
        this.concurrentOperationLimit = concurrentOperationLimit;
        this.maxIdleClients = maxIdleClients;
        this.clientFactory = clientFactory;
        this.clientDestructor = clientDestructor;
        this.grpcEnabled = false;
        /**
         * Stores each active clients and how many operations it has outstanding.
         */ this.activeClients = new Map();
        /**
         * A set of clients that have seen RST_STREAM errors (see
         * https://github.com/googleapis/nodejs-firestore/issues/1023) and should
         * no longer be used.
         */ this.failedClients = new Set();
        /**
         * A mapping from "client" objects to their corresponding IDs. These IDs have
         * no semantic meaning but are used for logging to enable tracing the events
         * of a particular client over time (such as creating, acquiring, and
         * releasing).
         */ this.clientIdByClient = new WeakMap();
        /**
         * Whether the Firestore instance has been terminated. Once terminated, the
         * ClientPool can longer schedule new operations.
         */ this.terminated = false;
        /**
         * Deferred promise that is resolved when there are no active operations on
         * the client pool after terminate() has been called.
         */ this.terminateDeferred = new util_1.Deferred();
        /**
         * A unique identifier for this object, for inclusion in log messages.
         */ this.instanceId = 'cpl' + (0, util_1.requestTag)();
        this.lazyLogStringForAllClientIds = new LazyLogStringForAllClientIds({
            activeClients: this.activeClients,
            failedClients: this.failedClients,
            clientIdByClient: this.clientIdByClient
        });
    }
    /**
     * Returns an already existing client if it has less than the maximum number
     * of concurrent operations or initializes and returns a new client.
     *
     * @private
     * @internal
     */ acquire(requestTag, requiresGrpc) {
        let selectedClient = null;
        let selectedClientRequestCount = -1;
        // Transition to grpc when we see the first operation that requires grpc.
        this.grpcEnabled = this.grpcEnabled || requiresGrpc;
        // Require a grpc client for this operation if we have transitioned to grpc.
        requiresGrpc = requiresGrpc || this.grpcEnabled;
        for (const [client, metadata] of this.activeClients){
            // Use the "most-full" client that can still accommodate the request
            // in order to maximize the number of idle clients as operations start to
            // complete.
            if (!this.failedClients.has(client) && metadata.activeRequestCount > selectedClientRequestCount && metadata.activeRequestCount < this.concurrentOperationLimit && (metadata.grpcEnabled || !requiresGrpc)) {
                selectedClient = client;
                selectedClientRequestCount = metadata.activeRequestCount;
            }
        }
        if (selectedClient) {
            const selectedClientId = this.clientIdByClient.get(selectedClient);
            (0, logger_1.logger)(`ClientPool[${this.instanceId}].acquire`, requestTag, 'Re-using existing client [%s] with %s remaining operations', selectedClientId, this.concurrentOperationLimit - selectedClientRequestCount);
        } else {
            const newClientId = 'cli' + (0, util_1.requestTag)();
            (0, logger_1.logger)(`ClientPool[${this.instanceId}].acquire`, requestTag, 'Creating a new client [%s] (requiresGrpc: %s)', newClientId, requiresGrpc);
            selectedClient = this.clientFactory(requiresGrpc);
            this.clientIdByClient.set(selectedClient, newClientId);
            selectedClientRequestCount = 0;
            assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');
        }
        this.activeClients.set(selectedClient, {
            grpcEnabled: requiresGrpc,
            activeRequestCount: selectedClientRequestCount + 1
        });
        return selectedClient;
    }
    /**
     * Reduces the number of operations for the provided client, potentially
     * removing it from the pool of active clients.
     * @private
     * @internal
     */ async release(requestTag, client) {
        const clientId = this.clientIdByClient.get(client);
        const metadata = this.activeClients.get(client);
        assert(metadata && metadata.activeRequestCount > 0, 'No active requests');
        this.activeClients.set(client, {
            grpcEnabled: metadata.grpcEnabled,
            activeRequestCount: metadata.activeRequestCount - 1
        });
        if (this.terminated && this.opCount === 0) {
            this.terminateDeferred.resolve();
        }
        const gcDetermination = this.shouldGarbageCollectClient(client);
        (0, logger_1.logger)(`ClientPool[${this.instanceId}].release`, requestTag, 'Releasing client [%s] (gc=%s)', clientId, gcDetermination);
        if (!gcDetermination.shouldGarbageCollectClient) {
            return;
        }
        (0, logger_1.logger)(`ClientPool[${this.instanceId}].release`, requestTag, 'Garbage collecting client [%s] (%s)', clientId, this.lazyLogStringForAllClientIds);
        const activeClientDeleted = this.activeClients.delete(client);
        this.failedClients.delete(client);
        await this.clientDestructor(client);
        (0, logger_1.logger)(`ClientPool[${this.instanceId}].release`, requestTag, 'Garbage collected client [%s] activeClientDeleted=%s (%s)', clientId, activeClientDeleted, this.lazyLogStringForAllClientIds);
    }
    /**
     * Given the current operation counts, determines if the given client should
     * be garbage collected.
     * @private
     * @internal
     */ shouldGarbageCollectClient(client) {
        const clientMetadata = this.activeClients.get(client);
        if (clientMetadata.activeRequestCount !== 0) {
            // Don't garbage collect clients that have active requests.
            return new ClientHasActiveRequests({
                shouldGarbageCollectClient: false,
                clientActiveRequestCount: clientMetadata.activeRequestCount
            });
        }
        if (this.grpcEnabled !== clientMetadata.grpcEnabled) {
            // We are transitioning to GRPC. Garbage collect REST clients.
            return new PoolIsTransitioningToGrpc({
                shouldGarbageCollectClient: true,
                clientActiveRequestCount: clientMetadata.activeRequestCount,
                poolGrpcEnabled: this.grpcEnabled,
                clientGrpcEnabled: clientMetadata.grpcEnabled
            });
        }
        // Idle clients that have received RST_STREAM errors are always garbage
        // collected.
        if (this.failedClients.has(client)) {
            return new ClientIsFailed({
                shouldGarbageCollectClient: true,
                clientActiveRequestCount: clientMetadata.activeRequestCount
            });
        }
        // Otherwise, only garbage collect if we have too much idle capacity (e.g.
        // more than 100 idle capacity with default settings).
        let idleCapacityCount = 0;
        for (const [, metadata] of this.activeClients){
            idleCapacityCount += this.concurrentOperationLimit - metadata.activeRequestCount;
        }
        const maxIdleCapacityCount = this.maxIdleClients * this.concurrentOperationLimit;
        return new IdleCapacity({
            shouldGarbageCollectClient: idleCapacityCount > maxIdleCapacityCount,
            clientActiveRequestCount: clientMetadata.activeRequestCount,
            idleCapacityCount: idleCapacityCount,
            maxIdleCapacityCount: maxIdleCapacityCount,
            maxIdleClients: this.maxIdleClients,
            concurrentOperationLimit: this.concurrentOperationLimit
        });
    }
    /**
     * The number of currently registered clients.
     *
     * @return Number of currently registered clients.
     * @private
     * @internal
     */ // Visible for testing.
    get size() {
        return this.activeClients.size;
    }
    /**
     * The number of currently active operations.
     *
     * @return Number of currently active operations.
     * @private
     * @internal
     */ // Visible for testing.
    get opCount() {
        let activeOperationCount = 0;
        this.activeClients.forEach((metadata)=>activeOperationCount += metadata.activeRequestCount);
        return activeOperationCount;
    }
    /**
     * The currently active clients.
     *
     * @return The currently active clients.
     * @private
     * @internal
     */ // Visible for testing.
    get _activeClients() {
        return this.activeClients;
    }
    /**
     * Runs the provided operation in this pool. This function may create an
     * additional client if all existing clients already operate at the concurrent
     * operation limit.
     *
     * @param requestTag A unique client-assigned identifier for this operation.
     * @param op A callback function that returns a Promise. The client T will
     * be returned to the pool when callback finishes.
     * @return A Promise that resolves with the result of `op`.
     * @private
     * @internal
     */ run(requestTag, requiresGrpc, op) {
        if (this.terminated) {
            return Promise.reject(new Error(exports.CLIENT_TERMINATED_ERROR_MSG));
        }
        const client = this.acquire(requestTag, requiresGrpc);
        return op(client).catch(async (err)=>{
            var _a;
            if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.match(/RST_STREAM/)) {
                // Once a client has seen a RST_STREAM error, the GRPC channel can
                // no longer be used. We mark the client as failed, which ensures that
                // we open a new GRPC channel for the next request.
                this.failedClients.add(client);
            }
            await this.release(requestTag, client);
            return Promise.reject(err);
        }).then(async (res)=>{
            await this.release(requestTag, client);
            return res;
        });
    }
    async terminate() {
        this.terminated = true;
        // Wait for all pending operations to complete before terminating.
        if (this.opCount > 0) {
            (0, logger_1.logger)(`ClientPool[${this.instanceId}].terminate`, /* requestTag= */ null, 'Waiting for %s pending operations to complete before terminating (%s)', this.opCount, this.lazyLogStringForAllClientIds);
            await this.terminateDeferred.promise;
        }
        (0, logger_1.logger)(`ClientPool[${this.instanceId}].terminate`, /* requestTag= */ null, 'Closing all active clients (%s)', this.lazyLogStringForAllClientIds);
        for (const [client] of this.activeClients){
            this.activeClients.delete(client);
            await this.clientDestructor(client);
        }
    }
}
exports.ClientPool = ClientPool;
/**
 * Helper class that, when logged as a direct argument of `logger()`, will
 * lazily evaluate to a long string that contains all IDs of both active and
 * failed clients.
 */ class LazyLogStringForAllClientIds {
    constructor(config){
        this.activeClients = config.activeClients;
        this.failedClients = config.failedClients;
        this.clientIdByClient = config.clientIdByClient;
    }
    toString() {
        const activeClientsDescription = Array.from(this.activeClients.entries()).map(([client, metadata])=>`${this.clientIdByClient.get(client)}=${metadata.activeRequestCount}`).sort().join(', ');
        const failedClientsDescription = Array.from(this.failedClients).map((client)=>`${this.clientIdByClient.get(client)}`).sort().join(', ');
        return `${this.activeClients.size} active clients: {` + activeClientsDescription + '}, ' + `${this.failedClients.size} failed clients: {` + failedClientsDescription + '}';
    }
}
/**
 * Minimum data to be included in the objects returned from
 * ClientPool.shouldGarbageCollectClient().
 */ class BaseShouldGarbageCollectClientResult {
    /**
     * Return a terse, one-line string representation. This makes it easy to
     * grep through log output to find the logged values.
     */ toString() {
        const propertyStrings = [];
        for (const propertyName of Object.getOwnPropertyNames(this)){
            const propertyValue = this[propertyName];
            propertyStrings.push(`${propertyName}=${propertyValue}`);
        }
        return '{' + propertyStrings.join(', ') + '}';
    }
}
class ClientHasActiveRequests extends BaseShouldGarbageCollectClientResult {
    constructor(args){
        super();
        this.name = 'ClientHasActiveRequests';
        this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;
        this.clientActiveRequestCount = args.clientActiveRequestCount;
    }
}
class PoolIsTransitioningToGrpc extends BaseShouldGarbageCollectClientResult {
    constructor(args){
        super();
        this.name = 'PoolIsTransitioningToGrpc';
        this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;
        this.clientActiveRequestCount = args.clientActiveRequestCount;
        this.poolGrpcEnabled = args.poolGrpcEnabled;
        this.clientGrpcEnabled = args.clientGrpcEnabled;
    }
}
class ClientIsFailed extends BaseShouldGarbageCollectClientResult {
    constructor(args){
        super();
        this.name = 'ClientIsFailed';
        this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;
        this.clientActiveRequestCount = args.clientActiveRequestCount;
    }
}
class IdleCapacity extends BaseShouldGarbageCollectClientResult {
    constructor(args){
        super();
        this.name = 'IdleCapacity';
        this.shouldGarbageCollectClient = args.shouldGarbageCollectClient;
        this.clientActiveRequestCount = args.clientActiveRequestCount;
        this.idleCapacityCount = args.idleCapacityCount;
        this.maxIdleCapacityCount = args.maxIdleCapacityCount;
        this.maxIdleClients = args.maxIdleClients;
        this.concurrentOperationLimit = args.concurrentOperationLimit;
    }
} //# sourceMappingURL=pool.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/transaction.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Transaction = void 0;
exports.parseGetAllArguments = parseGetAllArguments;
const backoff_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/backoff.js [app-client] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/index.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const aggregate_query_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/aggregate-query.js [app-client] (ecmascript)");
const document_reference_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js [app-client] (ecmascript)");
const query_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query.js [app-client] (ecmascript)");
const helpers_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/helpers.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const document_reader_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document-reader.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
/*!
 * Error message for transactional reads that were executed after performing
 * writes.
 */ const READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';
const READ_ONLY_WRITE_ERROR_MSG = 'Firestore read-only transactions cannot execute writes.';
/**
 * A reference to a transaction.
 *
 * The Transaction object passed to a transaction's updateFunction provides
 * the methods to read and write data within the transaction context. See
 * [runTransaction()]{@link Firestore#runTransaction}.
 *
 * @class Transaction
 */ class Transaction {
    /**
     * @private
     *
     * @param firestore The Firestore Database client.
     * @param requestTag A unique client-assigned identifier for the scope of
     * this transaction.
     * @param transactionOptions The user-defined options for this transaction.
     */ constructor(firestore, requestTag, transactionOptions){
        this._maxAttempts = index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;
        this._firestore = firestore;
        this._requestTag = requestTag;
        if (transactionOptions === null || transactionOptions === void 0 ? void 0 : transactionOptions.readOnly) {
            // Avoid initialising write batch and backoff unnecessarily for read-only transactions
            this._maxAttempts = 1;
            this._readOnlyReadTime = transactionOptions.readTime;
        } else {
            this._maxAttempts = (transactionOptions === null || transactionOptions === void 0 ? void 0 : transactionOptions.maxAttempts) || index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;
            this._writeBatch = firestore.batch();
            this._backoff = new backoff_1.ExponentialBackoff();
        }
    }
    /**
     * Retrieve a document or a query result from the database. Holds a
     * pessimistic lock on all returned documents.
     *
     * @param {DocumentReference|Query} refOrQuery The document or query to
     * return.
     * @returns {Promise} A Promise that resolves with a DocumentSnapshot or
     * QuerySnapshot for the returned documents.
     *
     * @example
     * ```
     * firestore.runTransaction(transaction => {
     *   let documentRef = firestore.doc('col/doc');
     *   return transaction.get(documentRef).then(doc => {
     *     if (doc.exists) {
     *       transaction.update(documentRef, { count: doc.get('count') + 1 });
     *     } else {
     *       transaction.create(documentRef, { count: 1 });
     *     }
     *   });
     * });
     * ```
     */ get(refOrQuery) {
        if (this._writeBatch && !this._writeBatch.isEmpty) {
            throw new Error(READ_AFTER_WRITE_ERROR_MSG);
        }
        if (refOrQuery instanceof document_reference_1.DocumentReference) {
            return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_GET_DOCUMENT, ()=>{
                return this.withLazyStartedTransaction(refOrQuery, this.getSingleFn);
            });
        }
        if (refOrQuery instanceof query_1.Query || refOrQuery instanceof aggregate_query_1.AggregateQuery) {
            return this._firestore._traceUtil.startActiveSpan(refOrQuery instanceof query_1.Query ? trace_util_1.SPAN_NAME_TRANSACTION_GET_QUERY : trace_util_1.SPAN_NAME_TRANSACTION_GET_AGGREGATION_QUERY, ()=>{
                return this.withLazyStartedTransaction(refOrQuery, this.getQueryFn);
            });
        }
        throw new Error('Value for argument "refOrQuery" must be a DocumentReference, Query, or AggregateQuery.');
    }
    /**
     * Retrieves multiple documents from Firestore. Holds a pessimistic lock on
     * all returned documents.
     *
     * The first argument is required and must be of type `DocumentReference`
     * followed by any additional `DocumentReference` documents. If used, the
     * optional `ReadOptions` must be the last argument.
     *
     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The
     * `DocumentReferences` to receive, followed by an optional field mask.
     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that
     * contains an array with the resulting document snapshots.
     *
     * @example
     * ```
     * let firstDoc = firestore.doc('col/doc1');
     * let secondDoc = firestore.doc('col/doc2');
     * let resultDoc = firestore.doc('col/doc3');
     *
     * firestore.runTransaction(transaction => {
     *   return transaction.getAll(firstDoc, secondDoc).then(docs => {
     *     transaction.set(resultDoc, {
     *       sum: docs[0].get('count') + docs[1].get('count')
     *     });
     *   });
     * });
     * ```
     */ getAll(...documentRefsOrReadOptions) {
        if (this._writeBatch && !this._writeBatch.isEmpty) {
            throw new Error(READ_AFTER_WRITE_ERROR_MSG);
        }
        (0, validate_1.validateMinNumberOfArguments)('Transaction.getAll', documentRefsOrReadOptions, 1);
        return this.withLazyStartedTransaction(parseGetAllArguments(documentRefsOrReadOptions), this.getBatchFn);
    }
    /**
     * Create the document referred to by the provided
     * [DocumentReference]{@link DocumentReference}. The operation will
     * fail the transaction if a document exists at the specified location.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * created.
     * @param {DocumentData} data The object data to serialize as the document.
     * @returns {Transaction} This Transaction instance. Used for
     * chaining method calls.
     *
     * @example
     * ```
     * firestore.runTransaction(transaction => {
     *   let documentRef = firestore.doc('col/doc');
     *   return transaction.get(documentRef).then(doc => {
     *     if (!doc.exists) {
     *       transaction.create(documentRef, { foo: 'bar' });
     *     }
     *   });
     * });
     * ```
     */ create(documentRef, data) {
        if (!this._writeBatch) {
            throw new Error(READ_ONLY_WRITE_ERROR_MSG);
        }
        this._writeBatch.create(documentRef, data);
        return this;
    }
    /**
     * Writes to the document referred to by the provided
     * [DocumentReference]{@link DocumentReference}. If the document
     * does not exist yet, it will be created. If you pass
     * [SetOptions]{@link SetOptions}, the provided data can be merged into the
     * existing document.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * set.
     * @param {T|Partial<T>} data The object to serialize as the document.
     * @param {SetOptions=} options An object to configure the set behavior.
     * @param {boolean=} options.merge - If true, set() merges the values
     * specified in its data argument. Fields omitted from this set() call remain
     * untouched. If your input sets any field to an empty map, all nested fields
     * are overwritten.
     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,
     * set() only replaces the specified field paths. Any field path that is not
     * specified is ignored and remains untouched. If your input sets any field to
     * an empty map, all nested fields are overwritten.
     * @throws {Error} If the provided input is not a valid Firestore document.
     * @returns {Transaction} This Transaction instance. Used for
     * chaining method calls.
     *
     * @example
     * ```
     * firestore.runTransaction(transaction => {
     *   let documentRef = firestore.doc('col/doc');
     *   transaction.set(documentRef, { foo: 'bar' });
     *   return Promise.resolve();
     * });
     * ```
     */ set(documentRef, data, options) {
        if (!this._writeBatch) {
            throw new Error(READ_ONLY_WRITE_ERROR_MSG);
        }
        if (options) {
            this._writeBatch.set(documentRef, data, options);
        } else {
            this._writeBatch.set(documentRef, data);
        }
        return this;
    }
    /**
     * Updates fields in the document referred to by the provided
     * [DocumentReference]{@link DocumentReference}. The update will
     * fail if applied to a document that does not exist.
     *
     * The update() method accepts either an object with field paths encoded as
     * keys and field values encoded as values, or a variable number of arguments
     * that alternate between field paths and field values. Nested fields can be
     * updated by providing dot-separated field path strings or by providing
     * FieldPath objects.
     *
     * A Precondition restricting this update can be specified as the last
     * argument.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * updated.
     * @param {UpdateData|string|FieldPath} dataOrField An object
     * containing the fields and values with which to update the document
     * or the path of the first field to update.
     * @param {
     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -
     * An alternating list of field paths and values to update or a Precondition
     * to to enforce on this update.
     * @throws {Error} If the provided input is not valid Firestore data.
     * @returns {Transaction} This Transaction instance. Used for
     * chaining method calls.
     *
     * @example
     * ```
     * firestore.runTransaction(transaction => {
     *   let documentRef = firestore.doc('col/doc');
     *   return transaction.get(documentRef).then(doc => {
     *     if (doc.exists) {
     *       transaction.update(documentRef, { count: doc.get('count') + 1 });
     *     } else {
     *       transaction.create(documentRef, { count: 1 });
     *     }
     *   });
     * });
     * ```
     */ update(documentRef, dataOrField, ...preconditionOrValues) {
        if (!this._writeBatch) {
            throw new Error(READ_ONLY_WRITE_ERROR_MSG);
        }
        // eslint-disable-next-line prefer-rest-params
        (0, validate_1.validateMinNumberOfArguments)('Transaction.update', arguments, 2);
        this._writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);
        return this;
    }
    /**
     * Deletes the document referred to by the provided [DocumentReference]
     * {@link DocumentReference}.
     *
     * @param {DocumentReference} documentRef A reference to the document to be
     * deleted.
     * @param {Precondition=} precondition A precondition to enforce for this
     * delete.
     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the
     * document was last updated at lastUpdateTime. Fails the transaction if the
     * document doesn't exist or was last updated at a different time.
     * @param {boolean=} precondition.exists If set, enforces that the target
     * document must or must not exist.
     * @returns {Transaction} This Transaction instance. Used for
     * chaining method calls.
     *
     * @example
     * ```
     * firestore.runTransaction(transaction => {
     *   let documentRef = firestore.doc('col/doc');
     *   transaction.delete(documentRef);
     *   return Promise.resolve();
     * });
     * ```
     */ delete(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    documentRef, precondition) {
        if (!this._writeBatch) {
            throw new Error(READ_ONLY_WRITE_ERROR_MSG);
        }
        this._writeBatch.delete(documentRef, precondition);
        return this;
    }
    /**
     * Commits all queued-up changes in this transaction and releases all locks.
     *
     * @private
     * @internal
     */ async commit() {
        var _a;
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_COMMIT, async ()=>{
            if (!this._writeBatch) {
                throw new Error(READ_ONLY_WRITE_ERROR_MSG);
            }
            // If we have not performed any reads in this particular attempt
            // then the writes will be atomically committed without a transaction ID
            let transactionId;
            if (this._transactionIdPromise) {
                transactionId = await this._transactionIdPromise;
            } else if (this._writeBatch.isEmpty) {
                // If we have not started a transaction (no reads) and we have no writes
                // then the commit is a no-op (success)
                return;
            }
            await this._writeBatch._commit({
                transactionId,
                requestTag: this._requestTag
            });
            this._transactionIdPromise = undefined;
            this._prevTransactionId = transactionId;
        }, {
            [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: true,
            [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: (_a = this._writeBatch) === null || _a === void 0 ? void 0 : _a._opCount
        });
    }
    /**
     * Releases all locks and rolls back this transaction. The rollback process
     * is completed asynchronously and this function resolves before the operation
     * is completed.
     *
     * @private
     * @internal
     */ async rollback() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_ROLLBACK, async ()=>{
            // No need to roll back if we have not lazily started the transaction
            // or if we are read only
            if (!this._transactionIdPromise || !this._writeBatch) {
                return;
            }
            let transactionId;
            try {
                transactionId = await this._transactionIdPromise;
            } catch (_a) {
                // This means the initial read operation rejected
                // and we do not have a transaction ID to roll back
                this._transactionIdPromise = undefined;
                return;
            }
            const request = {
                database: this._firestore.formattedName,
                transaction: transactionId
            };
            this._transactionIdPromise = undefined;
            this._prevTransactionId = transactionId;
            // We don't need to wait for rollback to completed before continuing.
            // If there are any locks held, then rollback will eventually release them.
            // Rollback can be done concurrently thereby reducing latency caused by
            // otherwise blocking.
            this._firestore.request('rollback', request, this._requestTag).catch((err)=>{
                (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Best effort to rollback failed with error:', err);
            });
        });
    }
    /**
     * Executes `updateFunction()` and commits the transaction with retry.
     *
     * @private
     * @internal
     * @param updateFunction The user function to execute within the transaction
     * context.
     */ async runTransaction(updateFunction) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_RUN, async (span)=>{
            // No backoff is set for readonly transactions (i.e. attempts == 1)
            if (!this._writeBatch) {
                return this.runTransactionOnce(updateFunction);
            }
            let lastError = undefined;
            for(let attempt = 0; attempt < this._maxAttempts; ++attempt){
                span.setAttributes({
                    [trace_util_1.ATTRIBUTE_KEY_TRANSACTION_TYPE]: this._writeBatch ? 'READ_WRITE' : 'READ_ONLY',
                    [trace_util_1.ATTRIBUTE_KEY_ATTEMPTS_ALLOWED]: this._maxAttempts,
                    [trace_util_1.ATTRIBUTE_KEY_ATTEMPTS_REMAINING]: this._maxAttempts - attempt - 1
                });
                try {
                    if (lastError) {
                        (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Retrying transaction after error:', lastError);
                        span.addEvent('Initiate transaction retry');
                    }
                    this._writeBatch._reset();
                    await maybeBackoff(this._backoff, lastError);
                    return await this.runTransactionOnce(updateFunction);
                } catch (err) {
                    lastError = err;
                    if (!isRetryableTransactionError(err)) {
                        break;
                    }
                }
            }
            (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);
            return Promise.reject(lastError);
        });
    }
    /**
     * Make single attempt to execute `updateFunction()` and commit the
     * transaction. Will rollback upon error.
     *
     * @private
     * @internal
     * @param updateFunction The user function to execute within the transaction
     * context.
     */ async runTransactionOnce(updateFunction) {
        try {
            const promise = updateFunction(this);
            if (!(promise instanceof Promise)) {
                throw new Error('You must return a Promise in your transaction()-callback.');
            }
            const result = await promise;
            if (this._writeBatch) {
                await this.commit();
            }
            return result;
        } catch (err) {
            (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', err);
            await this.rollback();
            return Promise.reject(err);
        }
    }
    /**
     * Given a function that performs a read operation, ensures that the first one
     * is provided with new transaction options and all subsequent ones are queued
     * upon the resulting transaction ID.
     */ withLazyStartedTransaction(param, resultFn) {
        if (this._transactionIdPromise) {
            // Simply queue this subsequent read operation after the first read
            // operation has resolved and we don't expect a transaction ID in the
            // response because we are not starting a new transaction
            return this._transactionIdPromise.then((opts)=>resultFn.call(this, param, opts)).then((r)=>r.result);
        } else {
            if (this._readOnlyReadTime) {
                // We do not start a transaction for read-only transactions
                // do not set _prevTransactionId
                return resultFn.call(this, param, this._readOnlyReadTime).then((r)=>r.result);
            } else {
                // This is the first read of the transaction so we create the appropriate
                // options for lazily starting the transaction inside this first read op
                const opts = {};
                if (this._writeBatch) {
                    opts.readWrite = this._prevTransactionId ? {
                        retryTransaction: this._prevTransactionId
                    } : {};
                } else {
                    opts.readOnly = {};
                }
                const resultPromise = resultFn.call(this, param, opts);
                // Ensure the _transactionIdPromise is set synchronously so that
                // subsequent operations will not race to start another transaction
                this._transactionIdPromise = resultPromise.then((r)=>{
                    if (!r.transaction) {
                        // Illegal state
                        // The read operation was provided with new transaction options but did not return a transaction ID
                        // Rejecting here will cause all queued reads to reject
                        throw new Error('Transaction ID was missing from server response');
                    }
                    return r.transaction;
                });
                return resultPromise.then((r)=>r.result);
            }
        }
    }
    async getSingleFn(document, opts) {
        const documentReader = new document_reader_1.DocumentReader(this._firestore, [
            document
        ], undefined, opts);
        const { transaction, result: [result] } = await documentReader._get(this._requestTag);
        return {
            transaction,
            result
        };
    }
    async getBatchFn({ documents, fieldMask }, opts) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_GET_DOCUMENTS, async ()=>{
            const documentReader = new document_reader_1.DocumentReader(this._firestore, documents, fieldMask, opts);
            return documentReader._get(this._requestTag);
        });
    }
    async getQueryFn(query, opts) {
        return query._get(opts);
    }
}
exports.Transaction = Transaction;
/**
 * Parses the arguments for the `getAll()` call supported by both the Firestore
 * and Transaction class.
 *
 * @private
 * @internal
 * @param documentRefsOrReadOptions An array of document references followed by
 * an optional ReadOptions object.
 */ function parseGetAllArguments(documentRefsOrReadOptions) {
    let documents;
    let readOptions = undefined;
    if (Array.isArray(documentRefsOrReadOptions[0])) {
        throw new Error('getAll() no longer accepts an array as its first argument. ' + 'Please unpack your array and call getAll() with individual arguments.');
    }
    if (documentRefsOrReadOptions.length > 0 && (0, util_1.isPlainObject)(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {
        readOptions = documentRefsOrReadOptions.pop();
        documents = documentRefsOrReadOptions;
    } else {
        documents = documentRefsOrReadOptions;
    }
    for(let i = 0; i < documents.length; ++i){
        (0, helpers_1.validateDocumentReference)(i, documents[i]);
    }
    validateReadOptions('options', readOptions, {
        optional: true
    });
    const fieldMask = readOptions && readOptions.fieldMask ? readOptions.fieldMask.map((fieldPath)=>path_1.FieldPath.fromArgument(fieldPath)) : undefined;
    return {
        fieldMask,
        documents
    };
}
/**
 * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'
 * is an array of strings or field paths.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the ReadOptions can be omitted.
 */ function validateReadOptions(arg, value, options) {
    if (!(0, validate_1.validateOptional)(value, options)) {
        if (!(0, util_1.isObject)(value)) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} Input is not an object.'`);
        }
        const options = value;
        if (options.fieldMask !== undefined) {
            if (!Array.isArray(options.fieldMask)) {
                throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} "fieldMask" is not an array.`);
            }
            for(let i = 0; i < options.fieldMask.length; ++i){
                try {
                    (0, path_1.validateFieldPath)(i, options.fieldMask[i]);
                } catch (err) {
                    throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} "fieldMask" is not valid: ${err.message}`);
                }
            }
        }
    }
}
function isRetryableTransactionError(error) {
    if (error.code !== undefined) {
        // This list is based on https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/transaction_runner.ts#L112
        switch(error.code){
            case 10 /* StatusCode.ABORTED */ :
            case 1 /* StatusCode.CANCELLED */ :
            case 2 /* StatusCode.UNKNOWN */ :
            case 4 /* StatusCode.DEADLINE_EXCEEDED */ :
            case 13 /* StatusCode.INTERNAL */ :
            case 14 /* StatusCode.UNAVAILABLE */ :
            case 16 /* StatusCode.UNAUTHENTICATED */ :
            case 8 /* StatusCode.RESOURCE_EXHAUSTED */ :
                return true;
            case 3 /* StatusCode.INVALID_ARGUMENT */ :
                // The Firestore backend uses "INVALID_ARGUMENT" for transactions
                // IDs that have expired. While INVALID_ARGUMENT is generally not
                // retryable, we retry this specific case.
                return !!error.message.match(/transaction has expired/);
            default:
                return false;
        }
    }
    return false;
}
/**
 * Delays further operations based on the provided error.
 *
 * @private
 * @internal
 * @return A Promise that resolves after the delay expired.
 */ async function maybeBackoff(backoff, error) {
    if ((error === null || error === void 0 ? void 0 : error.code) === 8 /* StatusCode.RESOURCE_EXHAUSTED */ ) {
        backoff.resetToMax();
    }
    await backoff.backoffAndWait();
} //# sourceMappingURL=transaction.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/query-partition.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryPartition = void 0;
const field_order_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/field-order.js [app-client] (ecmascript)");
const query_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query.js [app-client] (ecmascript)");
const query_options_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query-options.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const serializer_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/serializer.js [app-client] (ecmascript)");
/**
 * A split point that can be used in a query as a starting and/or end point for
 * the query results. The cursors returned by {@link #startAt} and {@link
 * #endBefore} can only be used in a query that matches the constraint of query
 * that produced this partition.
 *
 * @class QueryPartition
 */ class QueryPartition {
    /** @private */ constructor(_firestore, _collectionId, _converter, _startAt, _endBefore){
        this._firestore = _firestore;
        this._collectionId = _collectionId;
        this._converter = _converter;
        this._startAt = _startAt;
        this._endBefore = _endBefore;
        this._serializer = new serializer_1.Serializer(_firestore);
    }
    /**
     * The cursor that defines the first result for this partition or `undefined`
     * if this is the first partition. The cursor value must be
     * destructured when passed to `startAt()` (for example with
     * `query.startAt(...queryPartition.startAt)`).
     *
     * @example
     * ```
     * const query = firestore.collectionGroup('collectionId');
     * for await (const partition of query.getPartitions(42)) {
     *   let partitionedQuery = query.orderBy(FieldPath.documentId());
     *   if (partition.startAt) {
     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);
     *   }
     *   if (partition.endBefore) {
     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);
     *   }
     *   const querySnapshot = await partitionedQuery.get();
     *   console.log(`Partition contained ${querySnapshot.length} documents`);
     * }
     *
     * ```
     * @type {Array<*>}
     * @return {Array<*>} A cursor value that can be used with {@link
     * Query#startAt} or `undefined` if this is the first partition.
     */ get startAt() {
        if (this._startAt && !this._memoizedStartAt) {
            this._memoizedStartAt = this._startAt.map((v)=>this._serializer.decodeValue(v));
        }
        return this._memoizedStartAt;
    }
    /**
     * The cursor that defines the first result after this partition or
     * `undefined` if this is the last partition.  The cursor value must be
     * destructured when passed to `endBefore()` (for example with
     * `query.endBefore(...queryPartition.endBefore)`).
     *
     * @example
     * ```
     * const query = firestore.collectionGroup('collectionId');
     * for await (const partition of query.getPartitions(42)) {
     *   let partitionedQuery = query.orderBy(FieldPath.documentId());
     *   if (partition.startAt) {
     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);
     *   }
     *   if (partition.endBefore) {
     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);
     *   }
     *   const querySnapshot = await partitionedQuery.get();
     *   console.log(`Partition contained ${querySnapshot.length} documents`);
     * }
     *
     * ```
     * @type {Array<*>}
     * @return {Array<*>} A cursor value that can be used with {@link
     * Query#endBefore} or `undefined` if this is the last partition.
     */ get endBefore() {
        if (this._endBefore && !this._memoizedEndBefore) {
            this._memoizedEndBefore = this._endBefore.map((v)=>this._serializer.decodeValue(v));
        }
        return this._memoizedEndBefore;
    }
    /**
     * Returns a query that only encapsulates the documents for this partition.
     *
     * @example
     * ```
     * const query = firestore.collectionGroup('collectionId');
     * for await (const partition of query.getPartitions(42)) {
     *   const partitionedQuery = partition.toQuery();
     *   const querySnapshot = await partitionedQuery.get();
     *   console.log(`Partition contained ${querySnapshot.length} documents`);
     * }
     *
     * ```
     * @return {Query<T>} A query partitioned by a {@link Query#startAt} and
     * {@link Query#endBefore} cursor.
     */ toQuery() {
        // Since the api.Value to JavaScript type conversion can be lossy (unless
        // `useBigInt` is used), we pass the original protobuf representation to the
        // created query.
        let queryOptions = query_options_1.QueryOptions.forCollectionGroupQuery(this._collectionId, this._converter);
        queryOptions = queryOptions.with({
            fieldOrders: [
                new field_order_1.FieldOrder(path_1.FieldPath.documentId())
            ]
        });
        if (this._startAt !== undefined) {
            queryOptions = queryOptions.with({
                startAt: {
                    before: true,
                    values: this._startAt
                }
            });
        }
        if (this._endBefore !== undefined) {
            queryOptions = queryOptions.with({
                endAt: {
                    before: true,
                    values: this._endBefore
                }
            });
        }
        return new query_1.Query(this._firestore, queryOptions);
    }
}
exports.QueryPartition = QueryPartition; //# sourceMappingURL=query-partition.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/collection-group.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CollectionGroup = void 0;
const query_partition_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/query-partition.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
const query_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query.js [app-client] (ecmascript)");
const query_options_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query-options.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/types.js [app-client] (ecmascript)");
const order_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/order.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
/**
 * A `CollectionGroup` refers to all documents that are contained in a
 * collection or subcollection with a specific collection ID.
 *
 * @class CollectionGroup
 */ class CollectionGroup extends query_1.Query {
    /** @private */ constructor(firestore, collectionId, converter){
        super(firestore, query_options_1.QueryOptions.forCollectionGroupQuery(collectionId, converter));
    }
    /**
     * Partitions a query by returning partition cursors that can be used to run
     * the query in parallel. The returned cursors are split points that can be
     * used as starting and end points for individual query invocations.
     *
     * @example
     * ```
     * const query = firestore.collectionGroup('collectionId');
     * for await (const partition of query.getPartitions(42)) {
     *   const partitionedQuery = partition.toQuery();
     *   const querySnapshot = await partitionedQuery.get();
     *   console.log(`Partition contained ${querySnapshot.length} documents`);
     * }
     *
     * ```
     * @param {number} desiredPartitionCount The desired maximum number of
     * partition points. The number must be strictly positive. The actual number
     * of partitions returned may be fewer.
     * @return {AsyncIterable<QueryPartition>} An AsyncIterable of
     * `QueryPartition`s.
     */ async *getPartitions(desiredPartitionCount) {
        const partitions = [];
        await this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_PARTITION_QUERY, async ()=>{
            var _a;
            (0, validate_1.validateInteger)('desiredPartitionCount', desiredPartitionCount, {
                minValue: 1
            });
            const tag = (0, util_1.requestTag)();
            await this.firestore.initializeIfNeeded(tag);
            if (desiredPartitionCount > 1) {
                // Partition queries require explicit ordering by __name__.
                const queryWithDefaultOrder = this.orderBy(path_1.FieldPath.documentId());
                const request = queryWithDefaultOrder.toProto();
                // Since we are always returning an extra partition (with an empty endBefore
                // cursor), we reduce the desired partition count by one.
                request.partitionCount = desiredPartitionCount - 1;
                const stream = await this.firestore.requestStream('partitionQueryStream', /* bidirectional= */ false, request, tag);
                stream.resume();
                for await (const currentCursor of stream){
                    partitions.push((_a = currentCursor.values) !== null && _a !== void 0 ? _a : []);
                }
            }
            (0, logger_1.logger)('Firestore.getPartitions', tag, 'Received %d partitions', partitions.length);
            // Sort the partitions as they may not be ordered if responses are paged.
            partitions.sort((l, r)=>(0, order_1.compareArrays)(l, r));
        });
        for(let i = 0; i < partitions.length; ++i){
            yield new query_partition_1.QueryPartition(this._firestore, this._queryOptions.collectionId, this._queryOptions.converter, i > 0 ? partitions[i - 1] : undefined, partitions[i]);
        }
        // Return the extra partition with the empty cursor.
        yield new query_partition_1.QueryPartition(this._firestore, this._queryOptions.collectionId, this._queryOptions.converter, partitions.pop(), undefined);
    }
    withConverter(converter) {
        return new CollectionGroup(this.firestore, this._queryOptions.collectionId, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());
    }
}
exports.CollectionGroup = CollectionGroup; //# sourceMappingURL=collection-group.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/recursive-delete.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecursiveDelete = exports.RECURSIVE_DELETE_MIN_PENDING_OPS = exports.RECURSIVE_DELETE_MAX_PENDING_OPS = exports.REFERENCE_NAME_MIN_ID = void 0;
const assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
const _1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/index.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const query_options_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query-options.js [app-client] (ecmascript)");
/*!
 * Datastore allowed numeric IDs where Firestore only allows strings. Numeric
 * IDs are exposed to Firestore as __idNUM__, so this is the lowest possible
 * negative numeric value expressed in that format.
 *
 * This constant is used to specify startAt/endAt values when querying for all
 * descendants in a single collection.
 */ exports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';
/*!
 * The query limit used for recursive deletes when fetching all descendants of
 * the specified reference to delete. This is done to prevent the query stream
 * from streaming documents faster than Firestore can delete.
 */ // Visible for testing.
exports.RECURSIVE_DELETE_MAX_PENDING_OPS = 5000;
/*!
 * The number of pending BulkWriter operations at which RecursiveDelete
 * starts the next limit query to fetch descendants. By starting the query
 * while there are pending operations, Firestore can improve BulkWriter
 * throughput. This helps prevent BulkWriter from idling while Firestore
 * fetches the next query.
 */ exports.RECURSIVE_DELETE_MIN_PENDING_OPS = 1000;
/**
 * Class used to store state required for running a recursive delete operation.
 * Each recursive delete call should use a new instance of the class.
 * @private
 * @internal
 */ class RecursiveDelete {
    /**
     *
     * @param firestore The Firestore instance to use.
     * @param writer The BulkWriter instance to use for delete operations.
     * @param ref The document or collection reference to recursively delete.
     * @param maxLimit The query limit to use when fetching descendants
     * @param minLimit The number of pending BulkWriter operations at which
     * RecursiveDelete starts the next limit query to fetch descendants.
     */ constructor(firestore, writer, ref, maxLimit, minLimit){
        this.firestore = firestore;
        this.writer = writer;
        this.ref = ref;
        this.maxLimit = maxLimit;
        this.minLimit = minLimit;
        /**
         * The number of deletes that failed with a permanent error.
         * @private
         * @internal
         */ this.errorCount = 0;
        /**
         * Whether there are still documents to delete that still need to be fetched.
         * @private
         * @internal
         */ this.documentsPending = true;
        /**
         * Whether run() has been called.
         * @private
         * @internal
         */ this.started = false;
        /**
         * A deferred promise that resolves when the recursive delete operation
         * is completed.
         * @private
         * @internal
         */ this.completionDeferred = new util_1.Deferred();
        /**
         * Whether a query stream is currently in progress. Only one stream can be
         * run at a time.
         * @private
         * @internal
         */ this.streamInProgress = false;
        /**
         * The number of pending BulkWriter operations. Used to determine when the
         * next query can be run.
         * @private
         * @internal
         */ this.pendingOpsCount = 0;
        this.errorStack = '';
        this.maxPendingOps = maxLimit;
        this.minPendingOps = minLimit;
    }
    /**
     * Recursively deletes the reference provided in the class constructor.
     * Returns a promise that resolves when all descendants have been deleted, or
     * if an error occurs.
     */ run() {
        assert(!this.started, 'RecursiveDelete.run() should only be called once.');
        // Capture the error stack to preserve stack tracing across async calls.
        this.errorStack = Error().stack;
        this.writer._verifyNotClosed();
        this.setupStream();
        return this.completionDeferred.promise;
    }
    /**
     * Creates a query stream and attaches event handlers to it.
     * @private
     * @internal
     */ setupStream() {
        const stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference ? this.ref : this.ref);
        this.streamInProgress = true;
        let streamedDocsCount = 0;
        stream.on('error', (err)=>{
            err.code = 14 /* StatusCode.UNAVAILABLE */ ;
            err.stack = 'Failed to fetch children documents: ' + err.stack;
            this.lastError = err;
            this.onQueryEnd();
        }).on('data', (snap)=>{
            streamedDocsCount++;
            this.lastDocumentSnap = snap;
            this.deleteRef(snap.ref);
        }).on('end', ()=>{
            this.streamInProgress = false;
            // If there are fewer than the number of documents specified in the
            // limit() field, we know that the query is complete.
            if (streamedDocsCount < this.minPendingOps) {
                this.onQueryEnd();
            } else if (this.pendingOpsCount === 0) {
                this.setupStream();
            }
        });
    }
    /**
     * Retrieves all descendant documents nested under the provided reference.
     * @param ref The reference to fetch all descendants for.
     * @private
     * @internal
     * @return {Stream<QueryDocumentSnapshot>} Stream of descendant documents.
     */ getAllDescendants(ref) {
        // The parent is the closest ancestor document to the location we're
        // deleting. If we are deleting a document, the parent is the path of that
        // document. If we are deleting a collection, the parent is the path of the
        // document containing that collection (or the database root, if it is a
        // root collection).
        let parentPath = ref._resourcePath;
        if (ref instanceof _1.CollectionReference) {
            parentPath = parentPath.popLast();
        }
        const collectionId = ref instanceof _1.CollectionReference ? ref.id : ref.parent.id;
        let query = new _1.Query(this.firestore, query_options_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId, /* requireConsistency= */ false));
        // Query for names only to fetch empty snapshots.
        query = query.select(_1.FieldPath.documentId()).limit(this.maxPendingOps);
        if (ref instanceof _1.CollectionReference) {
            // To find all descendants of a collection reference, we need to use a
            // composite filter that captures all documents that start with the
            // collection prefix. The MIN_KEY constant represents the minimum key in
            // this collection, and a null byte + the MIN_KEY represents the minimum
            // key is the next possible collection.
            const nullChar = String.fromCharCode(0);
            const startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;
            const endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;
            query = query.where(_1.FieldPath.documentId(), '>=', startAt).where(_1.FieldPath.documentId(), '<', endAt);
        }
        if (this.lastDocumentSnap) {
            query = query.startAfter(this.lastDocumentSnap);
        }
        return query.stream();
    }
    /**
     * Called when all descendants of the provided reference have been streamed
     * or if a permanent error occurs during the stream. Deletes the developer
     * provided reference and wraps any errors that occurred.
     * @private
     * @internal
     */ onQueryEnd() {
        this.documentsPending = false;
        if (this.ref instanceof _1.DocumentReference) {
            this.writer.delete(this.ref).catch((err)=>this.incrementErrorCount(err));
        }
        this.writer.flush().then(async ()=>{
            var _a;
            if (this.lastError === undefined) {
                this.completionDeferred.resolve();
            } else {
                let error = new (__turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)")).GoogleError(`${this.errorCount} ` + `${this.errorCount !== 1 ? 'deletes' : 'delete'} ` + 'failed. The last delete failed with: ');
                if (this.lastError.code !== undefined) {
                    error.code = this.lastError.code;
                }
                error = (0, util_1.wrapError)(error, this.errorStack);
                // Wrap the BulkWriter error last to provide the full stack trace.
                this.completionDeferred.reject(this.lastError.stack ? (0, util_1.wrapError)(error, (_a = this.lastError.stack) !== null && _a !== void 0 ? _a : '') : error);
            }
        });
    }
    /**
     * Deletes the provided reference and starts the next stream if conditions
     * are met.
     * @private
     * @internal
     */ deleteRef(docRef) {
        this.pendingOpsCount++;
        this.writer.delete(docRef).catch((err)=>{
            this.incrementErrorCount(err);
        }).then(()=>{
            this.pendingOpsCount--;
            // We wait until the previous stream has ended in order to sure the
            // startAfter document is correct. Starting the next stream while
            // there are pending operations allows Firestore to maximize
            // BulkWriter throughput.
            if (this.documentsPending && !this.streamInProgress && this.pendingOpsCount < this.minPendingOps) {
                this.setupStream();
            }
        });
    }
    incrementErrorCount(err) {
        this.errorCount++;
        this.lastError = err;
    }
}
exports.RecursiveDelete = RecursiveDelete; //# sourceMappingURL=recursive-delete.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/telemetry/span.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Span = void 0;
/**
 * @private
 * @internal
 */ class Span {
    constructor(span){
        this.span = span;
    }
    end() {
        var _a;
        (_a = this.span) === null || _a === void 0 ? void 0 : _a.end();
    }
    addEvent(name, attributes) {
        var _a;
        this.span = (_a = this.span) === null || _a === void 0 ? void 0 : _a.addEvent(name, attributes);
        return this;
    }
    setAttributes(attributes) {
        var _a;
        this.span = (_a = this.span) === null || _a === void 0 ? void 0 : _a.setAttributes(attributes);
        return this;
    }
}
exports.Span = Span; //# sourceMappingURL=span.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/telemetry/disabled-trace-util.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DisabledTraceUtil = void 0;
const span_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/span.js [app-client] (ecmascript)");
/**
 * @private
 * @internal
 */ class DisabledTraceUtil {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    startSpan(name) {
        return new span_1.Span();
    }
    startActiveSpan(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    name, fn, // eslint-disable-next-line @typescript-eslint/no-unused-vars
    attributes) {
        const emptySpan = new span_1.Span();
        return fn(emptySpan);
    }
    currentSpan() {
        return new span_1.Span();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    recordProjectId(projectId) {}
}
exports.DisabledTraceUtil = DisabledTraceUtil; //# sourceMappingURL=disabled-trace-util.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client_config.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"interfaces\":{\"google.firestore.admin.v1.FirestoreAdmin\":{\"retry_codes\":{\"non_idempotent\":[],\"idempotent\":[\"DEADLINE_EXCEEDED\",\"UNAVAILABLE\"],\"deadline_exceeded_internal_unavailable\":[\"DEADLINE_EXCEEDED\",\"INTERNAL\",\"UNAVAILABLE\"]},\"retry_params\":{\"default\":{\"initial_retry_delay_millis\":100,\"retry_delay_multiplier\":1.3,\"max_retry_delay_millis\":60000,\"initial_rpc_timeout_millis\":60000,\"rpc_timeout_multiplier\":1,\"max_rpc_timeout_millis\":60000,\"total_timeout_millis\":600000}},\"methods\":{\"CreateIndex\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListIndexes\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"GetIndex\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"DeleteIndex\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"GetField\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"UpdateField\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListFields\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"ExportDocuments\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ImportDocuments\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"BulkDeleteDocuments\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"CreateDatabase\":{\"timeout_millis\":120000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"GetDatabase\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListDatabases\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateDatabase\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"DeleteDatabase\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"GetBackup\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListBackups\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"DeleteBackup\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"RestoreDatabase\":{\"timeout_millis\":120000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"CreateBackupSchedule\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"GetBackupSchedule\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListBackupSchedules\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateBackupSchedule\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"DeleteBackupSchedule\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"}}}}}"));}}),
"[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FirestoreAdminClient = void 0;
const jsonProtos = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/protos/admin_v1.json (json)");
/**
 * Client JSON configuration object, loaded from
 * `src/v1/firestore_admin_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */ const gapicConfig = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client_config.json (json)");
const version = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/package.json (json)").version;
/**
 *  The Cloud Firestore Admin API.
 *
 *  This API provides several administrative services for Cloud Firestore.
 *
 *  Project, Database, Namespace, Collection, Collection Group, and Document are
 *  used as defined in the Google Cloud Firestore API.
 *
 *  Operation: An Operation represents work being performed in the background.
 *
 *  The index service manages Cloud Firestore indexes.
 *
 *  Index creation is performed asynchronously.
 *  An Operation resource is created for each such asynchronous operation.
 *  The state of the operation (including any errors encountered)
 *  may be queried via the Operation resource.
 *
 *  The Operations collection provides a record of actions performed for the
 *  specified Project (including any Operations in progress). Operations are not
 *  created directly but through calls on other collections or resources.
 *
 *  An Operation that is done may be deleted so that it is no longer listed as
 *  part of the Operation collection. Operations are garbage collected after
 *  30 days. By default, ListOperations will only return in progress and failed
 *  operations. To list completed operation, issue a ListOperations request with
 *  the filter `done: true`.
 *
 *  Operations are created by service `FirestoreAdmin`, but are accessed via
 *  service `google.longrunning.Operations`.
 * @class
 * @memberof v1
 */ class FirestoreAdminClient {
    /**
     * Construct an instance of FirestoreAdminClient.
     *
     * @param {object} [options] - The configuration object.
     * The options accepted by the constructor are described in detail
     * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).
     * The common options are:
     * @param {object} [options.credentials] - Credentials object.
     * @param {string} [options.credentials.client_email]
     * @param {string} [options.credentials.private_key]
     * @param {string} [options.email] - Account email address. Required when
     *     using a .pem or .p12 keyFilename.
     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
     *     .p12 key downloaded from the Google Developers Console. If you provide
     *     a path to a JSON file, the projectId option below is not necessary.
     *     NOTE: .pem and .p12 require you to specify options.email as well.
     * @param {number} [options.port] - The port on which to connect to
     *     the remote host.
     * @param {string} [options.projectId] - The project ID from the Google
     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
     *     the environment variable GCLOUD_PROJECT for your project ID. If your
     *     app is running in an environment which supports
     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
     *     your project ID will be detected automatically.
     * @param {string} [options.apiEndpoint] - The domain name of the
     *     API remote host.
     * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
     *     Follows the structure of {@link gapicConfig}.
     * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.
     *     For more information, please check the
     *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.
     * @param {gax} [gaxInstance]: loaded instance of `google-gax`. Useful if you
     *     need to avoid loading the default gRPC version and want to use the fallback
     *     HTTP implementation. Load only fallback version and pass it to the constructor:
     *     ```
     *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC
     *     const client = new FirestoreAdminClient({fallback: true}, gax);
     *     ```
     */ constructor(opts, gaxInstance){
        var _a, _b, _c, _d, _e;
        this._terminated = false;
        this.descriptors = {
            page: {},
            stream: {},
            longrunning: {},
            batching: {}
        };
        // Ensure that options include all the required fields.
        const staticMembers = this.constructor;
        if ((opts === null || opts === void 0 ? void 0 : opts.universe_domain) && (opts === null || opts === void 0 ? void 0 : opts.universeDomain) && (opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== (opts === null || opts === void 0 ? void 0 : opts.universeDomain)) {
            throw new Error('Please set either universe_domain or universeDomain, but not both.');
        }
        const universeDomainEnvVar = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env === 'object' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] : undefined;
        this._universeDomain = (_c = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.universeDomain) !== null && _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== null && _b !== void 0 ? _b : universeDomainEnvVar) !== null && _c !== void 0 ? _c : 'googleapis.com';
        this._servicePath = 'firestore.' + this._universeDomain;
        const servicePath = (opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint) || this._servicePath;
        this._providedCustomServicePath = !!((opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint));
        const port = (opts === null || opts === void 0 ? void 0 : opts.port) || staticMembers.port;
        const clientConfig = (_d = opts === null || opts === void 0 ? void 0 : opts.clientConfig) !== null && _d !== void 0 ? _d : {};
        const fallback = (_e = opts === null || opts === void 0 ? void 0 : opts.fallback) !== null && _e !== void 0 ? _e : typeof window !== 'undefined' && typeof (window === null || window === void 0 ? void 0 : window.fetch) === 'function';
        opts = Object.assign({
            servicePath,
            port,
            clientConfig,
            fallback
        }, opts);
        // Request numeric enum values if REST transport is used.
        opts.numericEnums = true;
        // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
        if (servicePath !== this._servicePath && !('scopes' in opts)) {
            opts['scopes'] = staticMembers.scopes;
        }
        // Load google-gax module synchronously if needed
        if (!gaxInstance) {
            gaxInstance = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)");
        }
        // Choose either gRPC or proto-over-HTTP implementation of google-gax.
        this._gaxModule = opts.fallback ? gaxInstance.fallback : gaxInstance;
        // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);
        // Save options to use in initialize() method.
        this._opts = opts;
        // Save the auth object to the client, for use by other methods.
        this.auth = this._gaxGrpc.auth;
        // Set useJWTAccessWithScope on the auth object.
        this.auth.useJWTAccessWithScope = true;
        // Set defaultServicePath on the auth object.
        this.auth.defaultServicePath = this._servicePath;
        // Set the default scopes in auth client if needed.
        if (servicePath === this._servicePath) {
            this.auth.defaultScopes = staticMembers.scopes;
        }
        this.locationsClient = new this._gaxModule.LocationsClient(this._gaxGrpc, opts);
        // Determine the client header string.
        const clientHeader = [
            `gax/${this._gaxModule.version}`,
            `gapic/${version}`
        ];
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && 'versions' in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            clientHeader.push(`gl-node/${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node}`);
        } else {
            clientHeader.push(`gl-web/${this._gaxModule.version}`);
        }
        if (!opts.fallback) {
            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
        } else {
            clientHeader.push(`rest/${this._gaxGrpc.grpcVersion}`);
        }
        if (opts.libName && opts.libVersion) {
            clientHeader.push(`${opts.libName}/${opts.libVersion}`);
        }
        // Load the applicable protos.
        this._protos = this._gaxGrpc.loadProtoJSON(jsonProtos);
        // This API contains "path templates"; forward-slash-separated
        // identifiers to uniquely identify resources within the API.
        // Create useful helper objects for these.
        this.pathTemplates = {
            backupPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}/backups/{backup}'),
            backupSchedulePathTemplate: new this._gaxModule.PathTemplate('projects/{project}/databases/{database}/backupSchedules/{backup_schedule}'),
            collectionGroupPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/databases/{database}/collectionGroups/{collection}'),
            databasePathTemplate: new this._gaxModule.PathTemplate('projects/{project}/databases/{database}'),
            fieldPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/databases/{database}/collectionGroups/{collection}/fields/{field}'),
            indexPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/databases/{database}/collectionGroups/{collection}/indexes/{index}'),
            locationPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}'),
            projectPathTemplate: new this._gaxModule.PathTemplate('projects/{project}')
        };
        // Some of the methods on this service return "paged" results,
        // (e.g. 50 results at a time, with tokens to get subsequent
        // pages). Denote the keys used for pagination and results.
        this.descriptors.page = {
            listIndexes: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'indexes'),
            listFields: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'fields')
        };
        const protoFilesRoot = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
        // This API contains "long-running operations", which return a
        // an Operation object that allows for tracking of the operation,
        // rather than holding a request open.
        const lroOptions = {
            auth: this.auth,
            grpc: 'grpc' in this._gaxGrpc ? this._gaxGrpc.grpc : undefined
        };
        if (opts.fallback) {
            lroOptions.protoJson = protoFilesRoot;
            lroOptions.httpRules = [
                {
                    selector: 'google.longrunning.Operations.CancelOperation',
                    post: '/v1/{name=projects/*/databases/*/operations/*}:cancel',
                    body: '*'
                },
                {
                    selector: 'google.longrunning.Operations.DeleteOperation',
                    delete: '/v1/{name=projects/*/databases/*/operations/*}'
                },
                {
                    selector: 'google.longrunning.Operations.GetOperation',
                    get: '/v1/{name=projects/*/databases/*/operations/*}'
                },
                {
                    selector: 'google.longrunning.Operations.ListOperations',
                    get: '/v1/{name=projects/*/databases/*}/operations'
                }
            ];
        }
        this.operationsClient = this._gaxModule.lro(lroOptions).operationsClient(opts);
        const createIndexResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.Index');
        const createIndexMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.IndexOperationMetadata');
        const updateFieldResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.Field');
        const updateFieldMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.FieldOperationMetadata');
        const exportDocumentsResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.ExportDocumentsResponse');
        const exportDocumentsMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.ExportDocumentsMetadata');
        const importDocumentsResponse = protoFilesRoot.lookup('.google.protobuf.Empty');
        const importDocumentsMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.ImportDocumentsMetadata');
        const bulkDeleteDocumentsResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.BulkDeleteDocumentsResponse');
        const bulkDeleteDocumentsMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.BulkDeleteDocumentsMetadata');
        const createDatabaseResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.Database');
        const createDatabaseMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.CreateDatabaseMetadata');
        const updateDatabaseResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.Database');
        const updateDatabaseMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.UpdateDatabaseMetadata');
        const deleteDatabaseResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.Database');
        const deleteDatabaseMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.DeleteDatabaseMetadata');
        const restoreDatabaseResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.Database');
        const restoreDatabaseMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.RestoreDatabaseMetadata');
        this.descriptors.longrunning = {
            createIndex: new this._gaxModule.LongrunningDescriptor(this.operationsClient, createIndexResponse.decode.bind(createIndexResponse), createIndexMetadata.decode.bind(createIndexMetadata)),
            updateField: new this._gaxModule.LongrunningDescriptor(this.operationsClient, updateFieldResponse.decode.bind(updateFieldResponse), updateFieldMetadata.decode.bind(updateFieldMetadata)),
            exportDocuments: new this._gaxModule.LongrunningDescriptor(this.operationsClient, exportDocumentsResponse.decode.bind(exportDocumentsResponse), exportDocumentsMetadata.decode.bind(exportDocumentsMetadata)),
            importDocuments: new this._gaxModule.LongrunningDescriptor(this.operationsClient, importDocumentsResponse.decode.bind(importDocumentsResponse), importDocumentsMetadata.decode.bind(importDocumentsMetadata)),
            bulkDeleteDocuments: new this._gaxModule.LongrunningDescriptor(this.operationsClient, bulkDeleteDocumentsResponse.decode.bind(bulkDeleteDocumentsResponse), bulkDeleteDocumentsMetadata.decode.bind(bulkDeleteDocumentsMetadata)),
            createDatabase: new this._gaxModule.LongrunningDescriptor(this.operationsClient, createDatabaseResponse.decode.bind(createDatabaseResponse), createDatabaseMetadata.decode.bind(createDatabaseMetadata)),
            updateDatabase: new this._gaxModule.LongrunningDescriptor(this.operationsClient, updateDatabaseResponse.decode.bind(updateDatabaseResponse), updateDatabaseMetadata.decode.bind(updateDatabaseMetadata)),
            deleteDatabase: new this._gaxModule.LongrunningDescriptor(this.operationsClient, deleteDatabaseResponse.decode.bind(deleteDatabaseResponse), deleteDatabaseMetadata.decode.bind(deleteDatabaseMetadata)),
            restoreDatabase: new this._gaxModule.LongrunningDescriptor(this.operationsClient, restoreDatabaseResponse.decode.bind(restoreDatabaseResponse), restoreDatabaseMetadata.decode.bind(restoreDatabaseMetadata))
        };
        // Put together the default options sent with requests.
        this._defaults = this._gaxGrpc.constructSettings('google.firestore.admin.v1.FirestoreAdmin', gapicConfig, opts.clientConfig || {}, {
            'x-goog-api-client': clientHeader.join(' ')
        });
        // Set up a dictionary of "inner API calls"; the core implementation
        // of calling the API is handled in `google-gax`, with this code
        // merely providing the destination and request information.
        this.innerApiCalls = {};
        // Add a warn function to the client constructor so it can be easily tested.
        this.warn = this._gaxModule.warn;
    }
    /**
     * Initialize the client.
     * Performs asynchronous operations (such as authentication) and prepares the client.
     * This function will be called automatically when any class method is called for the
     * first time, but if you need to initialize it before calling an actual method,
     * feel free to call initialize() directly.
     *
     * You can await on this method if you want to make sure the client is initialized.
     *
     * @returns {Promise} A promise that resolves to an authenticated service stub.
     */ initialize() {
        // If the client stub promise is already initialized, return immediately.
        if (this.firestoreAdminStub) {
            return this.firestoreAdminStub;
        }
        // Put together the "service stub" for
        // google.firestore.admin.v1.FirestoreAdmin.
        this.firestoreAdminStub = this._gaxGrpc.createStub(this._opts.fallback ? this._protos.lookupService('google.firestore.admin.v1.FirestoreAdmin') : this._protos.google.firestore.admin.v1.FirestoreAdmin, this._opts, this._providedCustomServicePath);
        // Iterate over each of the methods that the service provides
        // and create an API call method for each.
        const firestoreAdminStubMethods = [
            'createIndex',
            'listIndexes',
            'getIndex',
            'deleteIndex',
            'getField',
            'updateField',
            'listFields',
            'exportDocuments',
            'importDocuments',
            'bulkDeleteDocuments',
            'createDatabase',
            'getDatabase',
            'listDatabases',
            'updateDatabase',
            'deleteDatabase',
            'getBackup',
            'listBackups',
            'deleteBackup',
            'restoreDatabase',
            'createBackupSchedule',
            'getBackupSchedule',
            'listBackupSchedules',
            'updateBackupSchedule',
            'deleteBackupSchedule'
        ];
        for (const methodName of firestoreAdminStubMethods){
            const callPromise = this.firestoreAdminStub.then((stub)=>(...args)=>{
                    if (this._terminated) {
                        return Promise.reject('The client has already been closed.');
                    }
                    const func = stub[methodName];
                    return func.apply(stub, args);
                }, (err)=>()=>{
                    throw err;
                });
            const descriptor = this.descriptors.page[methodName] || this.descriptors.longrunning[methodName] || undefined;
            const apiCall = this._gaxModule.createApiCall(callPromise, this._defaults[methodName], descriptor, this._opts.fallback);
            this.innerApiCalls[methodName] = apiCall;
        }
        return this.firestoreAdminStub;
    }
    /**
     * The DNS address for this API service.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get servicePath() {
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning === 'function') {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning('Static servicePath is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'firestore.googleapis.com';
    }
    /**
     * The DNS address for this API service - same as servicePath.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get apiEndpoint() {
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning === 'function') {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning('Static apiEndpoint is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'firestore.googleapis.com';
    }
    /**
     * The DNS address for this API service.
     * @returns {string} The DNS address for this service.
     */ get apiEndpoint() {
        return this._servicePath;
    }
    get universeDomain() {
        return this._universeDomain;
    }
    /**
     * The port for this API service.
     * @returns {number} The default port for this service.
     */ static get port() {
        return 443;
    }
    /**
     * The scopes needed to make gRPC calls for every method defined
     * in this service.
     * @returns {string[]} List of default scopes.
     */ static get scopes() {
        return [
            'https://www.googleapis.com/auth/cloud-platform',
            'https://www.googleapis.com/auth/datastore'
        ];
    }
    /**
     * Return the project ID used by this class.
     * @returns {Promise} A promise that resolves to string containing the project ID.
     */ getProjectId(callback) {
        if (callback) {
            this.auth.getProjectId(callback);
            return;
        }
        return this.auth.getProjectId();
    }
    getIndex(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getIndex(request, options, callback);
    }
    deleteIndex(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteIndex(request, options, callback);
    }
    getField(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getField(request, options, callback);
    }
    getDatabase(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getDatabase(request, options, callback);
    }
    listDatabases(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listDatabases(request, options, callback);
    }
    getBackup(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getBackup(request, options, callback);
    }
    listBackups(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listBackups(request, options, callback);
    }
    deleteBackup(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteBackup(request, options, callback);
    }
    createBackupSchedule(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.createBackupSchedule(request, options, callback);
    }
    getBackupSchedule(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getBackupSchedule(request, options, callback);
    }
    listBackupSchedules(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listBackupSchedules(request, options, callback);
    }
    updateBackupSchedule(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'backup_schedule.name': (_a = request.backupSchedule.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateBackupSchedule(request, options, callback);
    }
    deleteBackupSchedule(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteBackupSchedule(request, options, callback);
    }
    createIndex(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.createIndex(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `createIndex()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.create_index.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_CreateIndex_async
     */ async checkCreateIndexProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.createIndex, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    updateField(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'field.name': (_a = request.field.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateField(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `updateField()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.update_field.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_UpdateField_async
     */ async checkUpdateFieldProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.updateField, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    exportDocuments(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.exportDocuments(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `exportDocuments()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.export_documents.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_ExportDocuments_async
     */ async checkExportDocumentsProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.exportDocuments, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    importDocuments(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.importDocuments(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `importDocuments()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.import_documents.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_ImportDocuments_async
     */ async checkImportDocumentsProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.importDocuments, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    bulkDeleteDocuments(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.bulkDeleteDocuments(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `bulkDeleteDocuments()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.bulk_delete_documents.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_BulkDeleteDocuments_async
     */ async checkBulkDeleteDocumentsProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.bulkDeleteDocuments, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    createDatabase(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.createDatabase(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `createDatabase()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.create_database.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_CreateDatabase_async
     */ async checkCreateDatabaseProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.createDatabase, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    updateDatabase(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'database.name': (_a = request.database.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateDatabase(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `updateDatabase()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.update_database.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_UpdateDatabase_async
     */ async checkUpdateDatabaseProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.updateDatabase, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    deleteDatabase(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteDatabase(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `deleteDatabase()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.delete_database.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_DeleteDatabase_async
     */ async checkDeleteDatabaseProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.deleteDatabase, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    restoreDatabase(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.restoreDatabase(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `restoreDatabase()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.restore_database.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_RestoreDatabase_async
     */ async checkRestoreDatabaseProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.restoreDatabase, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    listIndexes(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listIndexes(request, options, callback);
    }
    /**
     * Equivalent to `listIndexes`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. A parent name of the form
     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
     * @param {string} request.filter
     *   The filter to apply to list results.
     * @param {number} request.pageSize
     *   The number of results to return.
     * @param {string} request.pageToken
     *   A page token, returned from a previous call to
     *   {@link protos.google.firestore.admin.v1.FirestoreAdmin.ListIndexes|FirestoreAdmin.ListIndexes},
     *   that may be used to get the next page of results.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.firestore.admin.v1.Index|Index} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listIndexesAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listIndexesStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listIndexes'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listIndexes.createStream(this.innerApiCalls.listIndexes, request, callSettings);
    }
    /**
     * Equivalent to `listIndexes`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. A parent name of the form
     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
     * @param {string} request.filter
     *   The filter to apply to list results.
     * @param {number} request.pageSize
     *   The number of results to return.
     * @param {string} request.pageToken
     *   A page token, returned from a previous call to
     *   {@link protos.google.firestore.admin.v1.FirestoreAdmin.ListIndexes|FirestoreAdmin.ListIndexes},
     *   that may be used to get the next page of results.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.firestore.admin.v1.Index|Index}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.list_indexes.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_ListIndexes_async
     */ listIndexesAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listIndexes'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listIndexes.asyncIterate(this.innerApiCalls['listIndexes'], request, callSettings);
    }
    listFields(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listFields(request, options, callback);
    }
    /**
     * Equivalent to `listFields`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. A parent name of the form
     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
     * @param {string} request.filter
     *   The filter to apply to list results. Currently,
     *   {@link protos.google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields}
     *   only supports listing fields that have been explicitly overridden. To issue
     *   this query, call
     *   {@link protos.google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields}
     *   with a filter that includes `indexConfig.usesAncestorConfig:false` or
     *   `ttlConfig:*`.
     * @param {number} request.pageSize
     *   The number of results to return.
     * @param {string} request.pageToken
     *   A page token, returned from a previous call to
     *   {@link protos.google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields},
     *   that may be used to get the next page of results.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.firestore.admin.v1.Field|Field} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listFieldsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listFieldsStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listFields'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listFields.createStream(this.innerApiCalls.listFields, request, callSettings);
    }
    /**
     * Equivalent to `listFields`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. A parent name of the form
     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
     * @param {string} request.filter
     *   The filter to apply to list results. Currently,
     *   {@link protos.google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields}
     *   only supports listing fields that have been explicitly overridden. To issue
     *   this query, call
     *   {@link protos.google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields}
     *   with a filter that includes `indexConfig.usesAncestorConfig:false` or
     *   `ttlConfig:*`.
     * @param {number} request.pageSize
     *   The number of results to return.
     * @param {string} request.pageToken
     *   A page token, returned from a previous call to
     *   {@link protos.google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields},
     *   that may be used to get the next page of results.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.firestore.admin.v1.Field|Field}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore_admin.list_fields.js</caption>
     * region_tag:firestore_v1_generated_FirestoreAdmin_ListFields_async
     */ listFieldsAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listFields'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listFields.asyncIterate(this.innerApiCalls['listFields'], request, callSettings);
    }
    /**
     * Gets information about a location.
     *
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.name
     *   Resource name for the location.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html | CallOptions} for more details.
     * @returns {Promise} - The promise which resolves to an array.
     *   The first element of the array is an object representing {@link google.cloud.location.Location | Location}.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
     *   for more details and examples.
     * @example
     * ```
     * const [response] = await client.getLocation(request);
     * ```
     */ getLocation(request, options, callback) {
        return this.locationsClient.getLocation(request, options, callback);
    }
    /**
     * Lists information about the supported locations for this service. Returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.name
     *   The resource that owns the locations collection, if applicable.
     * @param {string} request.filter
     *   The standard list filter.
     * @param {number} request.pageSize
     *   The standard list page size.
     * @param {string} request.pageToken
     *   The standard list page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link google.cloud.location.Location | Location}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example
     * ```
     * const iterable = client.listLocationsAsync(request);
     * for await (const response of iterable) {
     *   // process response
     * }
     * ```
     */ listLocationsAsync(request, options) {
        return this.locationsClient.listLocationsAsync(request, options);
    }
    /**
     * Gets the latest state of a long-running operation.  Clients can use this
     * method to poll the operation result at intervals as recommended by the API
     * service.
     *
     * @param {Object} request - The request object that will be sent.
     * @param {string} request.name - The name of the operation resource.
     * @param {Object=} options
     *   Optional parameters. You can override the default settings for this call,
     *   e.g, timeout, retries, paginations, etc. See {@link
     *   https://googleapis.github.io/gax-nodejs/global.html#CallOptions | gax.CallOptions}
     *   for the details.
     * @param {function(?Error, ?Object)=} callback
     *   The function which will be called with the result of the API call.
     *
     *   The second parameter to the callback is an object representing
     *   {@link google.longrunning.Operation | google.longrunning.Operation}.
     * @return {Promise} - The promise which resolves to an array.
     *   The first element of the array is an object representing
     * {@link google.longrunning.Operation | google.longrunning.Operation}.
     * The promise has a method named "cancel" which cancels the ongoing API call.
     *
     * @example
     * ```
     * const client = longrunning.operationsClient();
     * const name = '';
     * const [response] = await client.getOperation({name});
     * // doThingsWith(response)
     * ```
     */ getOperation(request, optionsOrCallback, callback) {
        var _a;
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        return this.operationsClient.getOperation(request, options, callback);
    }
    /**
     * Lists operations that match the specified filter in the request. If the
     * server doesn't support this method, it returns `UNIMPLEMENTED`. Returns an iterable object.
     *
     * For-await-of syntax is used with the iterable to recursively get response element on-demand.
     *
     * @param {Object} request - The request object that will be sent.
     * @param {string} request.name - The name of the operation collection.
     * @param {string} request.filter - The standard list filter.
     * @param {number=} request.pageSize -
     *   The maximum number of resources contained in the underlying API
     *   response. If page streaming is performed per-resource, this
     *   parameter does not affect the return value. If page streaming is
     *   performed per-page, this determines the maximum number of
     *   resources in a page.
     * @param {Object=} options
     *   Optional parameters. You can override the default settings for this call,
     *   e.g, timeout, retries, paginations, etc. See {@link
     *   https://googleapis.github.io/gax-nodejs/global.html#CallOptions | gax.CallOptions} for the
     *   details.
     * @returns {Object}
     *   An iterable Object that conforms to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | iteration protocols}.
     *
     * @example
     * ```
     * const client = longrunning.operationsClient();
     * for await (const response of client.listOperationsAsync(request));
     * // doThingsWith(response)
     * ```
     */ listOperationsAsync(request, options) {
        var _a;
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        return this.operationsClient.listOperationsAsync(request, options);
    }
    /**
     * Starts asynchronous cancellation on a long-running operation.  The server
     * makes a best effort to cancel the operation, but success is not
     * guaranteed.  If the server doesn't support this method, it returns
     * `google.rpc.Code.UNIMPLEMENTED`.  Clients can use
     * {@link Operations.GetOperation} or
     * other methods to check whether the cancellation succeeded or whether the
     * operation completed despite cancellation. On successful cancellation,
     * the operation is not deleted; instead, it becomes an operation with
     * an {@link Operation.error} value with a {@link google.rpc.Status.code} of
     * 1, corresponding to `Code.CANCELLED`.
     *
     * @param {Object} request - The request object that will be sent.
     * @param {string} request.name - The name of the operation resource to be cancelled.
     * @param {Object=} options
     *   Optional parameters. You can override the default settings for this call,
     * e.g, timeout, retries, paginations, etc. See {@link
     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions | gax.CallOptions} for the
     * details.
     * @param {function(?Error)=} callback
     *   The function which will be called with the result of the API call.
     * @return {Promise} - The promise which resolves when API call finishes.
     *   The promise has a method named "cancel" which cancels the ongoing API
     * call.
     *
     * @example
     * ```
     * const client = longrunning.operationsClient();
     * await client.cancelOperation({name: ''});
     * ```
     */ cancelOperation(request, optionsOrCallback, callback) {
        var _a;
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        return this.operationsClient.cancelOperation(request, options, callback);
    }
    /**
     * Deletes a long-running operation. This method indicates that the client is
     * no longer interested in the operation result. It does not cancel the
     * operation. If the server doesn't support this method, it returns
     * `google.rpc.Code.UNIMPLEMENTED`.
     *
     * @param {Object} request - The request object that will be sent.
     * @param {string} request.name - The name of the operation resource to be deleted.
     * @param {Object=} options
     *   Optional parameters. You can override the default settings for this call,
     * e.g, timeout, retries, paginations, etc. See {@link
     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions | gax.CallOptions}
     * for the details.
     * @param {function(?Error)=} callback
     *   The function which will be called with the result of the API call.
     * @return {Promise} - The promise which resolves when API call finishes.
     *   The promise has a method named "cancel" which cancels the ongoing API
     * call.
     *
     * @example
     * ```
     * const client = longrunning.operationsClient();
     * await client.deleteOperation({name: ''});
     * ```
     */ deleteOperation(request, optionsOrCallback, callback) {
        var _a;
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        return this.operationsClient.deleteOperation(request, options, callback);
    }
    // --------------------
    // -- Path templates --
    // --------------------
    /**
     * Return a fully-qualified backup resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @param {string} backup
     * @returns {string} Resource name string.
     */ backupPath(project, location, backup) {
        return this.pathTemplates.backupPathTemplate.render({
            project: project,
            location: location,
            backup: backup
        });
    }
    /**
     * Parse the project from Backup resource.
     *
     * @param {string} backupName
     *   A fully-qualified path representing Backup resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromBackupName(backupName) {
        return this.pathTemplates.backupPathTemplate.match(backupName).project;
    }
    /**
     * Parse the location from Backup resource.
     *
     * @param {string} backupName
     *   A fully-qualified path representing Backup resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromBackupName(backupName) {
        return this.pathTemplates.backupPathTemplate.match(backupName).location;
    }
    /**
     * Parse the backup from Backup resource.
     *
     * @param {string} backupName
     *   A fully-qualified path representing Backup resource.
     * @returns {string} A string representing the backup.
     */ matchBackupFromBackupName(backupName) {
        return this.pathTemplates.backupPathTemplate.match(backupName).backup;
    }
    /**
     * Return a fully-qualified backupSchedule resource name string.
     *
     * @param {string} project
     * @param {string} database
     * @param {string} backup_schedule
     * @returns {string} Resource name string.
     */ backupSchedulePath(project, database, backupSchedule) {
        return this.pathTemplates.backupSchedulePathTemplate.render({
            project: project,
            database: database,
            backup_schedule: backupSchedule
        });
    }
    /**
     * Parse the project from BackupSchedule resource.
     *
     * @param {string} backupScheduleName
     *   A fully-qualified path representing BackupSchedule resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromBackupScheduleName(backupScheduleName) {
        return this.pathTemplates.backupSchedulePathTemplate.match(backupScheduleName).project;
    }
    /**
     * Parse the database from BackupSchedule resource.
     *
     * @param {string} backupScheduleName
     *   A fully-qualified path representing BackupSchedule resource.
     * @returns {string} A string representing the database.
     */ matchDatabaseFromBackupScheduleName(backupScheduleName) {
        return this.pathTemplates.backupSchedulePathTemplate.match(backupScheduleName).database;
    }
    /**
     * Parse the backup_schedule from BackupSchedule resource.
     *
     * @param {string} backupScheduleName
     *   A fully-qualified path representing BackupSchedule resource.
     * @returns {string} A string representing the backup_schedule.
     */ matchBackupScheduleFromBackupScheduleName(backupScheduleName) {
        return this.pathTemplates.backupSchedulePathTemplate.match(backupScheduleName).backup_schedule;
    }
    /**
     * Return a fully-qualified collectionGroup resource name string.
     *
     * @param {string} project
     * @param {string} database
     * @param {string} collection
     * @returns {string} Resource name string.
     */ collectionGroupPath(project, database, collection) {
        return this.pathTemplates.collectionGroupPathTemplate.render({
            project: project,
            database: database,
            collection: collection
        });
    }
    /**
     * Parse the project from CollectionGroup resource.
     *
     * @param {string} collectionGroupName
     *   A fully-qualified path representing CollectionGroup resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromCollectionGroupName(collectionGroupName) {
        return this.pathTemplates.collectionGroupPathTemplate.match(collectionGroupName).project;
    }
    /**
     * Parse the database from CollectionGroup resource.
     *
     * @param {string} collectionGroupName
     *   A fully-qualified path representing CollectionGroup resource.
     * @returns {string} A string representing the database.
     */ matchDatabaseFromCollectionGroupName(collectionGroupName) {
        return this.pathTemplates.collectionGroupPathTemplate.match(collectionGroupName).database;
    }
    /**
     * Parse the collection from CollectionGroup resource.
     *
     * @param {string} collectionGroupName
     *   A fully-qualified path representing CollectionGroup resource.
     * @returns {string} A string representing the collection.
     */ matchCollectionFromCollectionGroupName(collectionGroupName) {
        return this.pathTemplates.collectionGroupPathTemplate.match(collectionGroupName).collection;
    }
    /**
     * Return a fully-qualified database resource name string.
     *
     * @param {string} project
     * @param {string} database
     * @returns {string} Resource name string.
     */ databasePath(project, database) {
        return this.pathTemplates.databasePathTemplate.render({
            project: project,
            database: database
        });
    }
    /**
     * Parse the project from Database resource.
     *
     * @param {string} databaseName
     *   A fully-qualified path representing Database resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromDatabaseName(databaseName) {
        return this.pathTemplates.databasePathTemplate.match(databaseName).project;
    }
    /**
     * Parse the database from Database resource.
     *
     * @param {string} databaseName
     *   A fully-qualified path representing Database resource.
     * @returns {string} A string representing the database.
     */ matchDatabaseFromDatabaseName(databaseName) {
        return this.pathTemplates.databasePathTemplate.match(databaseName).database;
    }
    /**
     * Return a fully-qualified field resource name string.
     *
     * @param {string} project
     * @param {string} database
     * @param {string} collection
     * @param {string} field
     * @returns {string} Resource name string.
     */ fieldPath(project, database, collection, field) {
        return this.pathTemplates.fieldPathTemplate.render({
            project: project,
            database: database,
            collection: collection,
            field: field
        });
    }
    /**
     * Parse the project from Field resource.
     *
     * @param {string} fieldName
     *   A fully-qualified path representing Field resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromFieldName(fieldName) {
        return this.pathTemplates.fieldPathTemplate.match(fieldName).project;
    }
    /**
     * Parse the database from Field resource.
     *
     * @param {string} fieldName
     *   A fully-qualified path representing Field resource.
     * @returns {string} A string representing the database.
     */ matchDatabaseFromFieldName(fieldName) {
        return this.pathTemplates.fieldPathTemplate.match(fieldName).database;
    }
    /**
     * Parse the collection from Field resource.
     *
     * @param {string} fieldName
     *   A fully-qualified path representing Field resource.
     * @returns {string} A string representing the collection.
     */ matchCollectionFromFieldName(fieldName) {
        return this.pathTemplates.fieldPathTemplate.match(fieldName).collection;
    }
    /**
     * Parse the field from Field resource.
     *
     * @param {string} fieldName
     *   A fully-qualified path representing Field resource.
     * @returns {string} A string representing the field.
     */ matchFieldFromFieldName(fieldName) {
        return this.pathTemplates.fieldPathTemplate.match(fieldName).field;
    }
    /**
     * Return a fully-qualified index resource name string.
     *
     * @param {string} project
     * @param {string} database
     * @param {string} collection
     * @param {string} index
     * @returns {string} Resource name string.
     */ indexPath(project, database, collection, index) {
        return this.pathTemplates.indexPathTemplate.render({
            project: project,
            database: database,
            collection: collection,
            index: index
        });
    }
    /**
     * Parse the project from Index resource.
     *
     * @param {string} indexName
     *   A fully-qualified path representing Index resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromIndexName(indexName) {
        return this.pathTemplates.indexPathTemplate.match(indexName).project;
    }
    /**
     * Parse the database from Index resource.
     *
     * @param {string} indexName
     *   A fully-qualified path representing Index resource.
     * @returns {string} A string representing the database.
     */ matchDatabaseFromIndexName(indexName) {
        return this.pathTemplates.indexPathTemplate.match(indexName).database;
    }
    /**
     * Parse the collection from Index resource.
     *
     * @param {string} indexName
     *   A fully-qualified path representing Index resource.
     * @returns {string} A string representing the collection.
     */ matchCollectionFromIndexName(indexName) {
        return this.pathTemplates.indexPathTemplate.match(indexName).collection;
    }
    /**
     * Parse the index from Index resource.
     *
     * @param {string} indexName
     *   A fully-qualified path representing Index resource.
     * @returns {string} A string representing the index.
     */ matchIndexFromIndexName(indexName) {
        return this.pathTemplates.indexPathTemplate.match(indexName).index;
    }
    /**
     * Return a fully-qualified location resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @returns {string} Resource name string.
     */ locationPath(project, location) {
        return this.pathTemplates.locationPathTemplate.render({
            project: project,
            location: location
        });
    }
    /**
     * Parse the project from Location resource.
     *
     * @param {string} locationName
     *   A fully-qualified path representing Location resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromLocationName(locationName) {
        return this.pathTemplates.locationPathTemplate.match(locationName).project;
    }
    /**
     * Parse the location from Location resource.
     *
     * @param {string} locationName
     *   A fully-qualified path representing Location resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromLocationName(locationName) {
        return this.pathTemplates.locationPathTemplate.match(locationName).location;
    }
    /**
     * Return a fully-qualified project resource name string.
     *
     * @param {string} project
     * @returns {string} Resource name string.
     */ projectPath(project) {
        return this.pathTemplates.projectPathTemplate.render({
            project: project
        });
    }
    /**
     * Parse the project from Project resource.
     *
     * @param {string} projectName
     *   A fully-qualified path representing Project resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectName(projectName) {
        return this.pathTemplates.projectPathTemplate.match(projectName).project;
    }
    /**
     * Terminate the gRPC channel and close the client.
     *
     * The client will no longer be usable and all future behavior is undefined.
     * @returns {Promise} A promise that resolves when the client is closed.
     */ close() {
        if (this.firestoreAdminStub && !this._terminated) {
            return this.firestoreAdminStub.then((stub)=>{
                this._terminated = true;
                stub.close();
                this.locationsClient.close();
                this.operationsClient.close();
            });
        }
        return Promise.resolve();
    }
}
exports.FirestoreAdminClient = FirestoreAdminClient; //# sourceMappingURL=firestore_admin_client.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_client.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FirestoreClient = void 0;
const stream_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
const jsonProtos = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/protos/v1.json (json)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
/**
 * Client JSON configuration object, loaded from
 * `src/v1/firestore_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */ const gapicConfig = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json (json)");
const version = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/package.json (json)").version;
/**
 *  The Cloud Firestore service.
 *
 *  Cloud Firestore is a fast, fully managed, serverless, cloud-native NoSQL
 *  document database that simplifies storing, syncing, and querying data for
 *  your mobile, web, and IoT apps at global scale. Its client libraries provide
 *  live synchronization and offline support, while its security features and
 *  integrations with Firebase and Google Cloud Platform accelerate building
 *  truly serverless apps.
 * @class
 * @memberof v1
 */ class FirestoreClient {
    /**
     * Construct an instance of FirestoreClient.
     *
     * @param {object} [options] - The configuration object.
     * The options accepted by the constructor are described in detail
     * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).
     * The common options are:
     * @param {object} [options.credentials] - Credentials object.
     * @param {string} [options.credentials.client_email]
     * @param {string} [options.credentials.private_key]
     * @param {string} [options.email] - Account email address. Required when
     *     using a .pem or .p12 keyFilename.
     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
     *     .p12 key downloaded from the Google Developers Console. If you provide
     *     a path to a JSON file, the projectId option below is not necessary.
     *     NOTE: .pem and .p12 require you to specify options.email as well.
     * @param {number} [options.port] - The port on which to connect to
     *     the remote host.
     * @param {string} [options.projectId] - The project ID from the Google
     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
     *     the environment variable GCLOUD_PROJECT for your project ID. If your
     *     app is running in an environment which supports
     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
     *     your project ID will be detected automatically.
     * @param {string} [options.apiEndpoint] - The domain name of the
     *     API remote host.
     * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
     *     Follows the structure of {@link gapicConfig}.
     * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.
     *     For more information, please check the
     *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.
     * @param {gax} [gaxInstance]: loaded instance of `google-gax`. Useful if you
     *     need to avoid loading the default gRPC version and want to use the fallback
     *     HTTP implementation. Load only fallback version and pass it to the constructor:
     *     ```
     *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC
     *     const client = new FirestoreClient({fallback: true}, gax);
     *     ```
     */ constructor(opts, gaxInstance){
        var _a, _b, _c, _d, _e;
        this._terminated = false;
        this._stubFailed = false;
        this.descriptors = {
            page: {},
            stream: {},
            longrunning: {},
            batching: {}
        };
        // Ensure that options include all the required fields.
        const staticMembers = this.constructor;
        if ((opts === null || opts === void 0 ? void 0 : opts.universe_domain) && (opts === null || opts === void 0 ? void 0 : opts.universeDomain) && (opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== (opts === null || opts === void 0 ? void 0 : opts.universeDomain)) {
            throw new Error('Please set either universe_domain or universeDomain, but not both.');
        }
        const universeDomainEnvVar = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env === 'object' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] : undefined;
        this._universeDomain = (_c = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.universeDomain) !== null && _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== null && _b !== void 0 ? _b : universeDomainEnvVar) !== null && _c !== void 0 ? _c : 'googleapis.com';
        this._servicePath = 'firestore.' + this._universeDomain;
        const servicePath = (opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint) || this._servicePath;
        this._providedCustomServicePath = !!((opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint));
        const port = (opts === null || opts === void 0 ? void 0 : opts.port) || staticMembers.port;
        const clientConfig = (_d = opts === null || opts === void 0 ? void 0 : opts.clientConfig) !== null && _d !== void 0 ? _d : {};
        const fallback = (_e = opts === null || opts === void 0 ? void 0 : opts.fallback) !== null && _e !== void 0 ? _e : typeof window !== 'undefined' && typeof (window === null || window === void 0 ? void 0 : window.fetch) === 'function';
        opts = Object.assign({
            servicePath,
            port,
            clientConfig,
            fallback
        }, opts);
        // Request numeric enum values if REST transport is used.
        opts.numericEnums = true;
        // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
        if (servicePath !== this._servicePath && !('scopes' in opts)) {
            opts['scopes'] = staticMembers.scopes;
        }
        // Load google-gax module synchronously if needed
        if (!gaxInstance) {
            gaxInstance = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)");
        }
        // Choose either gRPC or proto-over-HTTP implementation of google-gax.
        this._gaxModule = opts.fallback ? gaxInstance.fallback : gaxInstance;
        // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);
        // Save options to use in initialize() method.
        this._opts = opts;
        // Save the auth object to the client, for use by other methods.
        this.auth = this._gaxGrpc.auth;
        // Set useJWTAccessWithScope on the auth object.
        this.auth.useJWTAccessWithScope = true;
        // Set defaultServicePath on the auth object.
        this.auth.defaultServicePath = this._servicePath;
        // Set the default scopes in auth client if needed.
        if (servicePath === this._servicePath) {
            this.auth.defaultScopes = staticMembers.scopes;
        }
        this.locationsClient = new this._gaxModule.LocationsClient(this._gaxGrpc, opts);
        // Determine the client header string.
        const clientHeader = [
            `gax/${this._gaxModule.version}`,
            `gapic/${version}`
        ];
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && 'versions' in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            clientHeader.push(`gl-node/${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node}`);
        } else {
            clientHeader.push(`gl-web/${this._gaxModule.version}`);
        }
        if (!opts.fallback) {
            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
        } else {
            clientHeader.push(`rest/${this._gaxGrpc.grpcVersion}`);
        }
        if (opts.libName && opts.libVersion) {
            clientHeader.push(`${opts.libName}/${opts.libVersion}`);
        }
        // Load the applicable protos.
        this._protos = this._gaxGrpc.loadProtoJSON(jsonProtos);
        // Some of the methods on this service return "paged" results,
        // (e.g. 50 results at a time, with tokens to get subsequent
        // pages). Denote the keys used for pagination and results.
        this.descriptors.page = {
            listDocuments: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'documents'),
            partitionQuery: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'partitions'),
            listCollectionIds: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'collectionIds')
        };
        // Some of the methods on this service provide streaming responses.
        // Provide descriptors for these.
        this.descriptors.stream = {
            batchGetDocuments: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.SERVER_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),
            runQuery: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.SERVER_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),
            runAggregationQuery: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.SERVER_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),
            write: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.BIDI_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),
            listen: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.BIDI_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries)
        };
        // Put together the default options sent with requests.
        this._defaults = this._gaxGrpc.constructSettings('google.firestore.v1.Firestore', gapicConfig, opts.clientConfig || {}, {
            'x-goog-api-client': clientHeader.join(' ')
        });
        // Set up a dictionary of "inner API calls"; the core implementation
        // of calling the API is handled in `google-gax`, with this code
        // merely providing the destination and request information.
        this.innerApiCalls = {};
        // Add a warn function to the client constructor so it can be easily tested.
        this.warn = this._gaxModule.warn;
    }
    /**
     * Initialize the client.
     * Performs asynchronous operations (such as authentication) and prepares the client.
     * This function will be called automatically when any class method is called for the
     * first time, but if you need to initialize it before calling an actual method,
     * feel free to call initialize() directly.
     *
     * You can await on this method if you want to make sure the client is initialized.
     *
     * @returns {Promise} A promise that resolves to an authenticated service stub.
     */ initialize() {
        // If the client stub promise is already initialized, return immediately.
        if (this.firestoreStub && !this._stubFailed) {
            return this.firestoreStub;
        }
        // Reset _stubFailed because we are re-attempting create
        this._stubFailed = false;
        // Put together the "service stub" for
        // google.firestore.v1.Firestore.
        this.firestoreStub = this._gaxGrpc.createStub(this._opts.fallback ? this._protos.lookupService('google.firestore.v1.Firestore') : this._protos.google.firestore.v1.Firestore, this._opts, this._providedCustomServicePath);
        // Iterate over each of the methods that the service provides
        // and create an API call method for each.
        const firestoreStubMethods = [
            'getDocument',
            'listDocuments',
            'updateDocument',
            'deleteDocument',
            'batchGetDocuments',
            'beginTransaction',
            'commit',
            'rollback',
            'runQuery',
            'runAggregationQuery',
            'partitionQuery',
            'write',
            'listen',
            'listCollectionIds',
            'batchWrite',
            'createDocument'
        ];
        for (const methodName of firestoreStubMethods){
            const callPromise = this.firestoreStub.then((stub)=>{
                return (...args)=>{
                    if (this._terminated) {
                        if (methodName in this.descriptors.stream) {
                            const stream = new stream_1.PassThrough({
                                objectMode: true
                            });
                            setImmediate(()=>{
                                stream.emit('error', new this._gaxModule.GoogleError('The client has already been closed.'));
                            });
                            return stream;
                        }
                        return Promise.reject('The client has already been closed.');
                    }
                    const func = stub[methodName];
                    return func.apply(stub, args);
                };
            }, (err)=>{
                this._stubFailed = true;
                (0, logger_1.logger)('initialize', null, 'Failed to create the gax client stub.', err);
                return ()=>{
                    throw err;
                };
            });
            const descriptor = this.descriptors.page[methodName] || this.descriptors.stream[methodName] || undefined;
            const apiCall = this._gaxModule.createApiCall(callPromise, this._defaults[methodName], descriptor, this._opts.fallback);
            this.innerApiCalls[methodName] = apiCall;
        }
        return this.firestoreStub;
    }
    /**
     * The DNS address for this API service.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get servicePath() {
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning === 'function') {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning('Static servicePath is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'firestore.googleapis.com';
    }
    /**
     * The DNS address for this API service - same as servicePath.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get apiEndpoint() {
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning === 'function') {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning('Static apiEndpoint is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'firestore.googleapis.com';
    }
    /**
     * The DNS address for this API service.
     * @returns {string} The DNS address for this service.
     */ get apiEndpoint() {
        return this._servicePath;
    }
    get universeDomain() {
        return this._universeDomain;
    }
    /**
     * The port for this API service.
     * @returns {number} The default port for this service.
     */ static get port() {
        return 443;
    }
    /**
     * The scopes needed to make gRPC calls for every method defined
     * in this service.
     * @returns {string[]} List of default scopes.
     */ static get scopes() {
        return [
            'https://www.googleapis.com/auth/cloud-platform',
            'https://www.googleapis.com/auth/datastore'
        ];
    }
    /**
     * Return the project ID used by this class.
     * @returns {Promise} A promise that resolves to string containing the project ID.
     */ getProjectId(callback) {
        if (callback) {
            this.auth.getProjectId(callback);
            return;
        }
        return this.auth.getProjectId();
    }
    getDocument(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getDocument(request, options, callback);
    }
    updateDocument(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'document.name': (_a = request.document.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateDocument(request, options, callback);
    }
    deleteDocument(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteDocument(request, options, callback);
    }
    beginTransaction(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            database: (_a = request.database) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.beginTransaction(request, options, callback);
    }
    commit(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            database: (_a = request.database) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.commit(request, options, callback);
    }
    rollback(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            database: (_a = request.database) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.rollback(request, options, callback);
    }
    batchWrite(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            database: (_a = request.database) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.batchWrite(request, options, callback);
    }
    createDocument(request, optionsOrCallback, callback) {
        var _a, _b;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : '',
            collection_id: (_b = request.collectionId) !== null && _b !== void 0 ? _b : ''
        });
        this.initialize();
        return this.innerApiCalls.createDocument(request, options, callback);
    }
    /**
     * Gets multiple documents.
     *
     * Documents returned by this method are not guaranteed to be returned in the
     * same order that they were requested.
     *
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.database
     *   Required. The database name. In the format:
     *   `projects/{project_id}/databases/{database_id}`.
     * @param {string[]} request.documents
     *   The names of the documents to retrieve. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   The request will fail if any of the document is not a child resource of the
     *   given `database`. Duplicate names will be elided.
     * @param {google.firestore.v1.DocumentMask} request.mask
     *   The fields to return. If not set, returns all fields.
     *
     *   If a document has a field that is not present in this mask, that field will
     *   not be returned in the response.
     * @param {Buffer} request.transaction
     *   Reads documents in a transaction.
     * @param {google.firestore.v1.TransactionOptions} request.newTransaction
     *   Starts a new transaction and reads the documents.
     *   Defaults to a read-only transaction.
     *   The new transaction ID will be returned as the first response in the
     *   stream.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Reads documents as they were at the given time.
     *
     *   This must be a microsecond precision timestamp within the past one hour,
     *   or if Point-in-Time Recovery is enabled, can additionally be a whole
     *   minute timestamp within the past 7 days.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits {@link protos.google.firestore.v1.BatchGetDocumentsResponse|BatchGetDocumentsResponse} on 'data' event.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#server-streaming | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore.batch_get_documents.js</caption>
     * region_tag:firestore_v1_generated_Firestore_BatchGetDocuments_async
     */ batchGetDocuments(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            database: (_a = request.database) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.batchGetDocuments(request, options);
    }
    /**
     * Runs a query.
     *
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents` or
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   For example:
     *   `projects/my-project/databases/my-database/documents` or
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {google.firestore.v1.StructuredQuery} request.structuredQuery
     *   A structured query.
     * @param {Buffer} request.transaction
     *   Run the query within an already active transaction.
     *
     *   The value here is the opaque transaction ID to execute the query in.
     * @param {google.firestore.v1.TransactionOptions} request.newTransaction
     *   Starts a new transaction and reads the documents.
     *   Defaults to a read-only transaction.
     *   The new transaction ID will be returned as the first response in the
     *   stream.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Reads documents as they were at the given time.
     *
     *   This must be a microsecond precision timestamp within the past one hour,
     *   or if Point-in-Time Recovery is enabled, can additionally be a whole
     *   minute timestamp within the past 7 days.
     * @param {google.firestore.v1.ExplainOptions} [request.explainOptions]
     *   Optional. Explain options for the query. If set, additional query
     *   statistics will be returned. If not, only query results will be returned.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits {@link protos.google.firestore.v1.RunQueryResponse|RunQueryResponse} on 'data' event.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#server-streaming | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore.run_query.js</caption>
     * region_tag:firestore_v1_generated_Firestore_RunQuery_async
     */ runQuery(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.runQuery(request, options);
    }
    /**
     * Runs an aggregation query.
     *
     * Rather than producing {@link protos.google.firestore.v1.Document|Document} results like
     * {@link protos.google.firestore.v1.Firestore.RunQuery|Firestore.RunQuery}, this API
     * allows running an aggregation to produce a series of
     * {@link protos.google.firestore.v1.AggregationResult|AggregationResult} server-side.
     *
     * High-Level Example:
     *
     * ```
     * -- Return the number of documents in table given a filter.
     * SELECT COUNT(*) FROM ( SELECT * FROM k where a = true );
     * ```
     *
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents` or
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   For example:
     *   `projects/my-project/databases/my-database/documents` or
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {google.firestore.v1.StructuredAggregationQuery} request.structuredAggregationQuery
     *   An aggregation query.
     * @param {Buffer} request.transaction
     *   Run the aggregation within an already active transaction.
     *
     *   The value here is the opaque transaction ID to execute the query in.
     * @param {google.firestore.v1.TransactionOptions} request.newTransaction
     *   Starts a new transaction as part of the query, defaulting to read-only.
     *
     *   The new transaction ID will be returned as the first response in the
     *   stream.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Executes the query at the given timestamp.
     *
     *   This must be a microsecond precision timestamp within the past one hour,
     *   or if Point-in-Time Recovery is enabled, can additionally be a whole
     *   minute timestamp within the past 7 days.
     * @param {google.firestore.v1.ExplainOptions} [request.explainOptions]
     *   Optional. Explain options for the query. If set, additional query
     *   statistics will be returned. If not, only query results will be returned.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits {@link protos.google.firestore.v1.RunAggregationQueryResponse|RunAggregationQueryResponse} on 'data' event.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#server-streaming | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore.run_aggregation_query.js</caption>
     * region_tag:firestore_v1_generated_Firestore_RunAggregationQuery_async
     */ runAggregationQuery(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.runAggregationQuery(request, options);
    }
    /**
     * Streams batches of document updates and deletes, in order. This method is
     * only available via gRPC or WebChannel (not REST).
     *
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which is both readable and writable. It accepts objects
     *   representing {@link protos.google.firestore.v1.WriteRequest|WriteRequest} for write() method, and
     *   will emit objects representing {@link protos.google.firestore.v1.WriteResponse|WriteResponse} on 'data' event asynchronously.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#bi-directional-streaming | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore.write.js</caption>
     * region_tag:firestore_v1_generated_Firestore_Write_async
     */ write(options) {
        this.initialize();
        return this.innerApiCalls.write(null, options);
    }
    /**
     * Listens to changes. This method is only available via gRPC or WebChannel
     * (not REST).
     *
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which is both readable and writable. It accepts objects
     *   representing {@link protos.google.firestore.v1.ListenRequest|ListenRequest} for write() method, and
     *   will emit objects representing {@link protos.google.firestore.v1.ListenResponse|ListenResponse} on 'data' event asynchronously.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#bi-directional-streaming | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore.listen.js</caption>
     * region_tag:firestore_v1_generated_Firestore_Listen_async
     */ listen(options) {
        this.initialize();
        return this.innerApiCalls.listen(null, options);
    }
    listDocuments(request, optionsOrCallback, callback) {
        var _a, _b;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : '',
            collection_id: (_b = request.collectionId) !== null && _b !== void 0 ? _b : ''
        });
        this.initialize();
        return this.innerApiCalls.listDocuments(request, options, callback);
    }
    /**
     * Equivalent to `listDocuments`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents` or
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *
     *   For example:
     *   `projects/my-project/databases/my-database/documents` or
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {string} [request.collectionId]
     *   Optional. The collection ID, relative to `parent`, to list.
     *
     *   For example: `chatrooms` or `messages`.
     *
     *   This is optional, and when not provided, Firestore will list documents
     *   from all collections under the provided `parent`.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of documents to return in a single response.
     *
     *   Firestore may return fewer than this value.
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous `ListDocuments` response.
     *
     *   Provide this to retrieve the subsequent page. When paginating, all other
     *   parameters (with the exception of `page_size`) must match the values set
     *   in the request that generated the page token.
     * @param {string} [request.orderBy]
     *   Optional. The optional ordering of the documents to return.
     *
     *   For example: `priority desc, __name__ desc`.
     *
     *   This mirrors the {@link protos.google.firestore.v1.StructuredQuery.order_by|`ORDER BY`}
     *   used in Firestore queries but in a string representation. When absent,
     *   documents are ordered based on `__name__ ASC`.
     * @param {google.firestore.v1.DocumentMask} [request.mask]
     *   Optional. The fields to return. If not set, returns all fields.
     *
     *   If a document has a field that is not present in this mask, that field
     *   will not be returned in the response.
     * @param {Buffer} request.transaction
     *   Perform the read as part of an already active transaction.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Perform the read at the provided time.
     *
     *   This must be a microsecond precision timestamp within the past one hour,
     *   or if Point-in-Time Recovery is enabled, can additionally be a whole
     *   minute timestamp within the past 7 days.
     * @param {boolean} request.showMissing
     *   If the list should show missing documents.
     *
     *   A document is missing if it does not exist, but there are sub-documents
     *   nested underneath it. When true, such missing documents will be returned
     *   with a key but will not have fields,
     *   {@link protos.google.firestore.v1.Document.create_time|`create_time`}, or
     *   {@link protos.google.firestore.v1.Document.update_time|`update_time`} set.
     *
     *   Requests with `show_missing` may not specify `where` or `order_by`.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.firestore.v1.Document|Document} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listDocumentsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listDocumentsStream(request, options) {
        var _a, _b;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : '',
            collection_id: (_b = request.collectionId) !== null && _b !== void 0 ? _b : ''
        });
        const defaultCallSettings = this._defaults['listDocuments'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listDocuments.createStream(this.innerApiCalls.listDocuments, request, callSettings);
    }
    /**
     * Equivalent to `listDocuments`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents` or
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *
     *   For example:
     *   `projects/my-project/databases/my-database/documents` or
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {string} [request.collectionId]
     *   Optional. The collection ID, relative to `parent`, to list.
     *
     *   For example: `chatrooms` or `messages`.
     *
     *   This is optional, and when not provided, Firestore will list documents
     *   from all collections under the provided `parent`.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of documents to return in a single response.
     *
     *   Firestore may return fewer than this value.
     * @param {string} [request.pageToken]
     *   Optional. A page token, received from a previous `ListDocuments` response.
     *
     *   Provide this to retrieve the subsequent page. When paginating, all other
     *   parameters (with the exception of `page_size`) must match the values set
     *   in the request that generated the page token.
     * @param {string} [request.orderBy]
     *   Optional. The optional ordering of the documents to return.
     *
     *   For example: `priority desc, __name__ desc`.
     *
     *   This mirrors the {@link protos.google.firestore.v1.StructuredQuery.order_by|`ORDER BY`}
     *   used in Firestore queries but in a string representation. When absent,
     *   documents are ordered based on `__name__ ASC`.
     * @param {google.firestore.v1.DocumentMask} [request.mask]
     *   Optional. The fields to return. If not set, returns all fields.
     *
     *   If a document has a field that is not present in this mask, that field
     *   will not be returned in the response.
     * @param {Buffer} request.transaction
     *   Perform the read as part of an already active transaction.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Perform the read at the provided time.
     *
     *   This must be a microsecond precision timestamp within the past one hour,
     *   or if Point-in-Time Recovery is enabled, can additionally be a whole
     *   minute timestamp within the past 7 days.
     * @param {boolean} request.showMissing
     *   If the list should show missing documents.
     *
     *   A document is missing if it does not exist, but there are sub-documents
     *   nested underneath it. When true, such missing documents will be returned
     *   with a key but will not have fields,
     *   {@link protos.google.firestore.v1.Document.create_time|`create_time`}, or
     *   {@link protos.google.firestore.v1.Document.update_time|`update_time`} set.
     *
     *   Requests with `show_missing` may not specify `where` or `order_by`.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.firestore.v1.Document|Document}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore.list_documents.js</caption>
     * region_tag:firestore_v1_generated_Firestore_ListDocuments_async
     */ listDocumentsAsync(request, options) {
        var _a, _b;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : '',
            collection_id: (_b = request.collectionId) !== null && _b !== void 0 ? _b : ''
        });
        const defaultCallSettings = this._defaults['listDocuments'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listDocuments.asyncIterate(this.innerApiCalls['listDocuments'], request, callSettings);
    }
    partitionQuery(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.partitionQuery(request, options, callback);
    }
    /**
     * Equivalent to `partitionQuery`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents`.
     *   Document resource names are not supported; only database resource names
     *   can be specified.
     * @param {google.firestore.v1.StructuredQuery} request.structuredQuery
     *   A structured query.
     *   Query must specify collection with all descendants and be ordered by name
     *   ascending. Other filters, order bys, limits, offsets, and start/end
     *   cursors are not supported.
     * @param {number} request.partitionCount
     *   The desired maximum number of partition points.
     *   The partitions may be returned across multiple pages of results.
     *   The number must be positive. The actual number of partitions
     *   returned may be fewer.
     *
     *   For example, this may be set to one fewer than the number of parallel
     *   queries to be run, or in running a data pipeline job, one fewer than the
     *   number of workers or compute instances available.
     * @param {string} request.pageToken
     *   The `next_page_token` value returned from a previous call to
     *   PartitionQuery that may be used to get an additional set of results.
     *   There are no ordering guarantees between sets of results. Thus, using
     *   multiple sets of results will require merging the different result sets.
     *
     *   For example, two subsequent calls using a page_token may return:
     *
     *    * cursor B, cursor M, cursor Q
     *    * cursor A, cursor U, cursor W
     *
     *   To obtain a complete result set ordered with respect to the results of the
     *   query supplied to PartitionQuery, the results sets should be merged:
     *   cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W
     * @param {number} request.pageSize
     *   The maximum number of partitions to return in this call, subject to
     *   `partition_count`.
     *
     *   For example, if `partition_count` = 10 and `page_size` = 8, the first call
     *   to PartitionQuery will return up to 8 partitions and a `next_page_token`
     *   if more results exist. A second call to PartitionQuery will return up to
     *   2 partitions, to complete the total of 10 specified in `partition_count`.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Reads documents as they were at the given time.
     *
     *   This must be a microsecond precision timestamp within the past one hour,
     *   or if Point-in-Time Recovery is enabled, can additionally be a whole
     *   minute timestamp within the past 7 days.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.firestore.v1.Cursor|Cursor} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `partitionQueryAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ partitionQueryStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['partitionQuery'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.partitionQuery.createStream(this.innerApiCalls.partitionQuery, request, callSettings);
    }
    /**
     * Equivalent to `partitionQuery`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents`.
     *   Document resource names are not supported; only database resource names
     *   can be specified.
     * @param {google.firestore.v1.StructuredQuery} request.structuredQuery
     *   A structured query.
     *   Query must specify collection with all descendants and be ordered by name
     *   ascending. Other filters, order bys, limits, offsets, and start/end
     *   cursors are not supported.
     * @param {number} request.partitionCount
     *   The desired maximum number of partition points.
     *   The partitions may be returned across multiple pages of results.
     *   The number must be positive. The actual number of partitions
     *   returned may be fewer.
     *
     *   For example, this may be set to one fewer than the number of parallel
     *   queries to be run, or in running a data pipeline job, one fewer than the
     *   number of workers or compute instances available.
     * @param {string} request.pageToken
     *   The `next_page_token` value returned from a previous call to
     *   PartitionQuery that may be used to get an additional set of results.
     *   There are no ordering guarantees between sets of results. Thus, using
     *   multiple sets of results will require merging the different result sets.
     *
     *   For example, two subsequent calls using a page_token may return:
     *
     *    * cursor B, cursor M, cursor Q
     *    * cursor A, cursor U, cursor W
     *
     *   To obtain a complete result set ordered with respect to the results of the
     *   query supplied to PartitionQuery, the results sets should be merged:
     *   cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W
     * @param {number} request.pageSize
     *   The maximum number of partitions to return in this call, subject to
     *   `partition_count`.
     *
     *   For example, if `partition_count` = 10 and `page_size` = 8, the first call
     *   to PartitionQuery will return up to 8 partitions and a `next_page_token`
     *   if more results exist. A second call to PartitionQuery will return up to
     *   2 partitions, to complete the total of 10 specified in `partition_count`.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Reads documents as they were at the given time.
     *
     *   This must be a microsecond precision timestamp within the past one hour,
     *   or if Point-in-Time Recovery is enabled, can additionally be a whole
     *   minute timestamp within the past 7 days.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.firestore.v1.Cursor|Cursor}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore.partition_query.js</caption>
     * region_tag:firestore_v1_generated_Firestore_PartitionQuery_async
     */ partitionQueryAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['partitionQuery'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.partitionQuery.asyncIterate(this.innerApiCalls['partitionQuery'], request, callSettings);
    }
    listCollectionIds(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listCollectionIds(request, options, callback);
    }
    /**
     * Equivalent to `listCollectionIds`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent document. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   For example:
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {number} request.pageSize
     *   The maximum number of results to return.
     * @param {string} request.pageToken
     *   A page token. Must be a value from
     *   {@link protos.google.firestore.v1.ListCollectionIdsResponse|ListCollectionIdsResponse}.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Reads documents as they were at the given time.
     *
     *   This must be a microsecond precision timestamp within the past one hour,
     *   or if Point-in-Time Recovery is enabled, can additionally be a whole
     *   minute timestamp within the past 7 days.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing string on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listCollectionIdsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listCollectionIdsStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listCollectionIds'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listCollectionIds.createStream(this.innerApiCalls.listCollectionIds, request, callSettings);
    }
    /**
     * Equivalent to `listCollectionIds`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent document. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   For example:
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {number} request.pageSize
     *   The maximum number of results to return.
     * @param {string} request.pageToken
     *   A page token. Must be a value from
     *   {@link protos.google.firestore.v1.ListCollectionIdsResponse|ListCollectionIdsResponse}.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Reads documents as they were at the given time.
     *
     *   This must be a microsecond precision timestamp within the past one hour,
     *   or if Point-in-Time Recovery is enabled, can additionally be a whole
     *   minute timestamp within the past 7 days.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   string. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1/firestore.list_collection_ids.js</caption>
     * region_tag:firestore_v1_generated_Firestore_ListCollectionIds_async
     */ listCollectionIdsAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listCollectionIds'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listCollectionIds.asyncIterate(this.innerApiCalls['listCollectionIds'], request, callSettings);
    }
    /**
     * Gets information about a location.
     *
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.name
     *   Resource name for the location.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html | CallOptions} for more details.
     * @returns {Promise} - The promise which resolves to an array.
     *   The first element of the array is an object representing {@link google.cloud.location.Location | Location}.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
     *   for more details and examples.
     * @example
     * ```
     * const [response] = await client.getLocation(request);
     * ```
     */ getLocation(request, options, callback) {
        return this.locationsClient.getLocation(request, options, callback);
    }
    /**
     * Lists information about the supported locations for this service. Returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.name
     *   The resource that owns the locations collection, if applicable.
     * @param {string} request.filter
     *   The standard list filter.
     * @param {number} request.pageSize
     *   The standard list page size.
     * @param {string} request.pageToken
     *   The standard list page token.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link google.cloud.location.Location | Location}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example
     * ```
     * const iterable = client.listLocationsAsync(request);
     * for await (const response of iterable) {
     *   // process response
     * }
     * ```
     */ listLocationsAsync(request, options) {
        return this.locationsClient.listLocationsAsync(request, options);
    }
    /**
     * Terminate the gRPC channel and close the client.
     *
     * The client will no longer be usable and all future behavior is undefined.
     * @returns {Promise} A promise that resolves when the client is closed.
     */ close() {
        if (this.firestoreStub && !this._terminated) {
            return this.firestoreStub.then((stub)=>{
                this._terminated = true;
                stub.close();
                this.locationsClient.close();
            });
        }
        return Promise.resolve();
    }
}
exports.FirestoreClient = FirestoreClient; //# sourceMappingURL=firestore_client.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/v1/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FirestoreAdminClient = exports.FirestoreClient = void 0;
const firestore_admin_client_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client.js [app-client] (ecmascript)");
Object.defineProperty(exports, "FirestoreAdminClient", {
    enumerable: true,
    get: function() {
        return firestore_admin_client_1.FirestoreAdminClient;
    }
});
const firestore_client_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_client.js [app-client] (ecmascript)");
Object.defineProperty(exports, "FirestoreClient", {
    enumerable: true,
    get: function() {
        return firestore_client_1.FirestoreClient;
    }
});
// Doing something really horrible for reverse compatibility with original JavaScript exports
const existingExports = module.exports;
module.exports = firestore_client_1.FirestoreClient;
module.exports = Object.assign(module.exports, existingExports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/telemetry/enabled-trace-util.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EnabledTraceUtil = void 0;
const api_1 = __turbopack_context__.r("[project]/node_modules/@opentelemetry/api/build/esm/index.js [app-client] (ecmascript)");
const span_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/span.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
const firestore_client_config_json_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json (json)");
const v1_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1/index.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/index.js [app-client] (ecmascript)");
const serviceConfig = firestore_client_config_json_1.interfaces['google.firestore.v1.Firestore'];
/**
 * @private
 * @internal
 */ class EnabledTraceUtil {
    constructor(settings){
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        let provider = (_a = settings.openTelemetry) === null || _a === void 0 ? void 0 : _a.tracerProvider;
        // If a TracerProvider has not been given to us, we try to use the global one.
        if (!provider) {
            const { trace } = __turbopack_context__.r("[project]/node_modules/@opentelemetry/api/build/esm/index.js [app-client] (ecmascript)");
            provider = trace.getTracerProvider();
        }
        // At this point provider is guaranteed to be defined because
        // `trace.getTracerProvider()` does not return null or undefined.
        this.tracerProvider = provider;
        const libVersion = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/package.json (json)").version;
        const libName = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/package.json (json)").name;
        try {
            this.tracer = this.tracerProvider.getTracer(libName, libVersion);
        } catch (e) {
            throw new Error("The object provided for 'tracerProvider' does not conform to the TracerProvider interface.");
        }
        this.settingsAttributes = {};
        this.settingsAttributes['otel.scope.name'] = libName;
        this.settingsAttributes['otel.scope.version'] = libVersion;
        if (settings.projectId) {
            this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.project_id`] = settings.projectId;
        }
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.database_id`] = settings.databaseId || path_1.DEFAULT_DATABASE_ID;
        const host = (_c = (_b = settings.servicePath) !== null && _b !== void 0 ? _b : settings.host) !== null && _c !== void 0 ? _c : 'firestore.googleapis.com';
        const port = (_d = settings.port) !== null && _d !== void 0 ? _d : v1_1.FirestoreClient.port;
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.host`] = `${host}:${port}`;
        if (settings.preferRest !== undefined) {
            this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.prefer_REST`] = settings.preferRest;
        }
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.max_idle_channels`] = (_e = settings.maxIdleChannels) !== null && _e !== void 0 ? _e : index_1.DEFAULT_MAX_IDLE_CHANNELS;
        const defaultRetrySettings = serviceConfig.retry_params.default;
        const customRetrySettings = (_j = (_h = (_g = (_f = settings.clientConfig) === null || _f === void 0 ? void 0 : _f.interfaces) === null || _g === void 0 ? void 0 : _g['google.firestore.v1.Firestore']) === null || _h === void 0 ? void 0 : _h['retry_params']) === null || _j === void 0 ? void 0 : _j['default'];
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.initial_retry_delay`] = this.millisToSecondString((_k = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.initial_retry_delay_millis) !== null && _k !== void 0 ? _k : defaultRetrySettings.initial_retry_delay_millis);
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.initial_rpc_timeout`] = this.millisToSecondString((_l = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.initial_rpc_timeout_millis) !== null && _l !== void 0 ? _l : defaultRetrySettings.initial_rpc_timeout_millis);
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.total_timeout`] = this.millisToSecondString((_m = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.total_timeout_millis) !== null && _m !== void 0 ? _m : defaultRetrySettings.total_timeout_millis);
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.max_retry_delay`] = this.millisToSecondString((_o = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.max_retry_delay_millis) !== null && _o !== void 0 ? _o : defaultRetrySettings.max_retry_delay_millis);
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.max_rpc_timeout`] = this.millisToSecondString((_p = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.max_rpc_timeout_millis) !== null && _p !== void 0 ? _p : defaultRetrySettings.max_rpc_timeout_millis);
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.retry_delay_multiplier`] = (_q = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.retry_delay_multiplier.toString()) !== null && _q !== void 0 ? _q : defaultRetrySettings.retry_delay_multiplier.toString();
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.rpc_timeout_multiplier`] = (_r = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.rpc_timeout_multiplier.toString()) !== null && _r !== void 0 ? _r : defaultRetrySettings.rpc_timeout_multiplier.toString();
    }
    recordProjectId(projectId) {
        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.project_id`] = projectId;
        this.currentSpan().setAttributes(this.settingsAttributes);
    }
    millisToSecondString(millis) {
        return `${millis / 1000}s`;
    }
    endSpan(otelSpan, error) {
        otelSpan.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: error.message
        });
        otelSpan.recordException(error);
        otelSpan.end();
    }
    startActiveSpan(name, fn, attributes) {
        return this.tracer.startActiveSpan(name, {
            attributes: attributes
        }, (otelSpan)=>{
            this.addCommonAttributes(otelSpan);
            // Note that if `fn` returns a `Promise`, we want the otelSpan to end
            // after the `Promise` has resolved, NOT after the `fn` has returned.
            // Therefore, we should not use a `finally` clause to end the otelSpan.
            try {
                let result = fn(new span_1.Span(otelSpan));
                if (result instanceof Promise) {
                    result = result.then((value)=>{
                        otelSpan.end();
                        return value;
                    }).catch((error)=>{
                        this.endSpan(otelSpan, error);
                        // Returns a Promise.reject the same as the underlying function.
                        return Promise.reject(error);
                    });
                } else {
                    otelSpan.end();
                }
                return result;
            } catch (error) {
                this.endSpan(otelSpan, error);
                // Re-throw the exception to maintain normal error handling.
                throw error;
            }
        });
    }
    startSpan(name) {
        const otelSpan = this.tracer.startSpan(name, undefined, api_1.context.active());
        this.addCommonAttributes(otelSpan);
        return new span_1.Span(otelSpan);
    }
    currentSpan() {
        return new span_1.Span(api_1.trace.getActiveSpan());
    }
    addCommonAttributes(otelSpan) {
        otelSpan.setAttributes(this.settingsAttributes);
    }
}
exports.EnabledTraceUtil = EnabledTraceUtil; //# sourceMappingURL=enabled-trace-util.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client_config.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"interfaces\":{\"google.firestore.v1beta1.Firestore\":{\"retry_codes\":{\"non_idempotent\":[],\"idempotent\":[\"DEADLINE_EXCEEDED\",\"UNAVAILABLE\"]},\"retry_params\":{\"default\":{\"initial_retry_delay_millis\":100,\"retry_delay_multiplier\":1.3,\"max_retry_delay_millis\":60000,\"initial_rpc_timeout_millis\":60000,\"rpc_timeout_multiplier\":1,\"max_rpc_timeout_millis\":60000,\"total_timeout_millis\":600000}},\"methods\":{\"GetDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"ListDocuments\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"UpdateDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"DeleteDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"BatchGetDocuments\":{\"timeout_millis\":300000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"BeginTransaction\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"Commit\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"Rollback\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"RunQuery\":{\"timeout_millis\":300000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"PartitionQuery\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"Write\":{\"timeout_millis\":86400000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"Listen\":{\"timeout_millis\":86400000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"ListCollectionIds\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"BatchWrite\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"CreateDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"}}}}}"));}}),
"[project]/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FirestoreClient = void 0;
const stream_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
const jsonProtos = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/protos/v1beta1.json (json)");
/**
 * Client JSON configuration object, loaded from
 * `src/v1beta1/firestore_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */ const gapicConfig = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client_config.json (json)");
// tslint:disable deprecation
const version = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/package.json (json)").version;
/**
 *  The Cloud Firestore service.
 *
 *  Cloud Firestore is a fast, fully managed, serverless, cloud-native NoSQL
 *  document database that simplifies storing, syncing, and querying data for
 *  your mobile, web, and IoT apps at global scale. Its client libraries provide
 *  live synchronization and offline support, while its security features and
 *  integrations with Firebase and Google Cloud Platform (GCP) accelerate
 *  building truly serverless apps.
 * @class
 * @deprecated Use v1/firestore_client instead.
 * @memberof v1beta1
 */ class FirestoreClient {
    /**
     * Construct an instance of FirestoreClient.
     *
     * @param {object} [options] - The configuration object.
     * The options accepted by the constructor are described in detail
     * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).
     * The common options are:
     * @param {object} [options.credentials] - Credentials object.
     * @param {string} [options.credentials.client_email]
     * @param {string} [options.credentials.private_key]
     * @param {string} [options.email] - Account email address. Required when
     *     using a .pem or .p12 keyFilename.
     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
     *     .p12 key downloaded from the Google Developers Console. If you provide
     *     a path to a JSON file, the projectId option below is not necessary.
     *     NOTE: .pem and .p12 require you to specify options.email as well.
     * @param {number} [options.port] - The port on which to connect to
     *     the remote host.
     * @param {string} [options.projectId] - The project ID from the Google
     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
     *     the environment variable GCLOUD_PROJECT for your project ID. If your
     *     app is running in an environment which supports
     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
     *     your project ID will be detected automatically.
     * @param {string} [options.apiEndpoint] - The domain name of the
     *     API remote host.
     * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
     *     Follows the structure of {@link gapicConfig}.
     * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.
     *     For more information, please check the
     *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.
     * @param {gax} [gaxInstance]: loaded instance of `google-gax`. Useful if you
     *     need to avoid loading the default gRPC version and want to use the fallback
     *     HTTP implementation. Load only fallback version and pass it to the constructor:
     *     ```
     *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC
     *     const client = new FirestoreClient({fallback: true}, gax);
     *     ```
     */ constructor(opts, gaxInstance){
        var _a, _b, _c, _d, _e;
        this._terminated = false;
        this.descriptors = {
            page: {},
            stream: {},
            longrunning: {},
            batching: {}
        };
        // Ensure that options include all the required fields.
        const staticMembers = this.constructor;
        if ((opts === null || opts === void 0 ? void 0 : opts.universe_domain) && (opts === null || opts === void 0 ? void 0 : opts.universeDomain) && (opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== (opts === null || opts === void 0 ? void 0 : opts.universeDomain)) {
            throw new Error('Please set either universe_domain or universeDomain, but not both.');
        }
        const universeDomainEnvVar = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env === 'object' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] : undefined;
        this._universeDomain = (_c = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.universeDomain) !== null && _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== null && _b !== void 0 ? _b : universeDomainEnvVar) !== null && _c !== void 0 ? _c : 'googleapis.com';
        this._servicePath = 'firestore.' + this._universeDomain;
        const servicePath = (opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint) || this._servicePath;
        this._providedCustomServicePath = !!((opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint));
        const port = (opts === null || opts === void 0 ? void 0 : opts.port) || staticMembers.port;
        const clientConfig = (_d = opts === null || opts === void 0 ? void 0 : opts.clientConfig) !== null && _d !== void 0 ? _d : {};
        const fallback = (_e = opts === null || opts === void 0 ? void 0 : opts.fallback) !== null && _e !== void 0 ? _e : typeof window !== 'undefined' && typeof (window === null || window === void 0 ? void 0 : window.fetch) === 'function';
        opts = Object.assign({
            servicePath,
            port,
            clientConfig,
            fallback
        }, opts);
        // Request numeric enum values if REST transport is used.
        opts.numericEnums = true;
        // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
        if (servicePath !== this._servicePath && !('scopes' in opts)) {
            opts['scopes'] = staticMembers.scopes;
        }
        // Load google-gax module synchronously if needed
        if (!gaxInstance) {
            gaxInstance = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)");
        }
        // Choose either gRPC or proto-over-HTTP implementation of google-gax.
        this._gaxModule = opts.fallback ? gaxInstance.fallback : gaxInstance;
        // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);
        // Save options to use in initialize() method.
        this._opts = opts;
        // Save the auth object to the client, for use by other methods.
        this.auth = this._gaxGrpc.auth;
        // Set useJWTAccessWithScope on the auth object.
        this.auth.useJWTAccessWithScope = true;
        // Set defaultServicePath on the auth object.
        this.auth.defaultServicePath = this._servicePath;
        // Set the default scopes in auth client if needed.
        if (servicePath === this._servicePath) {
            this.auth.defaultScopes = staticMembers.scopes;
        }
        // Determine the client header string.
        const clientHeader = [
            `gax/${this._gaxModule.version}`,
            `gapic/${version}`
        ];
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && 'versions' in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            clientHeader.push(`gl-node/${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node}`);
        } else {
            clientHeader.push(`gl-web/${this._gaxModule.version}`);
        }
        if (!opts.fallback) {
            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
        } else {
            clientHeader.push(`rest/${this._gaxGrpc.grpcVersion}`);
        }
        if (opts.libName && opts.libVersion) {
            clientHeader.push(`${opts.libName}/${opts.libVersion}`);
        }
        // Load the applicable protos.
        this._protos = this._gaxGrpc.loadProtoJSON(jsonProtos);
        // Some of the methods on this service return "paged" results,
        // (e.g. 50 results at a time, with tokens to get subsequent
        // pages). Denote the keys used for pagination and results.
        this.descriptors.page = {
            listDocuments: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'documents'),
            partitionQuery: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'partitions'),
            listCollectionIds: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'collectionIds')
        };
        // Some of the methods on this service provide streaming responses.
        // Provide descriptors for these.
        this.descriptors.stream = {
            batchGetDocuments: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.SERVER_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),
            runQuery: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.SERVER_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),
            write: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.BIDI_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),
            listen: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.BIDI_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries)
        };
        // Put together the default options sent with requests.
        this._defaults = this._gaxGrpc.constructSettings('google.firestore.v1beta1.Firestore', gapicConfig, opts.clientConfig || {}, {
            'x-goog-api-client': clientHeader.join(' ')
        });
        // Set up a dictionary of "inner API calls"; the core implementation
        // of calling the API is handled in `google-gax`, with this code
        // merely providing the destination and request information.
        this.innerApiCalls = {};
        // Add a warn function to the client constructor so it can be easily tested.
        this.warn = this._gaxModule.warn;
    }
    /**
     * Initialize the client.
     * Performs asynchronous operations (such as authentication) and prepares the client.
     * This function will be called automatically when any class method is called for the
     * first time, but if you need to initialize it before calling an actual method,
     * feel free to call initialize() directly.
     *
     * You can await on this method if you want to make sure the client is initialized.
     *
     * @returns {Promise} A promise that resolves to an authenticated service stub.
     */ initialize() {
        // If the client stub promise is already initialized, return immediately.
        if (this.firestoreStub) {
            return this.firestoreStub;
        }
        // Put together the "service stub" for
        // google.firestore.v1beta1.Firestore.
        this.firestoreStub = this._gaxGrpc.createStub(this._opts.fallback ? this._protos.lookupService('google.firestore.v1beta1.Firestore') : this._protos.google.firestore.v1beta1.Firestore, this._opts, this._providedCustomServicePath);
        // Iterate over each of the methods that the service provides
        // and create an API call method for each.
        const firestoreStubMethods = [
            'getDocument',
            'listDocuments',
            'updateDocument',
            'deleteDocument',
            'batchGetDocuments',
            'beginTransaction',
            'commit',
            'rollback',
            'runQuery',
            'partitionQuery',
            'write',
            'listen',
            'listCollectionIds',
            'batchWrite',
            'createDocument'
        ];
        for (const methodName of firestoreStubMethods){
            const callPromise = this.firestoreStub.then((stub)=>(...args)=>{
                    if (this._terminated) {
                        if (methodName in this.descriptors.stream) {
                            const stream = new stream_1.PassThrough({
                                objectMode: true
                            });
                            setImmediate(()=>{
                                stream.emit('error', new this._gaxModule.GoogleError('The client has already been closed.'));
                            });
                            return stream;
                        }
                        return Promise.reject('The client has already been closed.');
                    }
                    const func = stub[methodName];
                    return func.apply(stub, args);
                }, (err)=>()=>{
                    throw err;
                });
            const descriptor = this.descriptors.page[methodName] || this.descriptors.stream[methodName] || undefined;
            const apiCall = this._gaxModule.createApiCall(callPromise, this._defaults[methodName], descriptor, this._opts.fallback);
            this.innerApiCalls[methodName] = apiCall;
        }
        return this.firestoreStub;
    }
    /**
     * The DNS address for this API service.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get servicePath() {
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning === 'function') {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning('Static servicePath is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'firestore.googleapis.com';
    }
    /**
     * The DNS address for this API service - same as servicePath.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get apiEndpoint() {
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning === 'function') {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning('Static apiEndpoint is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'firestore.googleapis.com';
    }
    /**
     * The DNS address for this API service.
     * @returns {string} The DNS address for this service.
     */ get apiEndpoint() {
        return this._servicePath;
    }
    get universeDomain() {
        return this._universeDomain;
    }
    /**
     * The port for this API service.
     * @returns {number} The default port for this service.
     */ static get port() {
        return 443;
    }
    /**
     * The scopes needed to make gRPC calls for every method defined
     * in this service.
     * @returns {string[]} List of default scopes.
     */ static get scopes() {
        return [
            'https://www.googleapis.com/auth/cloud-platform',
            'https://www.googleapis.com/auth/datastore'
        ];
    }
    /**
     * Return the project ID used by this class.
     * @returns {Promise} A promise that resolves to string containing the project ID.
     */ getProjectId(callback) {
        if (callback) {
            this.auth.getProjectId(callback);
            return;
        }
        return this.auth.getProjectId();
    }
    getDocument(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getDocument(request, options, callback);
    }
    updateDocument(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            'document.name': (_a = request.document.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateDocument(request, options, callback);
    }
    deleteDocument(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteDocument(request, options, callback);
    }
    beginTransaction(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            database: (_a = request.database) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.beginTransaction(request, options, callback);
    }
    commit(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            database: (_a = request.database) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.commit(request, options, callback);
    }
    rollback(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            database: (_a = request.database) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.rollback(request, options, callback);
    }
    batchWrite(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            database: (_a = request.database) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.batchWrite(request, options, callback);
    }
    createDocument(request, optionsOrCallback, callback) {
        var _a, _b;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : '',
            collection_id: (_b = request.collectionId) !== null && _b !== void 0 ? _b : ''
        });
        this.initialize();
        return this.innerApiCalls.createDocument(request, options, callback);
    }
    /**
     * Gets multiple documents.
     *
     * Documents returned by this method are not guaranteed to be returned in the
     * same order that they were requested.
     *
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.database
     *   Required. The database name. In the format:
     *   `projects/{project_id}/databases/{database_id}`.
     * @param {string[]} request.documents
     *   The names of the documents to retrieve. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   The request will fail if any of the document is not a child resource of the
     *   given `database`. Duplicate names will be elided.
     * @param {google.firestore.v1beta1.DocumentMask} request.mask
     *   The fields to return. If not set, returns all fields.
     *
     *   If a document has a field that is not present in this mask, that field will
     *   not be returned in the response.
     * @param {Buffer} request.transaction
     *   Reads documents in a transaction.
     * @param {google.firestore.v1beta1.TransactionOptions} request.newTransaction
     *   Starts a new transaction and reads the documents.
     *   Defaults to a read-only transaction.
     *   The new transaction ID will be returned as the first response in the
     *   stream.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Reads documents as they were at the given time.
     *   This may not be older than 270 seconds.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits {@link protos.google.firestore.v1beta1.BatchGetDocumentsResponse|BatchGetDocumentsResponse} on 'data' event.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#server-streaming | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1beta1/firestore.batch_get_documents.js</caption>
     * region_tag:firestore_v1beta1_generated_Firestore_BatchGetDocuments_async
     */ batchGetDocuments(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            database: (_a = request.database) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.batchGetDocuments(request, options);
    }
    /**
     * Runs a query.
     *
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents` or
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   For example:
     *   `projects/my-project/databases/my-database/documents` or
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {google.firestore.v1beta1.StructuredQuery} request.structuredQuery
     *   A structured query.
     * @param {Buffer} request.transaction
     *   Reads documents in a transaction.
     * @param {google.firestore.v1beta1.TransactionOptions} request.newTransaction
     *   Starts a new transaction and reads the documents.
     *   Defaults to a read-only transaction.
     *   The new transaction ID will be returned as the first response in the
     *   stream.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Reads documents as they were at the given time.
     *   This may not be older than 270 seconds.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits {@link protos.google.firestore.v1beta1.RunQueryResponse|RunQueryResponse} on 'data' event.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#server-streaming | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1beta1/firestore.run_query.js</caption>
     * region_tag:firestore_v1beta1_generated_Firestore_RunQuery_async
     */ runQuery(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.runQuery(request, options);
    }
    /**
     * Streams batches of document updates and deletes, in order.
     *
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which is both readable and writable. It accepts objects
     *   representing {@link protos.google.firestore.v1beta1.WriteRequest|WriteRequest} for write() method, and
     *   will emit objects representing {@link protos.google.firestore.v1beta1.WriteResponse|WriteResponse} on 'data' event asynchronously.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#bi-directional-streaming | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1beta1/firestore.write.js</caption>
     * region_tag:firestore_v1beta1_generated_Firestore_Write_async
     */ write(options) {
        this.initialize();
        return this.innerApiCalls.write(null, options);
    }
    /**
     * Listens to changes.
     *
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which is both readable and writable. It accepts objects
     *   representing {@link protos.google.firestore.v1beta1.ListenRequest|ListenRequest} for write() method, and
     *   will emit objects representing {@link protos.google.firestore.v1beta1.ListenResponse|ListenResponse} on 'data' event asynchronously.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#bi-directional-streaming | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1beta1/firestore.listen.js</caption>
     * region_tag:firestore_v1beta1_generated_Firestore_Listen_async
     */ listen(options) {
        this.initialize();
        return this.innerApiCalls.listen(null, options);
    }
    listDocuments(request, optionsOrCallback, callback) {
        var _a, _b;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : '',
            collection_id: (_b = request.collectionId) !== null && _b !== void 0 ? _b : ''
        });
        this.initialize();
        return this.innerApiCalls.listDocuments(request, options, callback);
    }
    /**
     * Equivalent to `listDocuments`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents` or
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   For example:
     *   `projects/my-project/databases/my-database/documents` or
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {string} request.collectionId
     *   Required. The collection ID, relative to `parent`, to list. For example: `chatrooms`
     *   or `messages`.
     * @param {number} request.pageSize
     *   The maximum number of documents to return.
     * @param {string} request.pageToken
     *   The `next_page_token` value returned from a previous List request, if any.
     * @param {string} request.orderBy
     *   The order to sort results by. For example: `priority desc, name`.
     * @param {google.firestore.v1beta1.DocumentMask} request.mask
     *   The fields to return. If not set, returns all fields.
     *
     *   If a document has a field that is not present in this mask, that field
     *   will not be returned in the response.
     * @param {Buffer} request.transaction
     *   Reads documents in a transaction.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Reads documents as they were at the given time.
     *   This may not be older than 270 seconds.
     * @param {boolean} request.showMissing
     *   If the list should show missing documents. A missing document is a
     *   document that does not exist but has sub-documents. These documents will
     *   be returned with a key but will not have fields, {@link protos.google.firestore.v1beta1.Document.create_time|Document.create_time},
     *   or {@link protos.google.firestore.v1beta1.Document.update_time|Document.update_time} set.
     *
     *   Requests with `show_missing` may not specify `where` or
     *   `order_by`.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.firestore.v1beta1.Document|Document} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listDocumentsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listDocumentsStream(request, options) {
        var _a, _b;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : '',
            collection_id: (_b = request.collectionId) !== null && _b !== void 0 ? _b : ''
        });
        const defaultCallSettings = this._defaults['listDocuments'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listDocuments.createStream(this.innerApiCalls.listDocuments, request, callSettings);
    }
    /**
     * Equivalent to `listDocuments`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents` or
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   For example:
     *   `projects/my-project/databases/my-database/documents` or
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {string} request.collectionId
     *   Required. The collection ID, relative to `parent`, to list. For example: `chatrooms`
     *   or `messages`.
     * @param {number} request.pageSize
     *   The maximum number of documents to return.
     * @param {string} request.pageToken
     *   The `next_page_token` value returned from a previous List request, if any.
     * @param {string} request.orderBy
     *   The order to sort results by. For example: `priority desc, name`.
     * @param {google.firestore.v1beta1.DocumentMask} request.mask
     *   The fields to return. If not set, returns all fields.
     *
     *   If a document has a field that is not present in this mask, that field
     *   will not be returned in the response.
     * @param {Buffer} request.transaction
     *   Reads documents in a transaction.
     * @param {google.protobuf.Timestamp} request.readTime
     *   Reads documents as they were at the given time.
     *   This may not be older than 270 seconds.
     * @param {boolean} request.showMissing
     *   If the list should show missing documents. A missing document is a
     *   document that does not exist but has sub-documents. These documents will
     *   be returned with a key but will not have fields, {@link protos.google.firestore.v1beta1.Document.create_time|Document.create_time},
     *   or {@link protos.google.firestore.v1beta1.Document.update_time|Document.update_time} set.
     *
     *   Requests with `show_missing` may not specify `where` or
     *   `order_by`.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.firestore.v1beta1.Document|Document}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1beta1/firestore.list_documents.js</caption>
     * region_tag:firestore_v1beta1_generated_Firestore_ListDocuments_async
     */ listDocumentsAsync(request, options) {
        var _a, _b;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : '',
            collection_id: (_b = request.collectionId) !== null && _b !== void 0 ? _b : ''
        });
        const defaultCallSettings = this._defaults['listDocuments'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listDocuments.asyncIterate(this.innerApiCalls['listDocuments'], request, callSettings);
    }
    partitionQuery(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.partitionQuery(request, options, callback);
    }
    /**
     * Equivalent to `partitionQuery`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents`.
     *   Document resource names are not supported; only database resource names
     *   can be specified.
     * @param {google.firestore.v1beta1.StructuredQuery} request.structuredQuery
     *   A structured query.
     *   Query must specify collection with all descendants and be ordered by name
     *   ascending. Other filters, order bys, limits, offsets, and start/end
     *   cursors are not supported.
     * @param {number} request.partitionCount
     *   The desired maximum number of partition points.
     *   The partitions may be returned across multiple pages of results.
     *   The number must be positive. The actual number of partitions
     *   returned may be fewer.
     *
     *   For example, this may be set to one fewer than the number of parallel
     *   queries to be run, or in running a data pipeline job, one fewer than the
     *   number of workers or compute instances available.
     * @param {string} request.pageToken
     *   The `next_page_token` value returned from a previous call to
     *   PartitionQuery that may be used to get an additional set of results.
     *   There are no ordering guarantees between sets of results. Thus, using
     *   multiple sets of results will require merging the different result sets.
     *
     *   For example, two subsequent calls using a page_token may return:
     *
     *    * cursor B, cursor M, cursor Q
     *    * cursor A, cursor U, cursor W
     *
     *   To obtain a complete result set ordered with respect to the results of the
     *   query supplied to PartitionQuery, the results sets should be merged:
     *   cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W
     * @param {number} request.pageSize
     *   The maximum number of partitions to return in this call, subject to
     *   `partition_count`.
     *
     *   For example, if `partition_count` = 10 and `page_size` = 8, the first call
     *   to PartitionQuery will return up to 8 partitions and a `next_page_token`
     *   if more results exist. A second call to PartitionQuery will return up to
     *   2 partitions, to complete the total of 10 specified in `partition_count`.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.firestore.v1beta1.Cursor|Cursor} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `partitionQueryAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ partitionQueryStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['partitionQuery'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.partitionQuery.createStream(this.innerApiCalls.partitionQuery, request, callSettings);
    }
    /**
     * Equivalent to `partitionQuery`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource name. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents`.
     *   Document resource names are not supported; only database resource names
     *   can be specified.
     * @param {google.firestore.v1beta1.StructuredQuery} request.structuredQuery
     *   A structured query.
     *   Query must specify collection with all descendants and be ordered by name
     *   ascending. Other filters, order bys, limits, offsets, and start/end
     *   cursors are not supported.
     * @param {number} request.partitionCount
     *   The desired maximum number of partition points.
     *   The partitions may be returned across multiple pages of results.
     *   The number must be positive. The actual number of partitions
     *   returned may be fewer.
     *
     *   For example, this may be set to one fewer than the number of parallel
     *   queries to be run, or in running a data pipeline job, one fewer than the
     *   number of workers or compute instances available.
     * @param {string} request.pageToken
     *   The `next_page_token` value returned from a previous call to
     *   PartitionQuery that may be used to get an additional set of results.
     *   There are no ordering guarantees between sets of results. Thus, using
     *   multiple sets of results will require merging the different result sets.
     *
     *   For example, two subsequent calls using a page_token may return:
     *
     *    * cursor B, cursor M, cursor Q
     *    * cursor A, cursor U, cursor W
     *
     *   To obtain a complete result set ordered with respect to the results of the
     *   query supplied to PartitionQuery, the results sets should be merged:
     *   cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W
     * @param {number} request.pageSize
     *   The maximum number of partitions to return in this call, subject to
     *   `partition_count`.
     *
     *   For example, if `partition_count` = 10 and `page_size` = 8, the first call
     *   to PartitionQuery will return up to 8 partitions and a `next_page_token`
     *   if more results exist. A second call to PartitionQuery will return up to
     *   2 partitions, to complete the total of 10 specified in `partition_count`.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.firestore.v1beta1.Cursor|Cursor}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1beta1/firestore.partition_query.js</caption>
     * region_tag:firestore_v1beta1_generated_Firestore_PartitionQuery_async
     */ partitionQueryAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['partitionQuery'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.partitionQuery.asyncIterate(this.innerApiCalls['partitionQuery'], request, callSettings);
    }
    listCollectionIds(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listCollectionIds(request, options, callback);
    }
    /**
     * Equivalent to `listCollectionIds`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent document. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   For example:
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {number} request.pageSize
     *   The maximum number of results to return.
     * @param {string} request.pageToken
     *   A page token. Must be a value from
     *   {@link protos.google.firestore.v1beta1.ListCollectionIdsResponse|ListCollectionIdsResponse}.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing string on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listCollectionIdsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listCollectionIdsStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listCollectionIds'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listCollectionIds.createStream(this.innerApiCalls.listCollectionIds, request, callSettings);
    }
    /**
     * Equivalent to `listCollectionIds`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent document. In the format:
     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *   For example:
     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
     * @param {number} request.pageSize
     *   The maximum number of results to return.
     * @param {string} request.pageToken
     *   A page token. Must be a value from
     *   {@link protos.google.firestore.v1beta1.ListCollectionIdsResponse|ListCollectionIdsResponse}.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   string. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v1beta1/firestore.list_collection_ids.js</caption>
     * region_tag:firestore_v1beta1_generated_Firestore_ListCollectionIds_async
     */ listCollectionIdsAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listCollectionIds'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listCollectionIds.asyncIterate(this.innerApiCalls['listCollectionIds'], request, callSettings);
    }
    /**
     * Terminate the gRPC channel and close the client.
     *
     * The client will no longer be usable and all future behavior is undefined.
     * @returns {Promise} A promise that resolves when the client is closed.
     */ close() {
        if (this.firestoreStub && !this._terminated) {
            return this.firestoreStub.then((stub)=>{
                this._terminated = true;
                stub.close();
            });
        }
        return Promise.resolve();
    }
}
exports.FirestoreClient = FirestoreClient; //# sourceMappingURL=firestore_client.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/v1beta1/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FirestoreClient = void 0;
// tslint:disable deprecation
const firestore_client_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client.js [app-client] (ecmascript)");
Object.defineProperty(exports, "FirestoreClient", {
    enumerable: true,
    get: function() {
        return firestore_client_1.FirestoreClient;
    }
});
// Doing something really horrible for reverse compatibility with original JavaScript exports
const existingExports = module.exports;
module.exports = firestore_client_1.FirestoreClient;
module.exports = Object.assign(module.exports, existingExports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/firestore/build/src/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Firestore = exports.DEFAULT_MAX_IDLE_CHANNELS = exports.DEFAULT_MAX_TRANSACTION_ATTEMPTS = exports.MAX_REQUEST_RETRIES = exports.AggregateField = exports.Aggregate = exports.setLogFunction = exports.QueryPartition = exports.CollectionGroup = exports.GeoPoint = exports.FieldPath = exports.DocumentChange = exports.Timestamp = exports.Transaction = exports.WriteResult = exports.WriteBatch = exports.Filter = exports.VectorValue = exports.FieldValue = exports.QueryDocumentSnapshot = exports.DocumentSnapshot = exports.BulkWriter = exports.Query = exports.QuerySnapshot = exports.DocumentReference = exports.CollectionReference = void 0;
const stream_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
const url_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)");
const backoff_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/backoff.js [app-client] (ecmascript)");
const bulk_writer_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/bulk-writer.js [app-client] (ecmascript)");
const bundle_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/bundle.js [app-client] (ecmascript)");
const convert_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/convert.js [app-client] (ecmascript)");
const document_reader_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document-reader.js [app-client] (ecmascript)");
const document_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
const pool_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/pool.js [app-client] (ecmascript)");
const collection_reference_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/collection-reference.js [app-client] (ecmascript)");
const document_reference_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js [app-client] (ecmascript)");
const serializer_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/serializer.js [app-client] (ecmascript)");
const timestamp_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
const transaction_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/transaction.js [app-client] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/util.js [app-client] (ecmascript)");
const validate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/validate.js [app-client] (ecmascript)");
const write_batch_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/write-batch.js [app-client] (ecmascript)");
const firestore_client_config_json_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json (json)");
const serviceConfig = firestore_client_config_json_1.interfaces['google.firestore.v1.Firestore'];
const collection_group_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/collection-group.js [app-client] (ecmascript)");
Object.defineProperty(exports, "CollectionGroup", {
    enumerable: true,
    get: function() {
        return collection_group_1.CollectionGroup;
    }
});
const recursive_delete_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/recursive-delete.js [app-client] (ecmascript)");
const trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/trace-util.js [app-client] (ecmascript)");
const disabled_trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/disabled-trace-util.js [app-client] (ecmascript)");
const enabled_trace_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/telemetry/enabled-trace-util.js [app-client] (ecmascript)");
var collection_reference_2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/collection-reference.js [app-client] (ecmascript)");
Object.defineProperty(exports, "CollectionReference", {
    enumerable: true,
    get: function() {
        return collection_reference_2.CollectionReference;
    }
});
var document_reference_2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js [app-client] (ecmascript)");
Object.defineProperty(exports, "DocumentReference", {
    enumerable: true,
    get: function() {
        return document_reference_2.DocumentReference;
    }
});
var query_snapshot_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query-snapshot.js [app-client] (ecmascript)");
Object.defineProperty(exports, "QuerySnapshot", {
    enumerable: true,
    get: function() {
        return query_snapshot_1.QuerySnapshot;
    }
});
var query_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/reference/query.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Query", {
    enumerable: true,
    get: function() {
        return query_1.Query;
    }
});
var bulk_writer_2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/bulk-writer.js [app-client] (ecmascript)");
Object.defineProperty(exports, "BulkWriter", {
    enumerable: true,
    get: function() {
        return bulk_writer_2.BulkWriter;
    }
});
var document_2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document.js [app-client] (ecmascript)");
Object.defineProperty(exports, "DocumentSnapshot", {
    enumerable: true,
    get: function() {
        return document_2.DocumentSnapshot;
    }
});
Object.defineProperty(exports, "QueryDocumentSnapshot", {
    enumerable: true,
    get: function() {
        return document_2.QueryDocumentSnapshot;
    }
});
var field_value_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/field-value.js [app-client] (ecmascript)");
Object.defineProperty(exports, "FieldValue", {
    enumerable: true,
    get: function() {
        return field_value_1.FieldValue;
    }
});
Object.defineProperty(exports, "VectorValue", {
    enumerable: true,
    get: function() {
        return field_value_1.VectorValue;
    }
});
var filter_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/filter.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Filter", {
    enumerable: true,
    get: function() {
        return filter_1.Filter;
    }
});
var write_batch_2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/write-batch.js [app-client] (ecmascript)");
Object.defineProperty(exports, "WriteBatch", {
    enumerable: true,
    get: function() {
        return write_batch_2.WriteBatch;
    }
});
Object.defineProperty(exports, "WriteResult", {
    enumerable: true,
    get: function() {
        return write_batch_2.WriteResult;
    }
});
var transaction_2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/transaction.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Transaction", {
    enumerable: true,
    get: function() {
        return transaction_2.Transaction;
    }
});
var timestamp_2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/timestamp.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Timestamp", {
    enumerable: true,
    get: function() {
        return timestamp_2.Timestamp;
    }
});
var document_change_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/document-change.js [app-client] (ecmascript)");
Object.defineProperty(exports, "DocumentChange", {
    enumerable: true,
    get: function() {
        return document_change_1.DocumentChange;
    }
});
var path_2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/path.js [app-client] (ecmascript)");
Object.defineProperty(exports, "FieldPath", {
    enumerable: true,
    get: function() {
        return path_2.FieldPath;
    }
});
var geo_point_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/geo-point.js [app-client] (ecmascript)");
Object.defineProperty(exports, "GeoPoint", {
    enumerable: true,
    get: function() {
        return geo_point_1.GeoPoint;
    }
});
var query_partition_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/query-partition.js [app-client] (ecmascript)");
Object.defineProperty(exports, "QueryPartition", {
    enumerable: true,
    get: function() {
        return query_partition_1.QueryPartition;
    }
});
var logger_2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/logger.js [app-client] (ecmascript)");
Object.defineProperty(exports, "setLogFunction", {
    enumerable: true,
    get: function() {
        return logger_2.setLogFunction;
    }
});
var aggregate_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/aggregate.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Aggregate", {
    enumerable: true,
    get: function() {
        return aggregate_1.Aggregate;
    }
});
Object.defineProperty(exports, "AggregateField", {
    enumerable: true,
    get: function() {
        return aggregate_1.AggregateField;
    }
});
const libVersion = __turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/package.json (json)").version;
(0, logger_1.setLibVersion)(libVersion);
/*!
 * DO NOT REMOVE THE FOLLOWING NAMESPACE DEFINITIONS
 */ /**
 * @namespace google.protobuf
 */ /**
 * @namespace google.rpc
 */ /**
 * @namespace google.longrunning
 */ /**
 * @namespace google.firestore.v1
 */ /**
 * @namespace google.firestore.v1beta1
 */ /**
 * @namespace google.firestore.admin.v1
 */ /*!
 * HTTP header for the resource prefix to improve routing and project isolation
 * by the backend.
 */ const CLOUD_RESOURCE_HEADER = 'google-cloud-resource-prefix';
/**
 * The maximum number of times to retry idempotent requests.
 * @private
 */ exports.MAX_REQUEST_RETRIES = 5;
/**
 * The maximum number of times to attempt a transaction before failing.
 * @private
 */ exports.DEFAULT_MAX_TRANSACTION_ATTEMPTS = 5;
/*!
 * The default number of idle GRPC channel to keep.
 */ exports.DEFAULT_MAX_IDLE_CHANNELS = 1;
/*!
 * The maximum number of concurrent requests supported by a single GRPC channel,
 * as enforced by Google's Frontend. If the SDK issues more than 100 concurrent
 * operations, we need to use more than one GAPIC client since these clients
 * multiplex all requests over a single channel.
 */ const MAX_CONCURRENT_REQUESTS_PER_CLIENT = 100;
/**
 * Document data (e.g. for use with
 * [set()]{@link DocumentReference#set}) consisting of fields mapped
 * to values.
 *
 * @typedef {Object.<string, *>} DocumentData
 */ /**
 * Converter used by [withConverter()]{@link Query#withConverter} to transform
 * user objects of type `AppModelType` into Firestore data of type
 * `DbModelType`.
 *
 * Using the converter allows you to specify generic type arguments when storing
 * and retrieving objects from Firestore.
 *
 * @example
 * ```
 * class Post {
 *   constructor(readonly title: string, readonly author: string) {}
 *
 *   toString(): string {
 *     return this.title + ', by ' + this.author;
 *   }
 * }
 *
 * const postConverter = {
 *   toFirestore(post: Post): FirebaseFirestore.DocumentData {
 *     return {title: post.title, author: post.author};
 *   },
 *   fromFirestore(
 *     snapshot: FirebaseFirestore.QueryDocumentSnapshot
 *   ): Post {
 *     const data = snapshot.data();
 *     return new Post(data.title, data.author);
 *   }
 * };
 *
 * const postSnap = await Firestore()
 *   .collection('posts')
 *   .withConverter(postConverter)
 *   .doc().get();
 * const post = postSnap.data();
 * if (post !== undefined) {
 *   post.title; // string
 *   post.toString(); // Should be defined
 *   post.someNonExistentProperty; // TS error
 * }
 *
 * ```
 * @property {Function} toFirestore Called by the Firestore SDK to convert a
 * custom model object of type `AppModelType` into a plain Javascript object
 * (suitable for writing directly to the Firestore database).
 * @property {Function} fromFirestore Called by the Firestore SDK to convert
 * Firestore data into an object of type `AppModelType`.
 * @typedef {Object} FirestoreDataConverter
 */ /**
 * Update data (for use with [update]{@link DocumentReference#update})
 * that contains paths mapped to values. Fields that contain dots
 * reference nested fields within the document.
 *
 * You can update a top-level field in your document by using the field name
 * as a key (e.g. `foo`). The provided value completely replaces the contents
 * for this field.
 *
 * You can also update a nested field directly by using its field path as a key
 * (e.g. `foo.bar`). This nested field update replaces the contents at `bar`
 * but does not modify other data under `foo`.
 *
 * @example
 * ```
 * const documentRef = firestore.doc('coll/doc');
 * documentRef.set({a1: {a2: 'val'}, b1: {b2: 'val'}, c1: {c2: 'val'}});
 * documentRef.update({
 *  b1: {b3: 'val'},
 *  'c1.c3': 'val',
 * });
 * // Value is {a1: {a2: 'val'}, b1: {b3: 'val'}, c1: {c2: 'val', c3: 'val'}}
 *
 * ```
 * @typedef {Object.<string, *>} UpdateData
 */ /**
 * An options object that configures conditional behavior of
 * [update()]{@link DocumentReference#update} and
 * [delete()]{@link DocumentReference#delete} calls in
 * [DocumentReference]{@link DocumentReference},
 * [WriteBatch]{@link WriteBatch}, [BulkWriter]{@link BulkWriter}, and
 * [Transaction]{@link Transaction}. Using Preconditions, these calls
 * can be restricted to only apply to documents that match the specified
 * conditions.
 *
 * @example
 * ```
 * const documentRef = firestore.doc('coll/doc');
 *
 * documentRef.get().then(snapshot => {
 *   const updateTime = snapshot.updateTime;
 *
 *   console.log(`Deleting document at update time: ${updateTime.toDate()}`);
 *   return documentRef.delete({ lastUpdateTime: updateTime });
 * });
 *
 * ```
 * @property {Timestamp} lastUpdateTime The update time to enforce. If set,
 *  enforces that the document was last updated at lastUpdateTime. Fails the
 *  operation if the document was last updated at a different time.
 * @property {boolean} exists If set, enforces that the target document must
 * or must not exist.
 * @typedef {Object} Precondition
 */ /**
 * An options object that configures the behavior of
 * [set()]{@link DocumentReference#set} calls in
 * [DocumentReference]{@link DocumentReference},
 * [WriteBatch]{@link WriteBatch}, and
 * [Transaction]{@link Transaction}. These calls can be
 * configured to perform granular merges instead of overwriting the target
 * documents in their entirety by providing a SetOptions object with
 * { merge : true }.
 *
 * @property {boolean} merge Changes the behavior of a set() call to only
 * replace the values specified in its data argument. Fields omitted from the
 * set() call remain untouched.
 * @property {Array<(string|FieldPath)>} mergeFields Changes the behavior of
 * set() calls to only replace the specified field paths. Any field path that is
 * not specified is ignored and remains untouched.
 * It is an error to pass a SetOptions object to a set() call that is missing a
 * value for any of the fields specified here.
 * @typedef {Object} SetOptions
 */ /**
 * An options object that can be used to configure the behavior of
 * [getAll()]{@link Firestore#getAll} calls. By providing a `fieldMask`, these
 * calls can be configured to only return a subset of fields.
 *
 * @property {Array<(string|FieldPath)>} fieldMask Specifies the set of fields
 * to return and reduces the amount of data transmitted by the backend.
 * Adding a field mask does not filter results. Documents do not need to
 * contain values for all the fields in the mask to be part of the result set.
 * @typedef {Object} ReadOptions
 */ /**
 * An options object to configure throttling on BulkWriter.
 *
 * Whether to disable or configure throttling. By default, throttling is
 * enabled. `throttling` can be set to either a boolean or a config object.
 * Setting it to `true` will use default values. You can override the defaults
 * by setting it to `false` to disable throttling, or by setting the config
 * values to enable throttling with the provided values.
 *
 * @property {boolean|Object} throttling Whether to disable or enable
 * throttling. Throttling is enabled by default, if the field is set to `true`
 * or if any custom throttling options are provided. `{ initialOpsPerSecond:
 * number }` sets the initial maximum number of operations per second allowed by
 * the throttler. If `initialOpsPerSecond` is not set, the default is 500
 * operations per second. `{ maxOpsPerSecond: number }` sets the maximum number
 * of operations per second allowed by the throttler. If `maxOpsPerSecond` is
 * not set, no maximum is enforced.
 * @typedef {Object} BulkWriterOptions
 */ /**
 * An error thrown when a BulkWriter operation fails.
 *
 * The error used by {@link BulkWriter~shouldRetryCallback} set in
 * {@link BulkWriter#onWriteError}.
 *
 * @property {GrpcStatus} code The status code of the error.
 * @property {string} message The error message of the error.
 * @property {DocumentReference} documentRef The document reference the
 * operation was performed on.
 * @property {'create' | 'set' | 'update' | 'delete'} operationType The type
 * of operation performed.
 * @property {number} failedAttempts How many times this operation has been
 * attempted unsuccessfully.
 * @typedef {Error} BulkWriterError
 */ /**
 * Status codes returned by GRPC operations.
 *
 * @see https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
 *
 * @enum {number}
 * @typedef {Object} GrpcStatus
 */ /**
 * The Firestore client represents a Firestore Database and is the entry point
 * for all Firestore operations.
 *
 * @see [Firestore Documentation]{@link https://firebase.google.com/docs/firestore/}
 *
 * @class
 *
 * @example Install the client library with <a href="https://www.npmjs.com/">npm</a>:
 * ```
 * npm install --save @google-cloud/firestore
 *
 * ```
 * @example Import the client library
 * ```
 * var Firestore = require('@google-cloud/firestore');
 *
 * ```
 * @example Create a client that uses <a href="https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application">Application Default Credentials (ADC)</a>:
 * ```
 * var firestore = new Firestore();
 *
 * ```
 * @example Create a client with <a href="https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually">explicit credentials</a>:
 * ```
 * var firestore = new Firestore({ projectId:
 * 'your-project-id', keyFilename: '/path/to/keyfile.json'
 * });
 *
 * ```
 * @example <caption>include:samples/quickstart.js</caption>
 * region_tag:firestore_quickstart
 * Full quickstart example:
 */ class Firestore {
    /**
     * Lazy-load the Firestore's default BulkWriter.
     *
     * @private
     * @internal
     */ getBulkWriter() {
        if (!this._bulkWriter) {
            this._bulkWriter = this.bulkWriter();
        }
        return this._bulkWriter;
    }
    /**
     * @param {Object=} settings [Configuration object](#/docs).
     * @param {string=} settings.projectId The project ID from the Google
     * Developer's Console, e.g. 'grape-spaceship-123'. We will also check the
     * environment variable GCLOUD_PROJECT for your project ID.  Can be omitted in
     * environments that support
     * {@link https://cloud.google.com/docs/authentication Application Default
     * Credentials}
     * @param {string=} settings.keyFilename Local file containing the Service
     * Account credentials as downloaded from the Google Developers Console. Can
     * be omitted in environments that support
     * {@link https://cloud.google.com/docs/authentication Application Default
     * Credentials}. To configure Firestore with custom credentials, use
     * `settings.credentials` and provide the `client_email` and `private_key` of
     * your service account.
     * @param {{client_email:string=, private_key:string=}=} settings.credentials
     * The `client_email` and `private_key` properties of the service account
     * to use with your Firestore project. Can be omitted in environments that
     * support {@link https://cloud.google.com/docs/authentication Application
     * Default Credentials}. If your credentials are stored in a JSON file, you
     * can specify a `keyFilename` instead.
     * @param {string=} settings.host The host to connect to.
     * @param {boolean=} settings.ssl Whether to use SSL when connecting.
     * @param {number=} settings.maxIdleChannels The maximum number of idle GRPC
     * channels to keep. A smaller number of idle channels reduces memory usage
     * but increases request latency for clients with fluctuating request rates.
     * If set to 0, shuts down all GRPC channels when the client becomes idle.
     * Defaults to 1.
     * @param {boolean=} settings.ignoreUndefinedProperties Whether to skip nested
     * properties that are set to `undefined` during object serialization. If set
     * to `true`, these properties are skipped and not written to Firestore. If
     * set `false` or omitted, the SDK throws an exception when it encounters
     * properties of type `undefined`.
     * @param {boolean=} settings.preferRest Whether to force the use of HTTP/1.1 REST
     * transport until a method that requires gRPC is called. When a method requires gRPC,
     * this Firestore client will load dependent gRPC libraries and then use gRPC transport
     * for communication from that point forward. Currently the only operation
     * that requires gRPC is creating a snapshot listener with the method
     * `DocumentReference<T>.onSnapshot()`, `CollectionReference<T>.onSnapshot()`, or
     * `Query<T>.onSnapshot()`. If specified, this setting value will take precedent over the
     * environment variable `FIRESTORE_PREFER_REST`. If not specified, the
     * SDK will use the value specified in the environment variable `FIRESTORE_PREFER_REST`.
     * Valid values of `FIRESTORE_PREFER_REST` are `true` ('1') or `false` (`0`). Values are
     * not case-sensitive. Any other value for the environment variable will be ignored and
     * a warning will be logged to the console.
     */ constructor(settings){
        /**
         * The configuration options for the GAPIC client.
         * @private
         * @internal
         */ this._settings = {};
        /**
         * Whether the initialization settings can still be changed by invoking
         * `settings()`.
         * @private
         * @internal
         */ this._settingsFrozen = false;
        /**
         * The serializer to use for the Protobuf transformation.
         * @private
         * @internal
         */ this._serializer = null;
        /**
         * The project ID for this client.
         *
         * The project ID is auto-detected during the first request unless a project
         * ID is passed to the constructor (or provided via `.settings()`).
         * @private
         * @internal
         */ this._projectId = undefined;
        /**
         * The database ID provided via `.settings()`.
         *
         * @private
         * @internal
         */ this._databaseId = undefined;
        /**
         * Count of listeners that have been registered on the client.
         *
         * The client can only be terminated when there are no pending writes or
         * registered listeners.
         * @private
         * @internal
         */ this.registeredListenersCount = 0;
        /**
         * Number of pending operations on the client.
         *
         * The client can only be terminated when there are no pending writes or
         * registered listeners.
         * @private
         * @internal
         */ this.bulkWritersCount = 0;
        const libraryHeader = {
            libName: 'gccl',
            libVersion
        };
        if (settings && settings.firebaseVersion) {
            libraryHeader.libVersion += ' fire/' + settings.firebaseVersion;
        }
        if (settings && settings.firebaseAdminVersion) {
            libraryHeader.libVersion += ' fire-admin/' + settings.firebaseAdminVersion;
        }
        this.validateAndApplySettings({
            ...settings,
            ...libraryHeader
        });
        this._traceUtil = this.newTraceUtilInstance(this._settings);
        const retryConfig = serviceConfig.retry_params.default;
        this._backoffSettings = {
            initialDelayMs: retryConfig.initial_retry_delay_millis,
            maxDelayMs: retryConfig.max_retry_delay_millis,
            backoffFactor: retryConfig.retry_delay_multiplier
        };
        const maxIdleChannels = this._settings.maxIdleChannels === undefined ? exports.DEFAULT_MAX_IDLE_CHANNELS : this._settings.maxIdleChannels;
        this._clientPool = new pool_1.ClientPool(MAX_CONCURRENT_REQUESTS_PER_CLIENT, maxIdleChannels, /* clientFactory= */ (requiresGrpc)=>{
            var _a;
            let client;
            // Use the rest fallback if enabled and if the method does not require GRPC
            const useFallback = !this._settings.preferRest || requiresGrpc ? false : 'rest';
            let gax;
            if (useFallback) {
                if (!this._gaxFallback) {
                    gax = this._gaxFallback = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)");
                } else {
                    gax = this._gaxFallback;
                }
            } else {
                if (!this._gax) {
                    gax = this._gax = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)");
                } else {
                    gax = this._gax;
                }
            }
            if (this._settings.ssl === false) {
                const grpcModule = (_a = this._settings.grpc) !== null && _a !== void 0 ? _a : __turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)").grpc;
                const sslCreds = grpcModule.credentials.createInsecure();
                const settings = {
                    sslCreds,
                    ...this._settings,
                    fallback: useFallback
                };
                // Since `ssl === false`, if we're using the GAX fallback then
                // also set the `protocol` option for GAX fallback to force http
                if (useFallback) {
                    settings.protocol = 'http';
                }
                client = new module.exports.v1(settings, gax);
            } else {
                client = new module.exports.v1({
                    ...this._settings,
                    fallback: useFallback
                }, gax);
            }
            (0, logger_1.logger)('clientFactory', null, 'Initialized Firestore GAPIC Client (useFallback: %s)', useFallback);
            return client;
        }, /* clientDestructor= */ (client)=>client.close());
        (0, logger_1.logger)('Firestore', null, 'Initialized Firestore');
    }
    /**
     * Specifies custom settings to be used to configure the `Firestore`
     * instance. Can only be invoked once and before any other Firestore method.
     *
     * If settings are provided via both `settings()` and the `Firestore`
     * constructor, both settings objects are merged and any settings provided via
     * `settings()` take precedence.
     *
     * @param {object} settings The settings to use for all Firestore operations.
     */ settings(settings) {
        (0, validate_1.validateObject)('settings', settings);
        (0, validate_1.validateString)('settings.projectId', settings.projectId, {
            optional: true
        });
        (0, validate_1.validateString)('settings.databaseId', settings.databaseId, {
            optional: true
        });
        if (this._settingsFrozen) {
            throw new Error('Firestore has already been initialized. You can only call ' + 'settings() once, and only before calling any other methods on a ' + 'Firestore object.');
        }
        const mergedSettings = {
            ...this._settings,
            ...settings
        };
        this.validateAndApplySettings(mergedSettings);
        this._traceUtil = this.newTraceUtilInstance(this._settings);
        this._settingsFrozen = true;
    }
    validateAndApplySettings(settings) {
        var _a;
        if (settings.projectId !== undefined) {
            (0, validate_1.validateString)('settings.projectId', settings.projectId);
            this._projectId = settings.projectId;
        }
        if (settings.databaseId !== undefined) {
            (0, validate_1.validateString)('settings.databaseId', settings.databaseId);
            this._databaseId = settings.databaseId;
        }
        let url = null;
        // If preferRest is not specified in settings, but is set as environment variable,
        // then use the environment variable value.
        const preferRestEnvValue = (0, util_1.tryGetPreferRestEnvironmentVariable)();
        if (settings.preferRest === undefined && preferRestEnvValue !== undefined) {
            settings = {
                ...settings,
                preferRest: preferRestEnvValue
            };
        }
        // If the environment variable is set, it should always take precedence
        // over any user passed in settings.
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.FIRESTORE_EMULATOR_HOST) {
            (0, validate_1.validateHost)('FIRESTORE_EMULATOR_HOST', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.FIRESTORE_EMULATOR_HOST);
            settings = {
                ...settings,
                host: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.FIRESTORE_EMULATOR_HOST,
                ssl: false
            };
            url = new url_1.URL(`http://${settings.host}`);
        } else if (settings.host !== undefined) {
            (0, validate_1.validateHost)('settings.host', settings.host);
            url = new url_1.URL(`http://${settings.host}`);
        }
        // Only store the host if a valid value was provided in `host`.
        if (url !== null) {
            if (settings.servicePath !== undefined && settings.servicePath !== url.hostname || settings.apiEndpoint !== undefined && settings.apiEndpoint !== url.hostname) {
                // eslint-disable-next-line no-console
                console.warn(`The provided host (${url.hostname}) in "settings" does not ` + `match the existing host (${(_a = settings.servicePath) !== null && _a !== void 0 ? _a : settings.apiEndpoint}). Using the provided host.`);
            }
            settings.servicePath = url.hostname;
            if (url.port !== '' && settings.port === undefined) {
                settings.port = Number(url.port);
            }
            // We need to remove the `host` and `apiEndpoint` setting, in case a user
            // calls `settings()`, which will compare the the provided `host` to the
            // existing hostname stored on `servicePath`.
            delete settings.host;
            delete settings.apiEndpoint;
        }
        if (settings.ssl !== undefined) {
            (0, validate_1.validateBoolean)('settings.ssl', settings.ssl);
        }
        if (settings.maxIdleChannels !== undefined) {
            (0, validate_1.validateInteger)('settings.maxIdleChannels', settings.maxIdleChannels, {
                minValue: 0
            });
        }
        this._settings = settings;
        this._settings.toJSON = function() {
            const temp = Object.assign({}, this);
            if (temp.credentials) {
                temp.credentials = {
                    private_key: '***',
                    client_email: '***'
                };
            }
            return temp;
        };
        this._serializer = new serializer_1.Serializer(this);
    }
    newTraceUtilInstance(settings) {
        let createEnabledInstance = true;
        // The environment variable can override options to enable/disable telemetry collection.
        if ('FIRESTORE_ENABLE_TRACING' in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env) {
            const enableTracingEnvVar = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.FIRESTORE_ENABLE_TRACING.toLowerCase();
            if (enableTracingEnvVar === 'on' || enableTracingEnvVar === 'true') {
                createEnabledInstance = true;
            }
            if (enableTracingEnvVar === 'off' || enableTracingEnvVar === 'false') {
                createEnabledInstance = false;
            }
        }
        if (createEnabledInstance) {
            return new enabled_trace_util_1.EnabledTraceUtil(settings);
        } else {
            return new disabled_trace_util_1.DisabledTraceUtil();
        }
    }
    /**
     * Returns the Project ID for this Firestore instance. Validates that
     * `initializeIfNeeded()` was called before.
     *
     * @private
     * @internal
     */ get projectId() {
        if (this._projectId === undefined) {
            throw new Error('INTERNAL ERROR: Client is not yet ready to issue requests.');
        }
        return this._projectId;
    }
    /**
     * Returns the Database ID for this Firestore instance.
     */ get databaseId() {
        return this._databaseId || path_1.DEFAULT_DATABASE_ID;
    }
    /**
     * Returns the root path of the database. Validates that
     * `initializeIfNeeded()` was called before.
     *
     * @private
     * @internal
     */ get formattedName() {
        return `projects/${this.projectId}/databases/${this.databaseId}`;
    }
    /**
     * Gets a [DocumentReference]{@link DocumentReference} instance that
     * refers to the document at the specified path.
     *
     * @param {string} documentPath A slash-separated path to a document.
     * @returns {DocumentReference} The
     * [DocumentReference]{@link DocumentReference} instance.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('collection/document');
     * console.log(`Path of document is ${documentRef.path}`);
     * ```
     */ doc(documentPath) {
        (0, path_1.validateResourcePath)('documentPath', documentPath);
        const path = path_1.ResourcePath.EMPTY.append(documentPath);
        if (!path.isDocument) {
            throw new Error(`Value for argument "documentPath" must point to a document, but was "${documentPath}". Your path does not contain an even number of components.`);
        }
        return new document_reference_1.DocumentReference(this, path);
    }
    /**
     * Gets a [CollectionReference]{@link CollectionReference} instance
     * that refers to the collection at the specified path.
     *
     * @param {string} collectionPath A slash-separated path to a collection.
     * @returns {CollectionReference} The
     * [CollectionReference]{@link CollectionReference} instance.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('collection');
     *
     * // Add a document with an auto-generated ID.
     * collectionRef.add({foo: 'bar'}).then((documentRef) => {
     *   console.log(`Added document at ${documentRef.path})`);
     * });
     * ```
     */ collection(collectionPath) {
        (0, path_1.validateResourcePath)('collectionPath', collectionPath);
        const path = path_1.ResourcePath.EMPTY.append(collectionPath);
        if (!path.isCollection) {
            throw new Error(`Value for argument "collectionPath" must point to a collection, but was "${collectionPath}". Your path does not contain an odd number of components.`);
        }
        return new collection_reference_1.CollectionReference(this, path);
    }
    /**
     * Creates and returns a new Query that includes all documents in the
     * database that are contained in a collection or subcollection with the
     * given collectionId.
     *
     * @param {string} collectionId Identifies the collections to query over.
     * Every collection or subcollection with this ID as the last segment of its
     * path will be included. Cannot contain a slash.
     * @returns {CollectionGroup} The created CollectionGroup.
     *
     * @example
     * ```
     * let docA = firestore.doc('mygroup/docA').set({foo: 'bar'});
     * let docB = firestore.doc('abc/def/mygroup/docB').set({foo: 'bar'});
     *
     * Promise.all([docA, docB]).then(() => {
     *    let query = firestore.collectionGroup('mygroup');
     *    query = query.where('foo', '==', 'bar');
     *    return query.get().then(snapshot => {
     *       console.log(`Found ${snapshot.size} documents.`);
     *    });
     * });
     * ```
     */ collectionGroup(collectionId) {
        if (collectionId.indexOf('/') !== -1) {
            throw new Error(`Invalid collectionId '${collectionId}'. Collection IDs must not contain '/'.`);
        }
        return new collection_group_1.CollectionGroup(this, collectionId, /* converter= */ undefined);
    }
    /**
     * Creates a [WriteBatch]{@link WriteBatch}, used for performing
     * multiple writes as a single atomic operation.
     *
     * @returns {WriteBatch} A WriteBatch that operates on this Firestore
     * client.
     *
     * @example
     * ```
     * let writeBatch = firestore.batch();
     *
     * // Add two documents in an atomic batch.
     * let data = { foo: 'bar' };
     * writeBatch.set(firestore.doc('col/doc1'), data);
     * writeBatch.set(firestore.doc('col/doc2'), data);
     *
     * writeBatch.commit().then(res => {
     *   console.log('Successfully executed batch.');
     * });
     * ```
     */ batch() {
        return new write_batch_1.WriteBatch(this);
    }
    /**
     * Creates a [BulkWriter]{@link BulkWriter}, used for performing
     * multiple writes in parallel. Gradually ramps up writes as specified
     * by the 500/50/5 rule.
     *
     * If you pass [BulkWriterOptions]{@link BulkWriterOptions}, you can
     * configure the throttling rates for the created BulkWriter.
     *
     * @see [500/50/5 Documentation]{@link https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic}
     *
     * @param {BulkWriterOptions=} options BulkWriter options.
     * @returns {BulkWriter} A BulkWriter that operates on this Firestore
     * client.
     *
     * @example
     * ```
     * let bulkWriter = firestore.bulkWriter();
     *
     * bulkWriter.create(firestore.doc('col/doc1'), {foo: 'bar'})
     *   .then(res => {
     *     console.log(`Added document at ${res.writeTime}`);
     *   });
     * bulkWriter.update(firestore.doc('col/doc2'), {foo: 'bar'})
     *   .then(res => {
     *     console.log(`Updated document at ${res.writeTime}`);
     *   });
     * bulkWriter.delete(firestore.doc('col/doc3'))
     *   .then(res => {
     *     console.log(`Deleted document at ${res.writeTime}`);
     *   });
     * await bulkWriter.close().then(() => {
     *   console.log('Executed all writes');
     * });
     * ```
     */ bulkWriter(options) {
        return new bulk_writer_1.BulkWriter(this, options);
    }
    /** @private */ snapshot_(documentOrName, readTime, encoding) {
        // TODO: Assert that Firestore Project ID is valid.
        let convertTimestamp;
        let convertFields;
        if (encoding === undefined || encoding === 'protobufJS') {
            convertTimestamp = (data)=>data;
            convertFields = (data)=>data;
        } else if (encoding === 'json') {
            // Google Cloud Functions calls us with Proto3 JSON format data, which we
            // must convert to Protobuf JS.
            convertTimestamp = convert_1.timestampFromJson;
            convertFields = convert_1.fieldsFromJson;
        } else {
            throw new Error('Unsupported encoding format. Expected "json" or "protobufJS", ' + `but was "${encoding}".`);
        }
        let ref;
        let document;
        if (typeof documentOrName === 'string') {
            ref = new document_reference_1.DocumentReference(this, path_1.QualifiedResourcePath.fromSlashSeparatedString(documentOrName));
            document = new document_1.DocumentSnapshotBuilder(ref);
        } else {
            ref = new document_reference_1.DocumentReference(this, path_1.QualifiedResourcePath.fromSlashSeparatedString(documentOrName.name));
            document = new document_1.DocumentSnapshotBuilder(ref);
            document.fieldsProto = documentOrName.fields ? convertFields(documentOrName.fields) : {};
            document.createTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.createTime, 'documentOrName.createTime'));
            document.updateTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.updateTime, 'documentOrName.updateTime'));
        }
        if (readTime) {
            document.readTime = timestamp_1.Timestamp.fromProto(convertTimestamp(readTime, 'readTime'));
        }
        return document.build();
    }
    /**
     * Creates a new `BundleBuilder` instance to package selected Firestore data into
     * a bundle.
     *
     * @param bundleId. The id of the bundle. When loaded on clients, client SDKs use this id
     * and the timestamp associated with the built bundle to tell if it has been loaded already.
     * If not specified, a random identifier will be used.
     */ bundle(name) {
        return new bundle_1.BundleBuilder(name || (0, util_1.autoId)());
    }
    /**
     * Function executed by {@link Firestore#runTransaction} within the transaction
     * context.
     *
     * @callback Firestore~updateFunction
     * @template T
     * @param {Transaction} transaction The transaction object for this
     * transaction.
     * @returns {Promise<T>} The promise returned at the end of the transaction.
     * This promise will be returned by {@link Firestore#runTransaction} if the
     * transaction completed successfully.
     */ /**
     * Options object for {@link Firestore#runTransaction} to configure a
     * read-only transaction.
     *
     * @param {true} readOnly Set to true to indicate a read-only transaction.
     * @param {Timestamp=} readTime If specified, documents are read at the given
     * time. This may not be more than 60 seconds in the past from when the
     * request is processed by the server.
     * @typedef {Object} Firestore~ReadOnlyTransactionOptions
     */ /**
     * Options object for {@link Firestore#runTransaction} to configure a
     * read-write transaction.
     *
     * @param {false=} readOnly Set to false or omit to indicate a read-write
     * transaction.
     * @param {number=} maxAttempts The maximum number of attempts for this
     * transaction. Defaults to 5.
     * @typedef {Object} Firestore~ReadWriteTransactionOptions
     */ /**
     * Executes the given updateFunction and commits the changes applied within
     * the transaction.
     *
     * You can use the transaction object passed to 'updateFunction' to read and
     * modify Firestore documents under lock. You have to perform all reads before
     * before you perform any write.
     *
     * Transactions can be performed as read-only or read-write transactions. By
     * default, transactions are executed in read-write mode.
     *
     * A read-write transaction obtains a pessimistic lock on all documents that
     * are read during the transaction. These locks block other transactions,
     * batched writes, and other non-transactional writes from changing that
     * document. Any writes in a read-write transactions are committed once
     * 'updateFunction' resolves, which also releases all locks.
     *
     * If a read-write transaction fails with contention, the transaction is
     * retried up to five times. The `updateFunction` is invoked once for each
     * attempt.
     *
     * Read-only transactions do not lock documents. They can be used to read
     * documents at a consistent snapshot in time, which may be up to 60 seconds
     * in the past. Read-only transactions are not retried.
     *
     * Transactions time out after 60 seconds if no documents are read.
     * Transactions that are not committed within than 270 seconds are also
     * aborted. Any remaining locks are released when a transaction times out.
     *
     * @template T
     * @param {Firestore~updateFunction} updateFunction The user function to
     * execute within the transaction context.
     * @param {
     * Firestore~ReadWriteTransactionOptions|Firestore~ReadOnlyTransactionOptions=
     * } transactionOptions Transaction options.
     * @returns {Promise<T>} If the transaction completed successfully or was
     * explicitly aborted (by the updateFunction returning a failed Promise), the
     * Promise returned by the updateFunction will be returned here. Else if the
     * transaction failed, a rejected Promise with the corresponding failure
     * error will be returned.
     *
     * @example
     * ```
     * let counterTransaction = firestore.runTransaction(transaction => {
     *   let documentRef = firestore.doc('col/doc');
     *   return transaction.get(documentRef).then(doc => {
     *     if (doc.exists) {
     *       let count =  doc.get('count') || 0;
     *       if (count > 10) {
     *         return Promise.reject('Reached maximum count');
     *       }
     *       transaction.update(documentRef, { count: ++count });
     *       return Promise.resolve(count);
     *     }
     *
     *     transaction.create(documentRef, { count: 1 });
     *     return Promise.resolve(1);
     *   });
     * });
     *
     * counterTransaction.then(res => {
     *   console.log(`Count updated to ${res}`);
     * });
     * ```
     */ runTransaction(updateFunction, transactionOptions) {
        (0, validate_1.validateFunction)('updateFunction', updateFunction);
        const tag = (0, util_1.requestTag)();
        if (transactionOptions) {
            (0, validate_1.validateObject)('transactionOptions', transactionOptions);
            (0, validate_1.validateBoolean)('transactionOptions.readOnly', transactionOptions.readOnly, {
                optional: true
            });
            if (transactionOptions.readOnly) {
                (0, validate_1.validateTimestamp)('transactionOptions.readTime', transactionOptions.readTime, {
                    optional: true
                });
            } else {
                (0, validate_1.validateInteger)('transactionOptions.maxAttempts', transactionOptions.maxAttempts, {
                    optional: true,
                    minValue: 1
                });
            }
        }
        const transaction = new transaction_1.Transaction(this, tag, transactionOptions);
        return this.initializeIfNeeded(tag).then(()=>transaction.runTransaction(updateFunction));
    }
    /**
     * Fetches the root collections that are associated with this Firestore
     * database.
     *
     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves
     * with an array of CollectionReferences.
     *
     * @example
     * ```
     * firestore.listCollections().then(collections => {
     *   for (let collection of collections) {
     *     console.log(`Found collection with id: ${collection.id}`);
     *   }
     * });
     * ```
     */ listCollections() {
        const rootDocument = new document_reference_1.DocumentReference(this, path_1.ResourcePath.EMPTY);
        return rootDocument.listCollections();
    }
    /**
     * Retrieves multiple documents from Firestore.
     *
     * The first argument is required and must be of type `DocumentReference`
     * followed by any additional `DocumentReference` documents. If used, the
     * optional `ReadOptions` must be the last argument.
     *
     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The
     * `DocumentReferences` to receive, followed by an optional field mask.
     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that
     * contains an array with the resulting document snapshots.
     *
     * @example
     * ```
     * let docRef1 = firestore.doc('col/doc1');
     * let docRef2 = firestore.doc('col/doc2');
     *
     * firestore.getAll(docRef1, docRef2, { fieldMask: ['user'] }).then(docs => {
     *   console.log(`First document: ${JSON.stringify(docs[0])}`);
     *   console.log(`Second document: ${JSON.stringify(docs[1])}`);
     * });
     * ```
     */ getAll(...documentRefsOrReadOptions) {
        return this._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_BATCH_GET_DOCUMENTS, ()=>{
            (0, validate_1.validateMinNumberOfArguments)('Firestore.getAll', documentRefsOrReadOptions, 1);
            const { documents, fieldMask } = (0, transaction_1.parseGetAllArguments)(documentRefsOrReadOptions);
            this._traceUtil.currentSpan().setAttributes({
                [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: false,
                [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: documents.length
            });
            const tag = (0, util_1.requestTag)();
            // Capture the error stack to preserve stack tracing across async calls.
            const stack = Error().stack;
            return this.initializeIfNeeded(tag).then(()=>{
                const reader = new document_reader_1.DocumentReader(this, documents, fieldMask);
                return reader.get(tag);
            }).catch((err)=>{
                throw (0, util_1.wrapError)(err, stack);
            });
        });
    }
    /**
     * Registers a listener on this client, incrementing the listener count. This
     * is used to verify that all listeners are unsubscribed when terminate() is
     * called.
     *
     * @private
     * @internal
     */ registerListener() {
        this.registeredListenersCount += 1;
    }
    /**
     * Unregisters a listener on this client, decrementing the listener count.
     * This is used to verify that all listeners are unsubscribed when terminate()
     * is called.
     *
     * @private
     * @internal
     */ unregisterListener() {
        this.registeredListenersCount -= 1;
    }
    /**
     * Increments the number of open BulkWriter instances. This is used to verify
     * that all pending operations are complete when terminate() is called.
     *
     * @private
     * @internal
     */ _incrementBulkWritersCount() {
        this.bulkWritersCount += 1;
    }
    /**
     * Decrements the number of open BulkWriter instances. This is used to verify
     * that all pending operations are complete when terminate() is called.
     *
     * @private
     * @internal
     */ _decrementBulkWritersCount() {
        this.bulkWritersCount -= 1;
    }
    /**
     * Recursively deletes all documents and subcollections at and under the
     * specified level.
     *
     * If any delete fails, the promise is rejected with an error message
     * containing the number of failed deletes and the stack trace of the last
     * failed delete. The provided reference is deleted regardless of whether
     * all deletes succeeded.
     *
     * `recursiveDelete()` uses a BulkWriter instance with default settings to
     * perform the deletes. To customize throttling rates or add success/error
     * callbacks, pass in a custom BulkWriter instance.
     *
     * @param ref The reference of a document or collection to delete.
     * @param bulkWriter A custom BulkWriter instance used to perform the
     * deletes.
     * @return A promise that resolves when all deletes have been performed.
     * The promise is rejected if any of the deletes fail.
     *
     * @example
     * ```
     * // Recursively delete a reference and log the references of failures.
     * const bulkWriter = firestore.bulkWriter();
     * bulkWriter
     *   .onWriteError((error) => {
     *     if (
     *       error.failedAttempts < MAX_RETRY_ATTEMPTS
     *     ) {
     *       return true;
     *     } else {
     *       console.log('Failed write at document: ', error.documentRef.path);
     *       return false;
     *     }
     *   });
     * await firestore.recursiveDelete(docRef, bulkWriter);
     * ```
     */ recursiveDelete(ref, bulkWriter) {
        return this._recursiveDelete(ref, recursive_delete_1.RECURSIVE_DELETE_MAX_PENDING_OPS, recursive_delete_1.RECURSIVE_DELETE_MIN_PENDING_OPS, bulkWriter);
    }
    /**
     * This overload is not private in order to test the query resumption with
     * startAfter() once the RecursiveDelete instance has MAX_PENDING_OPS pending.
     *
     * @private
     * @internal
     */ // Visible for testing
    _recursiveDelete(ref, maxPendingOps, minPendingOps, bulkWriter) {
        const writer = bulkWriter !== null && bulkWriter !== void 0 ? bulkWriter : this.getBulkWriter();
        const deleter = new recursive_delete_1.RecursiveDelete(this, writer, ref, maxPendingOps, minPendingOps);
        return deleter.run();
    }
    /**
     * Terminates the Firestore client and closes all open streams.
     *
     * @return A Promise that resolves when the client is terminated.
     */ async terminate() {
        if (this._bulkWriter) {
            await this._bulkWriter.close();
            this._bulkWriter = undefined;
        }
        if (this.registeredListenersCount > 0 || this.bulkWritersCount > 0) {
            return Promise.reject('All onSnapshot() listeners must be unsubscribed, and all BulkWriter ' + 'instances must be closed before terminating the client. ' + `There are ${this.registeredListenersCount} active listeners and ` + `${this.bulkWritersCount} open BulkWriter instances.`);
        }
        return this._clientPool.terminate();
    }
    /**
     * Returns the Project ID to serve as the JSON representation of this
     * Firestore instance.
     *
     * @return An object that contains the project ID (or `undefined` if not yet
     * available).
     */ toJSON() {
        return {
            projectId: this._projectId
        };
    }
    /**
     * Initializes the client if it is not already initialized. All methods in the
     * SDK can be used after this method completes.
     *
     * @private
     * @internal
     * @param requestTag A unique client-assigned identifier that caused this
     * initialization.
     * @return A Promise that resolves when the client is initialized.
     */ async initializeIfNeeded(requestTag) {
        this._settingsFrozen = true;
        if (this._settings.ssl === false) {
            // If SSL is false, we assume that we are talking to the emulator. We
            // provide an Authorization header by default so that the connection is
            // recognized as admin in Firestore Emulator. (If for some reason we're
            // not connecting to the emulator, then this will result in denials with
            // invalid token, rather than behave like clients not logged in. The user
            // can then provide their own Authorization header, which will take
            // precedence).
            this._settings.customHeaders = {
                Authorization: 'Bearer owner',
                ...this._settings.customHeaders
            };
        }
        if (this._projectId === undefined) {
            try {
                this._projectId = await this._clientPool.run(requestTag, /* requiresGrpc= */ false, (gapicClient)=>gapicClient.getProjectId());
                (0, logger_1.logger)('Firestore.initializeIfNeeded', null, 'Detected project ID: %s', this._projectId);
                // If the project ID was undefined when the TraceUtil was set up, we
                // need to record it.
                this._traceUtil.recordProjectId(this.projectId);
            } catch (err) {
                (0, logger_1.logger)('Firestore.initializeIfNeeded', null, 'Failed to detect project ID: %s', err);
                return Promise.reject(err);
            }
        }
    }
    /**
     * Returns GAX call options that set the cloud resource header.
     * @private
     * @internal
     */ createCallOptions(methodName, retryCodes) {
        var _a;
        const callOptions = {
            otherArgs: {
                headers: {
                    [CLOUD_RESOURCE_HEADER]: this.formattedName,
                    ...this._settings.customHeaders,
                    ...(_a = this._settings[methodName]) === null || _a === void 0 ? void 0 : _a.customHeaders
                }
            }
        };
        if (retryCodes) {
            const retryParams = (0, util_1.getRetryParams)(methodName);
            callOptions.retry = new (__turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)")).RetryOptions(retryCodes, retryParams);
        }
        return callOptions;
    }
    /**
     * A function returning a Promise that can be retried.
     *
     * @private
     * @internal
     * @callback retryFunction
     * @returns {Promise} A Promise indicating the function's success.
     */ /**
     * Helper method that retries failed Promises.
     *
     * If 'delayMs' is specified, waits 'delayMs' between invocations. Otherwise,
     * schedules the first attempt immediately, and then waits 100 milliseconds
     * for further attempts.
     *
     * @private
     * @internal
     * @param methodName Name of the Veneer API endpoint that takes a request
     * and GAX options.
     * @param requestTag A unique client-assigned identifier for this request.
     * @param func Method returning a Promise than can be retried.
     * @returns A Promise with the function's result if successful within
     * `attemptsRemaining`. Otherwise, returns the last rejected Promise.
     */ async _retry(methodName, requestTag, func) {
        const backoff = new backoff_1.ExponentialBackoff();
        let lastError = undefined;
        for(let attempt = 0; attempt < exports.MAX_REQUEST_RETRIES; ++attempt){
            if (lastError) {
                (0, logger_1.logger)('Firestore._retry', requestTag, 'Retrying request that failed with error:', lastError);
            }
            try {
                await backoff.backoffAndWait();
                return await func();
            } catch (err) {
                lastError = err;
                if ((0, util_1.isPermanentRpcError)(err, methodName)) {
                    break;
                }
            }
        }
        (0, logger_1.logger)('Firestore._retry', requestTag, 'Request failed with error:', lastError);
        return Promise.reject(lastError);
    }
    /**
     * Waits for the provided stream to become active and returns a paused but
     * healthy stream. If an error occurs before the first byte is read, the
     * method rejects the returned Promise.
     *
     * @private
     * @internal
     * @param backendStream The Node stream to monitor.
     * @param lifetime A Promise that resolves when the stream receives an 'end',
     * 'close' or 'finish' message.
     * @param requestTag A unique client-assigned identifier for this request.
     * @param request If specified, the request that should be written to the
     * stream after opening.
     * @returns A guaranteed healthy stream that should be used instead of
     * `backendStream`.
     */ _initializeStream(backendStream, lifetime, requestTag, request) {
        const resultStream = new stream_1.PassThrough({
            objectMode: true
        });
        resultStream.pause();
        /**
         * Whether we have resolved the Promise and returned the stream to the
         * caller.
         */ let streamInitialized = false;
        return new Promise((resolve, reject)=>{
            function streamReady() {
                if (!streamInitialized) {
                    streamInitialized = true;
                    (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Stream ready');
                    resolve(resultStream);
                }
            }
            function streamEnded() {
                (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Received stream end');
                resultStream.unpipe(backendStream);
                resolve(resultStream);
                lifetime.resolve();
            }
            function streamFailed(err) {
                if (!streamInitialized) {
                    // If we receive an error before we were able to receive any data,
                    // reject this stream.
                    (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Received initial error:', err);
                    reject(err);
                } else {
                    (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Received stream error:', err);
                    // We execute the forwarding of the 'error' event via setImmediate() as
                    // V8 guarantees that the Promise chain returned from this method
                    // is resolved before any code executed via setImmediate(). This
                    // allows the caller to attach an error handler.
                    setImmediate(()=>{
                        resultStream.emit('error', err);
                    });
                }
            }
            backendStream.on('data', ()=>streamReady());
            backendStream.on('error', (err)=>streamFailed(err));
            backendStream.on('end', ()=>streamEnded());
            backendStream.on('close', ()=>streamEnded());
            backendStream.on('finish', ()=>streamEnded());
            backendStream.pipe(resultStream);
            if (request) {
                (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Sending request: %j', request);
                backendStream.write(request, 'utf-8', (err)=>{
                    if (err) {
                        streamFailed(err);
                    } else {
                        (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Marking stream as healthy');
                        streamReady();
                    }
                });
            }
        });
    }
    /**
     * A funnel for all non-streaming API requests, assigning a project ID where
     * necessary within the request options.
     *
     * @private
     * @internal
     * @param methodName Name of the Veneer API endpoint that takes a request
     * and GAX options.
     * @param request The Protobuf request to send.
     * @param requestTag A unique client-assigned identifier for this request.
     * @param retryCodes If provided, a custom list of retry codes. If not
     * provided, retry is based on the behavior as defined in the ServiceConfig.
     * @returns A Promise with the request result.
     */ request(methodName, request, requestTag, retryCodes) {
        const callOptions = this.createCallOptions(methodName, retryCodes);
        return this._clientPool.run(requestTag, /* requiresGrpc= */ false, async (gapicClient)=>{
            try {
                (0, logger_1.logger)('Firestore.request', requestTag, 'Sending request: %j', request);
                const [result] = await gapicClient[methodName](request, callOptions);
                (0, logger_1.logger)('Firestore.request', requestTag, 'Received response: %j', result);
                return result;
            } catch (err) {
                (0, logger_1.logger)('Firestore.request', requestTag, 'Received error:', err);
                return Promise.reject(err);
            }
        });
    }
    /**
     * A funnel for streaming API requests, assigning a project ID where necessary
     * within the request options.
     *
     * The stream is returned in paused state and needs to be resumed once all
     * listeners are attached.
     *
     * @private
     * @internal
     * @param methodName Name of the streaming Veneer API endpoint that
     * takes a request and GAX options.
     * @param bidrectional Whether the request is bidirectional (true) or
     * unidirectional (false_
     * @param request The Protobuf request to send.
     * @param requestTag A unique client-assigned identifier for this request.
     * @returns A Promise with the resulting read-only stream.
     */ requestStream(methodName, bidrectional, request, requestTag) {
        const callOptions = this.createCallOptions(methodName);
        const bidirectional = methodName === 'listen';
        let numResponses = 0;
        const NUM_RESPONSES_PER_TRACE_EVENT = 100;
        return this._retry(methodName, requestTag, ()=>{
            const result = new util_1.Deferred();
            this._clientPool.run(requestTag, bidrectional, async (gapicClient)=>{
                (0, logger_1.logger)('Firestore.requestStream', requestTag, 'Sending request: %j', request);
                this._traceUtil.currentSpan().addEvent(`Firestore.${methodName}: Start`);
                try {
                    const stream = bidirectional ? gapicClient[methodName](callOptions) : gapicClient[methodName](request, callOptions);
                    const logStream = new stream_1.Transform({
                        objectMode: true,
                        transform: (chunk, encoding, callback)=>{
                            (0, logger_1.logger)('Firestore.requestStream', requestTag, 'Received response: %j', chunk);
                            numResponses++;
                            if (numResponses === 1) {
                                this._traceUtil.currentSpan().addEvent(`Firestore.${methodName}: First response received`);
                            } else if (numResponses % NUM_RESPONSES_PER_TRACE_EVENT === 0) {
                                this._traceUtil.currentSpan().addEvent(`Firestore.${methodName}: Received ${numResponses} responses`);
                            }
                            callback();
                        }
                    });
                    stream.pipe(logStream);
                    const lifetime = new util_1.Deferred();
                    const resultStream = await this._initializeStream(stream, lifetime, requestTag, bidirectional ? request : undefined);
                    resultStream.on('end', ()=>{
                        stream.end();
                        this._traceUtil.currentSpan().addEvent(`Firestore.${methodName}: Completed`, {
                            [trace_util_1.ATTRIBUTE_KEY_NUM_RESPONSES]: numResponses
                        });
                    });
                    result.resolve(resultStream);
                    // While we return the stream to the callee early, we don't want to
                    // release the GAPIC client until the callee has finished processing the
                    // stream.
                    return lifetime.promise;
                } catch (e) {
                    result.reject(e);
                }
            });
            return result.promise;
        });
    }
}
exports.Firestore = Firestore;
/**
 * A logging function that takes a single string.
 *
 * @callback Firestore~logFunction
 * @param {string} Log message
 */ // tslint:disable-next-line:no-default-export
/**
 * The default export of the `@google-cloud/firestore` package is the
 * {@link Firestore} class.
 *
 * See {@link Firestore} and {@link ClientConfig} for client methods and
 * configuration options.
 *
 * @module {Firestore} @google-cloud/firestore
 * @alias nodejs-firestore
 *
 * @example Install the client library with <a href="https://www.npmjs.com/">npm</a>:
 * ```
 * npm install --save @google-cloud/firestore
 *
 * ```
 * @example Import the client library
 * ```
 * var Firestore = require('@google-cloud/firestore');
 *
 * ```
 * @example Create a client that uses <a href="https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application">Application Default Credentials (ADC)</a>:
 * ```
 * var firestore = new Firestore();
 *
 * ```
 * @example Create a client with <a href="https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually">explicit credentials</a>:
 * ```
 * var firestore = new Firestore({ projectId:
 *   'your-project-id', keyFilename: '/path/to/keyfile.json'
 * });
 *
 * ```
 * @example <caption>include:samples/quickstart.js</caption>
 * region_tag:firestore_quickstart
 * Full quickstart example:
 */ // tslint:disable-next-line:no-default-export
exports.default = Firestore;
// Horrible hack to ensure backwards compatibility with <= 17.0, which allows
// users to call the default constructor via
// `const Fs = require(`@google-cloud/firestore`); new Fs()`;
const existingExports = module.exports;
module.exports = Firestore;
module.exports = Object.assign(module.exports, existingExports);
/**
 * {@link v1beta1} factory function.
 *
 * @private
 * @internal
 * @name Firestore.v1beta1
 * @type {function}
 */ Object.defineProperty(module.exports, 'v1beta1', {
    // The v1beta1 module is very large. To avoid pulling it in from static
    // scope, we lazy-load the module.
    get: ()=>__turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1beta1/index.js [app-client] (ecmascript)")
});
/**
 * {@link v1} factory function.
 *
 * @private
 * @internal
 * @name Firestore.v1
 * @type {function}
 */ Object.defineProperty(module.exports, 'v1', {
    // The v1 module is very large. To avoid pulling it in from static
    // scope, we lazy-load  the module.
    get: ()=>__turbopack_context__.r("[project]/node_modules/@google-cloud/firestore/build/src/v1/index.js [app-client] (ecmascript)")
});
/**
 * {@link Status} factory function.
 *
 * @private
 * @internal
 * @name Firestore.GrpcStatus
 * @type {function}
 */ Object.defineProperty(module.exports, 'GrpcStatus', {
    // The gax module is very large. To avoid pulling it in from static
    // scope, we lazy-load the module.
    get: ()=>__turbopack_context__.r("[project]/node_modules/google-gax/build/src/fallback.js [app-client] (ecmascript)").Status
}); //# sourceMappingURL=index.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40google-cloud_firestore_build_src_52c8d2bb._.js.map